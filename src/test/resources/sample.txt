# Flow Components
## Accordion

Accordion is a vertically stacked set of expandable panels. It reduces clutter and helps maintain the user’s focus by showing only the relevant content at any time.

```java
Accordion accordion = new Accordion();

Span name = new Span("Sophia Williams");
Span email = new Span("sophia.williams@company.com");
Span phone = new Span("(501) 555-9128");

VerticalLayout personalInformationLayout = new VerticalLayout(name,
        email, phone);
personalInformationLayout.setSpacing(false);
personalInformationLayout.setPadding(false);

accordion.add("Personal information", personalInformationLayout);
```

## Anatomy

Accordion consists of stacked panels, each composed of two parts: a summary and a content area. Only one panel can be expanded at a time. Use the  [Details](https://vaadin.com/docs/latest/components/details)  component to allow multiple, simultaneously expanded sections.

### Summary

The summary is the part that’s always visible, and typically describes the content, for example, with a title. Clicking on the summary toggles the content area’s visibility.

The summary supports rich content and can contain any component. This can be utilized, for example, to display the status of the corresponding content.

```java
AccordionPanel customDetailsPanel = accordion.add(CUSTOMER_DETAILS,
        customerDetailsFormLayout);
customDetailsPanel.addOpenedChangeListener(e -> {
    if (e.isOpened()) {
        customDetailsPanel.setSummaryText(CUSTOMER_DETAILS);
    } else if (personBinder.getBean() != null) {
        Person personValues = personBinder.getBean();
        customDetailsPanel.setSummary(createSummary(CUSTOMER_DETAILS,
                personValues.getFirstName() + " "
                        + personValues.getLastName(),
                personValues.getEmail(),
                personValues.getAddress() != null
                        ? personValues.getAddress().getPhone()
                        : ""));
    }
});
```

### Content

This is the collapsible part of a panel. It can contain any component. When the content area is collapsed, the content is invisible and inaccessible by keyboard or screen reader.

```java
Accordion accordion = new Accordion();

accordion.add("Analytics",
        createContent(createStyledAnchor("#", "Dashboard"),
                createStyledAnchor("#", "Reports"),
                createStyledAnchor("#", "Data sources")));
```

## Theme Variants

Accordion has three theme variants:  `filled`,  `small`, and  `reverse`. Set the theme attribute separately for each panel, not on Accordion itself. Theme names can be combined with each other. For example, all three themes variants can be applied to a panel.

### Filled Panels

The  `filled`  theme variant makes the panel’s boundaries visible. This helps tie its content together visually and distinguishes it from the surrounding UI.

```java
Accordion accordion = new Accordion();
AccordionPanel personalInfoPanel = accordion.add("Personal information",
        personalInformationLayout);
personalInfoPanel.addThemeVariants(DetailsVariant.FILLED);
```

### Small Panels

Use the  `small`  theme variant for compact UIs.

```java
AccordionPanel paymentPanel = accordion.add("Payment", paymentLayout);
paymentPanel.addThemeVariants(DetailsVariant.SMALL);
```

### Reverse Panels

The  `reverse`  theme variant places the toggle icon after the summary contents. This can be useful for aligning visually the summary with other content.


```java
AccordionPanel paymentPanel = accordion.add("Payment", paymentLayout);
paymentPanel.addThemeVariants(DetailsVariant.REVERSE);
```

## Disabled Panels

Accordion panels can be disabled to prevent them from being expanded or collapsed. Details can also be disabled to prevent them from being expanded or collapsed. Components inside a disabled expanded panel are automatically disabled as well.

```java
Accordion accordion = new Accordion();
AccordionPanel billingAddressPanel = accordion.add("Billing address",
        billingAddressLayout);
billingAddressPanel.setEnabled(false);
```

## Best Practices

Accordions are suitable when users need to focus on smaller pieces of content at any given time. However, when all of the content is relevant to the user to make a decision, Accordions should be avoided. Content areas that are logically linked should be grouped together in one panel.

Accordions are better suited than Tabs for long labels. However, Accordions can feel  _jumpy_  as panels are toggled — especially if there are several panels or the panel content is long.

Details can be used instead of Accordion when there is a need to see content from multiple panels, simultaneously.

Accordions can be used to break a complex form into smaller step-by-step sections.

The expandable and collapsible nature of accordions can sometimes be difficult for users to discover. Use the  [filled variant](https://vaadin.com/docs/latest/components/accordion#filled-panels)  and apply  [tooltips](https://vaadin.com/docs/latest/components/tooltip)  on the panels to make this more discoverable.

# App Layout

App Layout is a component for building common application layouts.

Scaled down examples

The examples on this page are scaled down so that their viewport-size-dependent behavior can be demonstrated. Some examples also change their behavior based on your browser viewport size.

```java
public class AppLayoutBasic extends AppLayout {

    public AppLayoutBasic() {
        DrawerToggle toggle = new DrawerToggle();

        H1 title = new H1("MyApp");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "0");

        SideNav nav = getSideNav();

        Scroller scroller = new Scroller(nav);
        scroller.setClassName(LumoUtility.Padding.SMALL);

        addToDrawer(scroller);
        addToNavbar(toggle, title);
    }
}
```

The layout consists of three sections: a horizontal navigation bar (**navbar**), a collapsible navigation drawer (**drawer**) and a content area. An application’s main navigation blocks should be positioned in the navbar and/or drawer, whereas views are rendered in the content area.

App Layout is responsive and adjusts automatically to fit desktop, tablet, and mobile screen sizes.

## Navbar Placement

The navbar can be located on top or to the side of the drawer.

When put on top, the navbar is typically used as an application header. Application headers contain, for example, the application’s name and branding, as well as actions that apply to the entire application, such as notifications, settings, etc.

```java
public class AppLayoutNavbarPlacement extends AppLayout {

    public AppLayoutNavbarPlacement() {
        DrawerToggle toggle = new DrawerToggle();

        H1 title = new H1("MyApp");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "0");

        SideNav nav = getSideNav();

        Scroller scroller = new Scroller(nav);
        scroller.setClassName(LumoUtility.Padding.SMALL);

        addToDrawer(scroller);
        addToNavbar(toggle, title);
    }
}
```

When placed to the side, the navbar is often seen as a view header, housing the view’s title, and actions and secondary navigation that relate only to the current view.

```java
public class AppLayoutNavbarPlacementSide extends AppLayout {

    public AppLayoutNavbarPlacementSide() {
        DrawerToggle toggle = new DrawerToggle();

        H1 title = new H1("Dashboard");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "0");

        SideNav nav = getSideNav();

        Scroller scroller = new Scroller(nav);
        scroller.setClassName(LumoUtility.Padding.SMALL);

        addToDrawer(scroller);
        addToNavbar(toggle, title);

        setPrimarySection(Section.DRAWER);
    }
}
```

## Drawer Toggle

Show and hide the drawer using a Drawer Toggle (or a Button). The Drawer Toggle (☰) should always be accessible (unless the drawer is empty) and is most often situated in the navbar.

## Scrolling Behavior

Depending on whether App Layout has a defined height, the way the content inside the layout scrolls can differ.

### Auto Height

When the App Layout has an undefined/auto height, which is the default behavior, the  `<body>`  element is the scrolling container for the content inside the layout.

```java
public class AppLayoutHeightAuto extends AppLayout {

    public AppLayoutHeightAuto() {
        H1 title = new H1("MyApp");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "var(--lumo-space-m)");
        addToNavbar(title);

        Grid<Person> grid = new Grid<>(Person.class, false);
        grid.addColumn(Person::getFirstName).setHeader("First name");
        grid.addColumn(Person::getLastName).setHeader("Last name");
        grid.addColumn(Person::getEmail).setHeader("Email");
        grid.addColumn(Person::getProfession).setHeader("Profession");

        List<Person> people = DataService.getPeople(20);
        grid.setItems(people);
        grid.setAllRowsVisible(true);
        setContent(grid);
    }
}
```

The vertical scrollbar crosses the App Layout navbar and the content flows under it, allowing for translucent visual styles. Mobile browsers collapse and expand their toolbars when the user scrolls down and up, respectively. On iOS, you can tap the status bar (signal strength, battery, clock, etc.) to scroll back to the top of the page/view.

This behavior isn’t compatible with vertically scrollable Grids, or other scrolling containers within the content area whose height is 100%. To support those, define 100% height for the App Layout.

### Full Height (100%)

To allow a nested component to take all the available vertical space inside the App Layout, you need to set an explicit height for the layout, commonly 100%. A common use case is to let a data grid fill the entire content area.

Make sure all parent components/elements have 100% height

The full hierarchy of components from the App Layout to the  `<body>`  element need to have 100% height.

```java
public class AppLayoutHeightFull extends AppLayout {

    public AppLayoutHeightFull() {
        H1 title = new H1("MyApp");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "var(--lumo-space-m)");
        addToNavbar(title);

        Grid<Person> grid = new Grid<>(Person.class, false);
        grid.addColumn(Person::getFirstName).setHeader("First name");
        grid.addColumn(Person::getLastName).setHeader("Last name");
        grid.addColumn(Person::getEmail).setHeader("Email");
        grid.addColumn(Person::getProfession).setHeader("Profession");

        List<Person> people = DataService.getPeople();
        grid.setItems(people);
        setContent(grid);

        getElement().getStyle().set("height", "100%");
        grid.setHeight("100%");
        grid.addThemeVariants(GridVariant.LUMO_NO_BORDER);
    }
}
```

The vertical scrollbar stays within the layout content area, and mobile browsers don’t collapse their toolbars when the content area is scrolled down.

## Bottom Navbar on Small Touchscreens

When the navbar is used for navigation, the  **touch-optimized navbar**  slot can be used to provide a separate version of the navigation at the bottom of the UI, optimized for mobile phones.

```java
public class AppLayoutBottomNavbar extends AppLayout {

    public AppLayoutBottomNavbar() {
        H1 title = new H1("MyApp");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "var(--lumo-space-m) var(--lumo-space-l)");

        HorizontalLayout nav = getNavigation();

        H2 viewTitle = new H2("View title");
        Paragraph viewContent = new Paragraph("View content");

        Div content = new Div();
        content.add(viewTitle, viewContent);

        addToNavbar(title);
        addToNavbar(true, nav);

        setContent(content);
    }
}
```

## Best Practices

### Navbar vs Drawer

Make the choice between navbar and drawer based primarily on the number of items placed in it.

The navbar is a good choice for a small number of items (3–5), as these can fit into the viewport without scrolling.

```java
public class AppLayoutNavbar extends AppLayout {

    public AppLayoutNavbar() {
        H1 title = new H1("MyApp");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("left", "var(--lumo-space-l)").set("margin", "0")
                .set("position", "absolute");

        HorizontalLayout navigation = getNavigation();
        navigation.getElement()

        addToNavbar(title, navigation);
    }
}
```

When more items need to be displayed, or if small-screen support is a priority, the drawer is a better choice, as it can accommodate a longer list of links without scrolling, and collapses into a hamburger menu on small screens. Furthermore, a vertical list of items is easier for the user to scan.

```java
public class AppLayoutDrawer extends AppLayout {

    public AppLayoutDrawer() {
        DrawerToggle toggle = new DrawerToggle();

        H1 title = new H1("Dashboard");
        title.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "0");

        SideNav nav = getTabs();

        Scroller scroller = new Scroller(nav);
        scroller.setClassName(LumoUtility.Padding.SMALL);

        addToDrawer(scroller);
        addToNavbar(toggle, title);

        setPrimarySection(Section.DRAWER);
    }
}
```

For applications that require multilevel or hierarchical navigation, use the drawer to (at least) house the first level. The secondary (and tertiary) navigation items can be placed in either the drawer or the navbar.


```java
public class AppLayoutSecondaryNavigation extends AppLayout {

    public AppLayoutSecondaryNavigation() {
        H1 appTitle = new H1("MyApp");
        appTitle.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("line-height", "var(--lumo-size-l)")
                .set("margin", "0 var(--lumo-space-m)");

        SideNav views = getPrimaryNavigation();

        Scroller scroller = new Scroller(views);
        scroller.setClassName(LumoUtility.Padding.SMALL);

        DrawerToggle toggle = new DrawerToggle();

        H2 viewTitle = new H2("Orders");
        viewTitle.getStyle().set("font-size", "var(--lumo-font-size-l)")
                .set("margin", "0");

        HorizontalLayout subViews = getSecondaryNavigation();

        HorizontalLayout wrapper = new HorizontalLayout(toggle, viewTitle);
        wrapper.setAlignItems(FlexComponent.Alignment.CENTER);
        wrapper.setSpacing(false);

        VerticalLayout viewHeader = new VerticalLayout(wrapper, subViews);
        viewHeader.setPadding(false);
        viewHeader.setSpacing(false);

        addToDrawer(appTitle, scroller);
        addToNavbar(viewHeader);

        setPrimarySection(Section.DRAWER);
    }
}
```

# Avatar

API:  [TypeScript](https://cdn.vaadin.com/vaadin-web-components/24.5.0-alpha11/#/elements/vaadin-avatar)  /  [Java](https://vaadin.com/api/platform/24.5.0.alpha14/com/vaadin/flow/component/avatar/Avatar.html)

Source:  [TypeScript](https://github.com/vaadin/web-components/tree/v24.5.0-alpha11/packages/avatar)  /  [Java](https://github.com/vaadin/flow-components/tree/24.5.0.alpha14/vaadin-avatar-flow-parent)

-   Usage
-   [Styling](https://vaadin.com/docs/latest/components/avatar/styling)

-   [Content](https://vaadin.com/docs/latest/components/avatar#content)
-   [Avatar Group](https://vaadin.com/docs/latest/components/avatar#avatar-group)
-   [Background Color](https://vaadin.com/docs/latest/components/avatar#background-color)
-   [Internationalisation (i18n)](https://vaadin.com/docs/latest/components/avatar#internationalisation-i18n)
-   [Size Variants](https://vaadin.com/docs/latest/components/avatar#size-variants)
-   [Use Cases](https://vaadin.com/docs/latest/components/avatar#use-cases)

Avatar is a graphical representation of an object or entity, for example, a person or an organization.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=avatar-basic-wc.js&import=component/avatar/avatar-basic.ts,component/avatar/react/avatar-basic.tsx)

Hide code

LitFlowReact

AvatarBasic.java

Expand code,Copyto clipboard

```java
Avatar avatarBasic = new Avatar();

Avatar avatarName = new Avatar(name);

Avatar avatarImage = new Avatar(name);
avatarImage.setImage(pictureUrl);
```

Real-time collaboration

This component is optimized for use with  [Collaboration Kit](https://vaadin.com/collaboration)  — a simple way to build real-time collaboration into your app — but can also be used standalone as a regular component.

## Content

Avatar has three properties:  **name**,  **abbreviation**, and  **image**.

### Name and Abbreviation

The name is shown on hover in a tooltip. When a name is set, Avatar auto-generates and display an abbreviation of the specified name. For example, “Allison Torres” becomes “AT”, “John Smith” becomes “JS”, and so on.

```java
Avatar avatarName = new Avatar(name);
```

The abbreviation can also be set manually. Abbreviations should be kept to a maximum of 2–3 characters.

```java
Avatar avatarName = new Avatar("Augusta Ada King");

Avatar avatarAbbr = new Avatar("Augusta Ada King");
avatarAbbr.setAbbreviation("AK");
```

### Image

Avatar can be used to display images, such as user profile pictures or company logos. Abbreviations aren’t shown when images are used.

```java
Avatar user = new Avatar(name);
user.setImage(pictureUrl);

Avatar company = new Avatar("Company Inc.");
StreamResource imageResource = new StreamResource("company-logo.png",
        () -> getClass()
                .getResourceAsStream("/images/company-logo.png"));
company.setImageResource(imageResource);
```

## Avatar Group

Avatar Group is used to group multiple Avatars together. It can be used, for example, to show that there are multiple users viewing the same page or for listing members of a project.

```java
AvatarGroup avatarGroup = new AvatarGroup();

for (Person person : people) {
    String name = person.getFirstName() + " " + person.getLastName();
    AvatarGroupItem avatar = new AvatarGroupItem(name);
    avatarGroup.add(avatar);
}
```

### Maximum Number of Items

You can specify the maximum number of items an Avatar Group should display. Items that overflow are grouped into a single Avatar that displays the overflow count. The name of each hidden item is shown on hover in a tooltip. Clicking the overflow item displays the overflowing avatars and names in a list.

```java
AvatarGroup avatarGroup = new AvatarGroup();
avatarGroup.setMaxItemsVisible(3);

for (Person person : people) {
    String name = person.getFirstName() + " " + person.getLastName();
    AvatarGroup.AvatarGroupItem avatar = new AvatarGroup.AvatarGroupItem(
            name);
    avatarGroup.add(avatar);
}
```

## Background Color

By default, there are 7 different background colors you can use for Avatar. The background color is set using a color index.

```java
AvatarGroup avatarGroup = new AvatarGroup();

for (Person person : people) {
    String name = person.getFirstName() + " " + person.getLastName();
    AvatarGroupItem avatar = new AvatarGroupItem(name);
    avatar.setColorIndex(colorIndex++);
    avatarGroup.add(avatar);
}
```

Using different background colors can be useful when you need to be able to distinguish between users, for example during collaborative work.

## Internationalisation (i18n)

All texts in Avatar and Avatar Group are configurable:

### Avatar Texts

Property

Text

Description

`anonymous`

"Anonymous"

Avatar’s default name. Shown on hover in a tooltip and announced by screen readers when the Avatar is focused.

Avatar Group Texts

Property

Text

Description

`anonymous`

"Anonymous"

Default name for all Avatars in the Avatar Group.

`activeUsers.one`

"Currently one active user"

Announced by screen readers when there is exactly one Avatar in an Avatar Group and the Avatar is focused. The name of the Avatar is read aloud first.

`activeUsers.many`

"Currently {count} active users"

Announced by screen readers when there are multiple Avatars in an Avatar Group and an Avatar is focused. The name of the focused Avatar is read aloud first.

*{count} is the Avatar Group item count.

`joined`

"{user} joined"

Announced by screen readers when an Avatar is added to the group.

*{user} is the Avatar’s name.

`left`

"{user} left"

Announced by screen readers when an Avatar is removed from the group.

*{user} is the Avatar’s name.

```java
AvatarGroupI18n i18n = new AvatarGroupI18n();
i18n.setAnonymous("Anonyymi");
i18n.setManyActiveUsers("Yksi käyttäjä aktiivisena");
i18n.setOneActiveUser("{count} käyttäjää aktiivisena");

AvatarGroup avatarGroup = new AvatarGroup();
avatarGroup.setI18n(i18n);

// Add anonymous user
avatarGroup.add(new AvatarGroupItem());

for (Person person : people) {
    String name = person.getFirstName() + " " + person.getLastName();
    AvatarGroupItem avatar = new AvatarGroupItem(name);
    avatarGroup.add(avatar);
}
```

## Size Variants

Avatar has four available size variants:

```java
Avatar xl = new Avatar(name);
xl.addThemeVariants(AvatarVariant.LUMO_XLARGE);

Avatar l = new Avatar(name);
l.addThemeVariants(AvatarVariant.LUMO_LARGE);

Avatar s = new Avatar(name);
s.addThemeVariants(AvatarVariant.LUMO_SMALL);

Avatar xs = new Avatar(name);
xs.addThemeVariants(AvatarVariant.LUMO_XSMALL);
```

Variant

Theme name

Extra large

`xlarge`

Large

`large`

Small

`small`

Extra small

`xsmall`

Size variants should be used only in special cases. See  [Size and Space](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties/size-space)  for details on how to change the default Avatar size.

## Use Cases

Avatar can be paired with Menu Bar to create a user account menu.

![](data:image/jpeg;base64,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)

```java
Avatar avatar = new Avatar(name);
avatar.setImage(pictureUrl);

MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_TERTIARY_INLINE);

MenuItem menuItem = menuBar.addItem(avatar);
SubMenu subMenu = menuItem.getSubMenu();
subMenu.addItem("Profile");
subMenu.addItem("Settings");
subMenu.addItem("Help");
subMenu.addItem("Sign out");
```
# Badge

Badges are colored text elements containing small bits of information. They’re used for labeling content, displaying metadata and/or highlighting information.

```java
Span pending = new Span("Pending");
pending.getElement().getThemeList().add("badge");

Span confirmed = new Span("Confirmed");
confirmed.getElement().getThemeList().add("badge success");

Span denied = new Span("Denied");
denied.getElement().getThemeList().add("badge error");

Span onHold = new Span("On hold");
onHold.getElement().getThemeList().add("badge contrast");
```

Import styles

Badge is a set of CSS classes rather than a web / Flow component. The Badge-specific CSS classes are available as part of the Lumo theme. To use these classes in your application, enable them in your theme’s  `theme.json`:

```json
{
  "lumoImports": [<...>, "badge"]
}
```

The  `theme.json`  is located in the theme folder at  `/src/main/frontend/themes/<my-theme>/theme.json`.

## Label

Badges should contain a label. Labels should be clear, concise, and written using sentence case. Aim for 1 to 2 words.

## Icons

Badges can contain icons as well as text. Icons can be placed on either side of the text.

```java
// Icon before text
Span pending1 = new Span(createIcon(VaadinIcon.CLOCK),
        new Span("Pending"));
pending1.getElement().getThemeList().add("badge");

// Icon after text
Span pending2 = new Span(new Span("Pending"),
        createIcon(VaadinIcon.CLOCK));
pending2.getElement().getThemeList().add("badge");

...

private Icon createIcon(VaadinIcon vaadinIcon) {
    Icon icon = vaadinIcon.create();
    icon.getStyle().set("padding", "var(--lumo-space-xs)");
    return icon;
}
```

Use icons sparingly

The benefit of using icons should be weighed against the visual noise it adds.

### Icon-Only

Badges can also be used with icons without a label. For accessibility, a tooltip and  `aria-label`  attribute is recommended to ensure that all users can identify their meaning.

```java
Icon confirmed = createIcon(VaadinIcon.CHECK, "Confirmed");
confirmed.getElement().getThemeList().add("badge success");

Icon cancelled = createIcon(VaadinIcon.CLOSE_SMALL, "Cancelled");
cancelled.getElement().getThemeList().add("badge error");

...

private Icon createIcon(VaadinIcon vaadinIcon, String label) {
    Icon icon = vaadinIcon.create();
    icon.getStyle().set("padding", "var(--lumo-space-xs");
    // Accessible label
    icon.getElement().setAttribute("aria-label", label);
    // Tooltip
    icon.getElement().setAttribute("title", label);
    return icon;
}
```

Icon-only badges should primarily be used for common recurring content with highly standardized, universally understood icons (such as a checkmark for "_yes_"), and for content that’s repeated, for example in lists and tables.

```java
grid.addColumn(UserPermissions::getName).setHeader("Name");
grid.addComponentColumn(userPermissions -> createPermissionIcon(
        userPermissions.getView())).setHeader("View");
grid.addComponentColumn(userPermissions -> createPermissionIcon(
        userPermissions.getComment())).setHeader("Comment");
grid.addComponentColumn(userPermissions -> createPermissionIcon(
        userPermissions.getEdit())).setHeader("Edit");

...

private Icon createPermissionIcon(boolean hasPermission) {
    Icon icon;
    if (hasPermission) {
        icon = createIcon(VaadinIcon.CHECK, "Yes");
        icon.getElement().getThemeList().add("badge success");
    } else {
        icon = createIcon(VaadinIcon.CLOSE_SMALL, "No");
        icon.getElement().getThemeList().add("badge error");
    }
    return icon;
}

private Icon createIcon(VaadinIcon vaadinIcon, String label) {
    Icon icon = vaadinIcon.create();
    icon.getStyle().set("padding", "var(--lumo-space-xs");
    // Accessible label
    icon.getElement().setAttribute("aria-label", label);
    // Tooltip
    icon.getElement().setAttribute("title", label);
    return icon;
}
```

## Theme Variants

Badge features theme variants for different sizes, colors, and shapes. You can combine any theme variants together.

### Size

Badges have two different sizes you can use: the default (normal) and  `small`. Use the  `small`  theme variant to make a badge smaller, for example when space is limited or for compact parts of the UI.

```java
Span pending = new Span("Pending");
pending.getElement().getThemeList().add("badge small");

Span confirmed = new Span("Confirmed");
confirmed.getElement().getThemeList().add("badge success small");

Span denied = new Span("Denied");
denied.getElement().getThemeList().add("badge error small");

Span onHold = new Span("On hold");
onHold.getElement().getThemeList().add("badge contrast small");
```

### Color

Badges have four different color variants: default,  `success`,  `error`, and  `contrast`. The color variants can be paired with the  `primary`  theme variant for additional emphasis.

```java
// Default variant
Span pending = new Span("Pending");
pending.getElement().getThemeList().add("badge");

// Primary variant
Span pendingPrimary = new Span("Pending");
pendingPrimary.getElement().getThemeList().add("badge primary");
```

Variant

Theme name

Usage recommendations

Normal

Default style. Recommended for informational messages. This style may be confused with a Button or link.

Success

`Success`

Highlight positive outcomes, such as when a task or operation is completed.

Error

`Error`

Use the error theme variant to communicate alerts, failures, or warnings.

Contrast

`Contrast`

A high-contrast version that improves legibility and distinguishes the badge from the rest of the UI. Recommended for neutral badges (that don’t communicate success or errors).

Primary

`Primary`

Used for important information and/or to draw more attention to your badge. Can be combined with all other theme variants.

Accessibility

Assistive technologies, such as screen readers, interpret badges solely based on their content. Without proper context, they may end up confusing the user. If you are using colors and icons to convey information, provide the same info via  `aria-label`  to ensure that screen readers can interpret the information.

### Shape

Applying the  `pill`  theme variant produces a badge with rounded corners. It can aid in making badges and buttons more distinct from one another.

```java
Span pending = new Span("Pending");
pending.getElement().getThemeList().add("badge pill");

Span confirmed = new Span("Confirmed");
confirmed.getElement().getThemeList().add("badge success pill");

Span denied = new Span("Denied");
denied.getElement().getThemeList().add("badge error pill");

Span onHold = new Span("On hold");
onHold.getElement().getThemeList().add("badge contrast pill");
```

## Use Cases

### Highlighting and Distinguishing Information

A typical use case for badges is to highlight an item’s status, for example in a Grid.

```java
grid.addComponentColumn(report -> createStatusBadge(report.getStatus()))
        .setHeader("Status");

...

private Span createStatusBadge(String status) {
    String theme;
    switch (status) {
    case "In progress":
        theme = "badge primary";
        break;
    case "Completed":
        theme = "badge success primary";
        break;
    case "Cancelled":
        theme = "badge error primary";
        break;
    default:
        theme = "badge contrast primary";
        break;
    }
    Span badge = new Span(status);
    badge.getElement().getThemeList().add(theme);
    return badge;
}
```

They are also often used for displaying metadata tags.

### Interactive Content

Badges can house interactive content such as Anchors and Buttons. For example, Badges that highlight active filters might contain a "Clear" Button which removes the associated filter.

```java
HorizontalLayout badges = new HorizontalLayout();
badges.getStyle().set("flex-wrap", "wrap");

ComboBox<String> comboBox = new ComboBox<>("Profession");
comboBox.setItems(DataService.getProfessions());
comboBox.addValueChangeListener(e -> {
    Span filterBadge = createFilterBadge(e.getValue());
    badges.add(filterBadge);
});

...

private Span createFilterBadge(String profession) {
    Button clearButton = new Button(VaadinIcon.CLOSE_SMALL.create());
    clearButton.addThemeVariants(ButtonVariant.LUMO_CONTRAST,
            ButtonVariant.LUMO_TERTIARY_INLINE);
    clearButton.getStyle().set("margin-inline-start",
            "var(--lumo-space-xs)");
    // Accessible button name
    clearButton.getElement().setAttribute("aria-label",
            "Clear filter: " + profession);
    // Tooltip
    clearButton.getElement().setAttribute("title",
            "Clear filter: " + profession);

    Span badge = new Span(new Span(profession), clearButton);
    badge.getElement().getThemeList().add("badge contrast pill");

    // Add handler for removing the badge
    clearButton.addClickListener(event -> {
        badge.getElement().removeFromParent();
    });

    return badge;
}
```

### Counter

Badges can be used as counters, for example to show the number of unread/new messages, selection count, etc.

```java
Tabs tabs = new Tabs(createTab("Inbox", 12), createTab("Important", 3),
        createTab("Spam", 45), createTab("Archive", 23));

...

private static Tab createTab(String labelText, int messageCount) {
    Span label = new Span(labelText);
    Span counter = new Span(String.valueOf(messageCount));
    counter.getElement().getThemeList().add("badge pill small contrast");
    counter.getStyle().set("margin-inline-start", "var(--lumo-space-s)");
    // Accessible badge label
    String counterLabel = String.format("%d unread messages", messageCount);
    counter.getElement().setAttribute("aria-label", counterLabel);
    counter.getElement().setAttribute("title", counterLabel);

    return new Tab(label, counter);
}
```

Assistive technologies, such as screen readers, interpret badges solely based on their content. Without proper context, they may end up confusing the user. To provide context for people using screen readers, set the badge’s  `aria-label`  attribute.

## Best Practices

### Badge vs Button

Badges and Buttons are similar in appearance. This might lead users to think that badges are interactive.

Placement, language, shape, and color can all help mitigate any confusion. First, badges shouldn’t be labeled with active verbs. They aren’t actions, but rather static text/content. Second, avoid placing badges directly next to Buttons, in particular if they are using similar themes. The  `pill`  theme variant may aid in making badges and Buttons more distinct from one another.

# Button

The Button component allows users to perform actions. It comes in several different style variants and supports icons as well as text labels.

```java
Button button = new Button("Button");
Paragraph info = new Paragraph(infoText());
button.addClickListener(clickEvent -> {
    counter += 1;
    info.setText(infoText());
});
```

## Styles

The following variants can be used to distinguish between actions of different importance in the UI:

```java
Button primaryButton = new Button("Primary");
primaryButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

Button secondaryButton = new Button("Secondary");

Button tertiaryButton = new Button("Tertiary");
tertiaryButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY);
```

Variant

Usage Recommendation

Primary

This is the most important action in a view or in part of one. It’s the main closure or continuation action (e.g.,  **Save**) in a form or dialog. Avoid presenting the user with more than one at any time.

Secondary

This is the default style recommended for most actions. It can be the alternate or negative closure actions (e.g.,  **Cancel**) in a form or dialog.

Tertiary

These are lower-importance actions — especially in parts of the UI with less space, such as cards, or repeated actions for items in lists, tables, etc. Caution: this can be mistaken for non-interactive text.

### Danger & Error Variants

This is a style for distinguishing actions related to dangers, warnings, or errors. Dangerous actions would be those that lose or destroy data.

```java
Button primaryButton = new Button("Primary");
primaryButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
        ButtonVariant.LUMO_ERROR);

Button secondaryButton = new Button("Secondary");
secondaryButton.addThemeVariants(ButtonVariant.LUMO_ERROR);

Button tertiaryButton = new Button("Tertiary");
tertiaryButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY,
        ButtonVariant.LUMO_ERROR);
```

Primary danger buttons should only be used when a dangerous action is the most likely action. An example of this would be the affirmative  **Delete**  action in a deletion confirmation dialog. Secondary and Tertiary variants can be used for actions related to current errors, such as resolving them or viewing their details.

### Warning Variant

This is a style for distinguishing actions related to warnings: for example, in dialogs that are intended to warn the user, or to provide information that requires extra attention.

```java
Button primaryButton = new Button("Primary");
primaryButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
        ButtonVariant.LUMO_WARNING);

Button secondaryButton = new Button("Secondary");
secondaryButton.addThemeVariants(ButtonVariant.LUMO_WARNING);

Button tertiaryButton = new Button("Tertiary");
tertiaryButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY,
        ButtonVariant.LUMO_WARNING);
```

### Size Variants

The following size variants are available for Button instances whose size needs to be different from the default:

```java
Button largeButton = new Button("Large");
largeButton.addThemeVariants(ButtonVariant.LUMO_LARGE);

Button normalButton = new Button("Normal");

Button smallButton = new Button("Small");
smallButton.addThemeVariants(ButtonVariant.LUMO_SMALL);
```

Variant

Usage Recommendation

Large

For important call-to-action buttons — where more emphasis is needed.

Normal

Default size.

Small

Compact option for cramped parts of the UI — where a Tertiary variant isn’t deemed appropriate.

Customize Default Button Size

Size variants should only be used in special cases. See  [Size and Space](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties/size-space)  for details on how to change the default button size.

### Miscellaneous Style Variants

The  **Tertiary Inline**  variant omits all white space around the label. This can be useful for embedding a Button as part of text content or another component. It shouldn’t be confused with a link.

```java
Button tertiaryInlineButton = new Button("Tertiary inline");
tertiaryInlineButton
        .addThemeVariants(ButtonVariant.LUMO_TERTIARY_INLINE);
```

The  **Success**  and  **Contrast**  variants should provide additional color options for buttons.

```java
Button primaryButton = new Button("Primary");
primaryButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
        ButtonVariant.LUMO_SUCCESS);

Button secondaryButton = new Button("Secondary");
secondaryButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

Button tertiaryButton = new Button("Tertiary");
tertiaryButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY,
        ButtonVariant.LUMO_SUCCESS);
```

```java
Button primaryButton = new Button("Primary");
primaryButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
        ButtonVariant.LUMO_CONTRAST);

Button secondaryButton = new Button("Secondary");
secondaryButton.addThemeVariants(ButtonVariant.LUMO_CONTRAST);

Button tertiaryButton = new Button("Tertiary (avoid)");
tertiaryButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY,
        ButtonVariant.LUMO_CONTRAST);
```

The  **Tertiary + Contrast**  combination should be avoided because of similarity to non-interactive text elements.

Customize Default Button Colors

The standard Button colors can be adjusted using  [the Lumo color properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties/color). Therefore, these variants shouldn’t be used to replace standard buttons only to achieve a different color.

## Buttons with Icons

Buttons can have icons instead of text, or they can have icons along with text.

```java
// Icon button using an aria-label to provide a textual alternative
// to screen readers
Button plusButton = new Button(new Icon(VaadinIcon.PLUS));
plusButton.addThemeVariants(ButtonVariant.LUMO_ICON);
plusButton.setAriaLabel("Add item");

// Icon button using a tooltip to provide textual description
// of the action that it triggers
Button closeButton = new Button(new Icon(VaadinIcon.CLOSE_SMALL));
closeButton.addThemeVariants(ButtonVariant.LUMO_ICON);
closeButton.setAriaLabel("Close");
closeButton.setTooltipText("Close the dialog");

Button arrowLeftButton = new Button("Left",
        new Icon(VaadinIcon.ARROW_LEFT));

Button arrowRightButton = new Button("Right",
        new Icon(VaadinIcon.ARROW_RIGHT));
arrowRightButton.setIconAfterText(true);
```

Use icons sparingly. Most actions are difficult to represent reliably with icons. The benefit of icons plus text should be weighed against the visual clutter they create.

Icon-only buttons should be used primarily for common recurring actions with highly standardized, universally understood icons (e.g., a cross for  **close**), and for actions that are repeated, such as in lists and tables. They should also include a textual alternative for screen readers using the  `aria-label`  attribute (see the first two buttons in the previous example).

Additionally,  [tooltips](https://vaadin.com/docs/latest/components/tooltip)  can be added to provide a description of the action that the button triggers (see the  **Close**  button in the previous example).

Icon-Only Button Style Variant

Use the  `icon`  /  `LUMO_ICON`  theme variant on icon-only buttons to reduce the white space on either side of the icon. The Flow  `Button`  component automatically applies the  `icon`  variant if the icon is the only child of the component.

## Buttons with Images

Images on buttons can be used like icons. See the icon usage recommendations for more information.

```java
Image img = new Image(src, "Vaadin logo");
img.setWidth("100px");

Button imgButton = new Button(img);
imgButton.addThemeVariants(ButtonVariant.LUMO_ICON);
```

## Disabled

Buttons representing actions that aren’t currently available to the user should be either hidden or disabled. A disabled button is rendered as "dimmed", and is excluded from the focus order. This may be useful when you don’t want interactive UI elements to receive the focus using the tab key.

```java
Button primaryButton = new Button("Primary");
primaryButton.setEnabled(false);
primaryButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

Button secondaryButton = new Button("Secondary");
secondaryButton.setEnabled(false);

Button tertiaryButton = new Button("Tertiary");
tertiaryButton.setEnabled(false);
tertiaryButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY);
```

### Hidden vs. Disabled

Hiding entirely an unavailable action is often preferable to a disabled button, as this reduces UI clutter. However, in certain situations, this can be problematic. If the user expects a button to be present — such as at the end of a form — hiding the button can cause confusion, even if the form clearly shows the presence of one or more invalid fields. Also, since a hidden button doesn’t occupy any space in the UI, toggling its visibility can cause unwanted changes in the layout of other elements.

### Show Error on Click

As an alternative to hiding or disabling buttons, configure instead unavailable actions to show an error message when the button is clicked by using a  [Notification](https://vaadin.com/docs/latest/components/notification)  or an adjacent inline text element. This approach is the most accessible option, but may be frustrating to users who expect unavailable actions to be distinguished somehow from available actions.

### Prevent Multiple Clicks

Buttons can be configured to be disabled when clicked. This can be useful especially for actions that take a bit longer to perform. Not only does this avoid the need for special handling of additional clicks while the action is in progress, but it also communicates to the user that the action was received successfully and is being processed.

```java
Button button = new Button("Perform Action");
FakeProgressBar progressBar = new FakeProgressBar();
button.setDisableOnClick(true);
button.addClickListener(event -> progressBar.simulateProgress());

progressBar.addProgressEndListener(event -> {
    button.setEnabled(true);
});
```

## Focus

As with other components, the focus ring is only rendered when the button is focused by keyboard or programmatically.

### Auto Focus

Buttons can receive keyboard focus automatically when the UI in which they appear is rendered.

```java
Button button = new Button("Button");
button.setAutofocus(true);
```

## Keyboard Usage

A focused button can be triggered with  Enter  or  Space.

## Best Practices

Below are some best practice recommendations related to buttons and their labels.

### Button Labels

A label should describe the action, preferably using active verbs, such as  _"View Details"_  rather than  _"Details"_. To avoid ambiguity, also specify the object of the verb, such as  _"Save Changes"_  instead of  _"Save"_. They also should be brief, ideally less than three words or twenty-five characters.

Button groups representing options, such as the buttons of a  [Confirm Dialog](https://vaadin.com/docs/latest/components/confirm-dialog), should state what each option represents (e.g.,  _"Save Changes"_). Don’t label a button  _"Yes"_  since that requires the user to read the question being asked. It’ll increase the risk of selecting the wrong option.

Use ellipsis (i.e., …) when an action is not immediate, but requires more steps to complete. This is useful, for example, for destructive actions like  _"Delete…​"_  when a  [Confirm Dialog](https://vaadin.com/docs/latest/components/confirm-dialog)  is used to confirm the action before it’s executed.

### ARIA Labels

The  `aria-label`  attribute can be used to provide a separate label for accessibility technologies (AT), such as screen readers. This is important, for example, for icon-only buttons that lack a visible label.

A button with a regular, visible label can also benefit from a separate  `aria-label`  to provide more context that may otherwise be difficult for an AT user to perceive. In the example here, each button’s  `aria-label`  specifies which email address is removed:

```java
Button clearPrimaryEmail = new Button("Remove", event -> {
    emailField.setValue("");
});
clearPrimaryEmail.setAriaLabel("Remove primary email address");

Button clearSecondaryEmail = new Button("Remove", event -> {
    secondaryEmailField.setValue("");
});
clearSecondaryEmail.setAriaLabel("Remove secondary email address");
```

### Buttons in Forms

Buttons in forms should be placed below the form with which they’re associated. They should be aligned left, with the primary action first, followed by other actions, in order of importance.

```java
TextField firstNameField = new TextField("First name", "John", "");
TextField lastNameField = new TextField("Last name", "Smith", "");
EmailField emailField = new EmailField("Email address");
emailField.setValue("john.smith@example.com");
FormLayout formLayout = new FormLayout(firstNameField, lastNameField,
        emailField);
formLayout.setResponsiveSteps(new ResponsiveStep("0", 2));
formLayout.setColspan(emailField, 2);

Button createAccount = new Button("Create account");
createAccount.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
Button cancel = new Button("Cancel");

HorizontalLayout buttonLayout = new HorizontalLayout(createAccount,
        cancel);
```

### Buttons in Dialogs

Buttons in dialogs should be placed at the bottom of the dialog and aligned right. Primary action should be last, preceded by other actions. Dangerous actions should be aligned left, to avoid accidental clicks, especially if no confirmation step is included.

```java
TextField firstNameField = new TextField("First name", "John", "");
TextField lastNameField = new TextField("Last name", "Smith", "");
EmailField emailField = new EmailField("Email address");
emailField.setValue("john.smith@example.com");
FormLayout formLayout = new FormLayout(firstNameField, lastNameField,
        emailField);
formLayout.setResponsiveSteps(new FormLayout.ResponsiveStep("0", 2));
formLayout.setColspan(emailField, 2);

Button delete = new Button("Delete");
delete.addThemeVariants(ButtonVariant.LUMO_ERROR);
delete.getStyle().set("margin-inline-end", "auto");

Button cancel = new Button("Cancel");

Button createAccount = new Button("Create account");
createAccount.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

HorizontalLayout buttonLayout = new HorizontalLayout(delete, cancel,
        createAccount);
buttonLayout.getStyle().set("flex-wrap", "wrap");
buttonLayout.setJustifyContentMode(JustifyContentMode.END);
```

### Global vs. Selection-Specific Actions

In lists of selectable items — such as in a  [Grid](https://vaadin.com/docs/latest/components/grid) — that provide actions applicable to the selected item, buttons for selection-specific actions should be placed apart from global actions that aren’t selection-specific. They should be located below the list of selectable items.

In the example below, the global  _Add User_  action is separated from the selection-specific actions below the Grid:

## Users

```java
H2 users = new H2("Users");
users.getStyle().set("margin", "0 auto 0 0");
Button addUser = new Button("Add user");
HorizontalLayout header = new HorizontalLayout(users, addUser);
header.setAlignItems(Alignment.CENTER);
header.getThemeList().clear();

Button editProfile = new Button("Edit profile");
editProfile.setEnabled(false);

Button managePermissions = new Button("Manage permissions");
managePermissions.setEnabled(false);

Button resetPassword = new Button("Reset password");
resetPassword.setEnabled(false);

Button delete = new Button("Delete");
delete.setEnabled(false);
delete.addThemeVariants(ButtonVariant.LUMO_ERROR);
delete.getStyle().set("margin-inline-start", "auto");

Grid<Person> grid = new Grid<>(Person.class, false);
grid.setSelectionMode(Grid.SelectionMode.MULTI);
grid.addColumn(Person::getFirstName).setHeader("First name");
grid.addColumn(Person::getLastName).setHeader("Last name");
grid.addColumn(Person::getEmail).setHeader("Email");
grid.addSelectionListener(selection -> {
    int size = selection.getAllSelectedItems().size();
    boolean isSingleSelection = size == 1;
    editProfile.setEnabled(isSingleSelection);
    managePermissions.setEnabled(isSingleSelection);
    resetPassword.setEnabled(isSingleSelection);

    delete.setEnabled(size != 0);
});

HorizontalLayout footer = new HorizontalLayout(editProfile,
        managePermissions, resetPassword, delete);
footer.getStyle().set("flex-wrap", "wrap");
```

# Checkbox
Checkbox is an input field representing a binary choice. Checkbox Group is a group of related binary choices.

```java
Checkbox checkbox = new Checkbox();
checkbox.setLabel("I accept the terms and conditions");

add(checkbox);
```

```java
CheckboxGroup<String> checkboxGroup = new CheckboxGroup<>();
checkboxGroup.setLabel("Export data");
checkboxGroup.setItems("Order ID", "Product name", "Customer",
        "Status");
checkboxGroup.select("Order ID", "Customer");
checkboxGroup.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);
add(checkboxGroup);
```

Use Checkbox Group to group related items. Individual checkboxes should be used for options that aren’t necessarily related to each other in any way.

## States

Checkbox has a few states: disabled; read-only; required; and indeterminate. These are described in this section, in the following sub-sections.

### Disabled

Disable a field to mark it as currently unavailable. Disabled state is used for fields that aren’t editable and don’t need to be readable. Disabled elements can’t be focused and may be inaccessible to assistive technologies like screen readers.

Disabling can be preferable to hiding an element to prevent changes in layout when the element’s visibility changes, and to make users aware of its existence even when currently unavailable.

Disabling is supported both for individual checkboxes, and for an entire checkbox group.

```java
CheckboxGroup<String> disabledCheckGroup = new CheckboxGroup<>();
disabledCheckGroup.setLabel("Departments");
disabledCheckGroup.setItems("Engineering", "Human Resources",
        "Marketing", "Operations", "Sales");
disabledCheckGroup.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);
disabledCheckGroup.setEnabled(false);
add(disabledCheckGroup);
```

### Read-Only

Fields used to display values should be set to read-only mode to prevent editing. Read-only fields are focusable and visible to screen readers.

Read-only mode is supported both on individual checkboxes and on an entire checkbox group.

```java
CheckboxGroup<String> checkboxGroup = new CheckboxGroup<>();
checkboxGroup.setLabel("Export data");
checkboxGroup.setItems("Order ID", "Product name", "Customer",
        "Status");
checkboxGroup.select("Order ID", "Customer");
checkboxGroup.setReadOnly(true);
checkboxGroup.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);
add(checkboxGroup);
```

### Required

Individual checkboxes can be marked as required. This is commonly used for checkboxes that must be checked in order to proceed with an operation, such as submitting a form. Required checkboxes become invalid when validated or if left unchecked after being focused.

An entire checkbox group can also be marked as required. They become invalid when validated or when blurred if none of their items are checked.

```java
Checkbox checkbox = new Checkbox();
checkbox.setLabel("Grant view permissions");
checkbox.setRequiredIndicatorVisible(true);

Binder<UserPermissions> binder = new Binder<>(UserPermissions.class);
binder.forField(checkbox).asRequired("This field is required")
        .bind(UserPermissions::getView, UserPermissions::setView);
```

### Indeterminate

The indeterminate state can be used for a parent checkbox to show that there is a mix of checked and unchecked child items in a list, and to change the state of all child items at once.

```java
Checkbox checkbox = new Checkbox("Notify users");

CheckboxGroup<Person> checkboxGroup = new CheckboxGroup<>();
checkboxGroup.setLabel("Users to notify");
checkboxGroup.setItemLabelGenerator(
        person -> person.getFirstName() + " " + person.getLastName());
checkboxGroup.setItems(items);
checkboxGroup.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);
checkboxGroup.addValueChangeListener(event -> {
    if (event.getValue().size() == items.size()) {
        checkbox.setValue(true);
        checkbox.setIndeterminate(false);
    } else if (event.getValue().size() == 0) {
        checkbox.setValue(false);
        checkbox.setIndeterminate(false);
    } else {
        checkbox.setIndeterminate(true);
    }
});
checkbox.addValueChangeListener(event -> {
    if (checkbox.getValue()) {
        checkboxGroup.setValue(new HashSet<>(items));
    } else {
        checkboxGroup.deselectAll();
    }
});
checkboxGroup.select(items.get(0), items.get(2));
add(checkbox, checkboxGroup);
```

## Orientation

The component’s default orientation is horizontal. However, vertical orientation is recommended whenever possible as it’s easier for the user to scan a vertical list of options:

```java
CheckboxGroup<String> checkboxGroup = new CheckboxGroup<>();
checkboxGroup.setLabel("Working days");
checkboxGroup.setItems("Monday", "Tuesday", "Wednesday", "Thursday",
        "Friday", "Saturday", "Sunday");
checkboxGroup.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);
add(checkboxGroup);
```

In cases where vertical space needs to be conserved, horizontal orientation can be used. Still, no more than three options are recommended:

```java
CheckboxGroup<String> checkboxGroup = new CheckboxGroup<>();
checkboxGroup.setLabel("Permissions");
checkboxGroup.setItems("Read", "Edit", "Delete");
add(checkboxGroup);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/checkbox#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/checkbox#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/checkbox#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/checkbox#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.


```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-checkbox accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-checkbox accessible-name="This is the label">...
```

```java
Checkbox checkbox = new Checkbox();
checkbox.setLabel("Label");
checkbox.setHelperText("Helper text");

CheckboxGroup<String> field = new CheckboxGroup<>();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setTooltipText("Tooltip text");
```

## Style Variants

The following style variants can be applied:

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
CheckboxGroup<String> field = new CheckboxGroup<>();
field.addThemeVariants(CheckboxGroupVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Best Practices

One of the best practices to consider is related to labeling. Try to use short and descriptive labels with positive wording. Avoid negations.

Yes, I agree

It’s important to provide labels for Checkbox Groups to distinguish clearly any adjacent groups.

```java
CheckboxGroup<String> manufacturer = new CheckboxGroup<>();
manufacturer.setLabel("Manufacturer");
manufacturer.setItems("Akuchi", "Broek", "Wulf");
manufacturer.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);

CheckboxGroup<String> status = new CheckboxGroup<>();
status.setLabel("Status");
status.setItems("In progress", "Done", "Cancelled");
status.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);

add(manufacturer, status);
```
# Combo Box

Combo Box allows the user to choose a value from a filterable list of options presented in an overlay. It supports lazy loading and can be configured to accept custom typed values.

```java
ComboBox<Country> comboBox = new ComboBox<>("Country");
comboBox.setItems(DataService.getCountries());
comboBox.setItemLabelGenerator(Country::getName);
add(comboBox);
```

The overlay opens when the user clicks the field using a pointing device. Using the Up/Down arrow keys or typing a character — found in at least one of the options — when the field is focused also opens the popup.

## Custom Value Entry

Combo Box can be configured to allow entering custom values that aren’t included in the list of options.

```java
ComboBox<String> comboBox = new ComboBox<>("Browser");
comboBox.setAllowCustomValue(true);
add(comboBox);
```

Allowing custom entry is useful when you need to present the most common choices, but still give users the freedom to enter their own options.

Custom values can also be stored and added to the list of options:

```java
ComboBox<String> comboBox = new ComboBox<>("Browser");
comboBox.setAllowCustomValue(true);
comboBox.addCustomValueSetListener(e -> {
    String customValue = e.getDetail();
    items.add(customValue);
    comboBox.setItems(items);
    comboBox.setValue(customValue);
});
add(comboBox);
```

## Custom Item Presentation

Items can be customized to display more information than a single line of text.

```java
ComboBox<Person> comboBox = new ComboBox<>("Choose doctor");
comboBox.setItems(filter, DataService.getPeople());
comboBox.setItemLabelGenerator(
        person -> person.getFirstName() + " " + person.getLastName());
comboBox.setRenderer(createRenderer());
comboBox.getStyle().set("--vaadin-combo-box-overlay-width", "16em");
add(comboBox);

...

// NOTE
// We are using inline styles here to keep the example simple.
// We recommend placing CSS in a separate style sheet and to
// encapsulating the styling in a new component.

private Renderer<Person> createRenderer() {
    StringBuilder tpl = new StringBuilder();
    tpl.append("<div style=\"display: flex;\">");
    tpl.append(
            "  <img style=\"height: var(--lumo-size-m); margin-right: var(--lumo-space-s);\" src=\"${item.pictureUrl}\" alt=\"Portrait of ${item.firstName} ${item.lastName}\" />");
    tpl.append("  <div>");
    tpl.append("    ${item.firstName} ${item.lastName}");
    tpl.append(
            "    <div style=\"font-size: var(--lumo-font-size-s); color: var(--lumo-secondary-text-color);\">${item.profession}</div>");
    tpl.append("  </div>");
    tpl.append("</div>");

    return LitRenderer.<Person> of(tpl.toString())
            .withProperty("pictureUrl", Person::getPictureUrl)
            .withProperty("firstName", Person::getFirstName)
            .withProperty("lastName", Person::getLastName)
            .withProperty("profession", Person::getProfession);
}
```

Use a custom filter to allow the user to search by the rendered properties. It’s recommended to make filtering case insensitive.

## Item Class Names

Items can be styled dynamically, based on application logic and the data in the combo box, through custom class names.

```java
ComboBox<String> comboBox = new ComboBox<>("Fruit");
comboBox.setItems(List.of("Apple", "Banana", "Orange", "Pear"));
comboBox.setClassNameGenerator((item) -> {
    switch (item) {
    case "Apple":
        return "coral";
    case "Banana":
        return "gold";
    case "Orange":
        return "orange";
    case "Pear":
        return "yellowgreen";
    default:
        return "";
    }
});
```

## Auto Open

The overlay opens automatically when the field is focused using a pointer (i.e., mouse or touch), or when the user types in the field. You can disable this so that the overlay opens only when the toggle button or the  Up/Down  arrow keys are pressed.

```java
ComboBox<Country> comboBox = new ComboBox<>("Country");
comboBox.setAutoOpen(false);
add(comboBox);
```

## Popup Width

The width of the popup is, by default, the same width as the input field. The popup width can be overridden to any fixed width in cases where the default width is too narrow.

```java
ComboBox<Person> comboBox = new ComboBox<>("Employee");
comboBox.getStyle().set("--vaadin-combo-box-overlay-width", "350px");
add(comboBox);
```

## Custom Filtering

Combo Box’s filtering, by default, is configured to show only items that contain the entered value:

Custom filtering is also possible. For example, if you only want to show items that start with the user’s input you could do something like this:

```java
ComboBox<Country> comboBox = new ComboBox<>("Country");

ItemFilter<Country> filter = (country, filterString) -> country
        .getName().toLowerCase().startsWith(filterString.toLowerCase());
comboBox.setItems(filter, DataService.getCountries());

add(comboBox);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/combo-box#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/combo-box#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/combo-box#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/combo-box#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/combo-box#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/combo-box#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix

A prefix element — rendered at the start of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/combo-box#label), a  [Helper](https://vaadin.com/docs/latest/components/combo-box#helper)  or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```java
// Associates external element as label:
NativeLabel label = new NativeLabel("This is the label");
label.setId("external-label");
field.setAriaLabelledBy("external-label");

// Invisible label for screen readers:
field.setAriaLabel("This is the label");
```

```java
ComboBox<String> field = new ComboBox<>();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.SEARCH.create());
```

## Constraints

Required

Required fields are marked with an indicator next to the label, and become invalid if left empty after having been focused. An error message explaining that the field is required needs to be provided manually.

An instruction text at the top of the form explaining the required indicator is recommended. The indicator itself can be customized with the  `--lumo-required-field-indicator`  style property.

Allowed Characters

A separate single-character, regular expression can be used to restrict the characters that can be entered into the field. Characters that don’t match the expression are rejected.

```java
ComboBox<String> field = new ComboBox<>();
field.setRequiredIndicatorVisible(true);
field.setAllowedCharPattern("[A-Z]");
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
ComboBox<String> readonlyField = new ComboBox<>();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setItems("Value");
readonlyField.setValue("Value");

ComboBox<String> disabledField = new ComboBox<>();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
ComboBox<String> field = new ComboBox<>();
field.addThemeVariants(ComboBoxVariant.LUMO_SMALL,
        ComboBoxVariant.LUMO_ALIGN_RIGHT,
        ComboBoxVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Usage as Autocomplete Field

As the user is typing, the Combo Box filters out the options that don’t match. Once the correct value has been found, the user can use the Up/Down arrow keys to navigate the list and the Enter key to set the value, essentially using the Combo Box as an autocomplete field.

## Best Practices

Combo Box supports lazy loading for large datasets. It reduces the initial load time, and consumes less bandwidth and resources.

Don’t use as a menu.

Combo Box is an input field component, not a generic menu component. Use the Menu Bar component to create overlays for actions.

# Confirm Dialog

Confirm Dialog is a modal Dialog used to confirm user actions.

```java
status = new Span();
status.setVisible(false);

ConfirmDialog dialog = new ConfirmDialog();
dialog.setHeader("Unsaved changes");
dialog.setText(
        "There are unsaved changes. Do you want to discard or save them?");

dialog.setCancelable(true);
dialog.addCancelListener(event -> setStatus("Canceled"));

dialog.setRejectable(true);
dialog.setRejectText("Discard");
dialog.addRejectListener(event -> setStatus("Discarded"));

dialog.setConfirmText("Save");
dialog.addConfirmListener(event -> setStatus("Saved"));

Button button = new Button("Open confirm dialog");
button.addClickListener(event -> {
    dialog.open();
    status.setVisible(false);
});
```

## Content

Confirm Dialog consists of:

-   Title

-   Message

-   Footer

    -   “Cancel” button

    -   “Reject” button

    -   “Confirm” button



Each Confirm Dialog should have a title and/or message. The “Confirm” button is shown by default, while the two other buttons aren’t (they must be explicitly enabled to be displayed).

## Title

The title should be brief but informative and written in sentence case. It must explain the purpose of the dialog and can be phrased as a statement or question. Avoid ambiguous titles, such as “Are you sure?”. Rich content, such as other components and elements, can also be used in the title.

## Messages

The message should contain any information a user might need to make an informed decision.

While it can contain any type of content, Confirm Dialog isn’t meant for collecting user input, except for a Checkbox used for remembering the user’s choice.

## Buttons

The buttons in a Confirm Dialog are customizable. You can edit their labels and change their theme variants.

### Confirm Button

The “Confirm” button represents primary action and is the only button that’s visible by default. Every dialog needs at least one button.

As the name suggests, its default label is “Confirm”, but it can and should be relabeled based on the use case.

#### Usage Recommendations

-   Use concise labels that explain the action, such as “Save” and “Delete”. Avoid ambiguous labels like “Yes” and “No”.

-   For dangerous actions, such as those that lose or destroy data, use the Error theme variant.

-   For simple acknowledgements, it’s acceptable to use an “OK” label.


```java
status = new Span();
status.setVisible(false);

ConfirmDialog dialog = new ConfirmDialog();
dialog.setHeader("Export failed");
dialog.setText(new Html(
        "<p>An error occurred while exporting <b>Report Q4</b>. Please try again. If the problem persists, contact <a href=\"mailto:support@company.com\">support@company.com</a>.</p>"));

dialog.setConfirmText("OK");
dialog.addConfirmListener(event -> setStatus("Acknowledged"));

Button button = new Button("Open confirm dialog");
button.addClickListener(event -> {
    dialog.open();
    status.setVisible(false);
});
```

### Cancel Button

The “Cancel” button is used in situations where the user must be able to cancel an action altogether, such as confirming irreversible actions like saving or deleting data.

```java
status = new Span();
status.setVisible(false);

ConfirmDialog dialog = new ConfirmDialog();
dialog.setHeader("Delete \"Report Q4\"?");
dialog.setText(
        "Are you sure you want to permanently delete this item?");

dialog.setCancelable(true);
dialog.addCancelListener(event -> setStatus("Canceled"));

dialog.setConfirmText("Delete");
dialog.setConfirmButtonTheme("error primary");
dialog.addConfirmListener(event -> setStatus("Deleted"));

Button button = new Button("Open confirm dialog");
button.addClickListener(event -> {
    dialog.open();
    status.setVisible(false);
});
```

### Reject Button

The “Reject” button differs from the “Cancel” button in that it still moves the user forward in their workflow.

For example, if the user tries to leave a view containing unsaved changes, they are typically presented with three options: “Cancel”, “Discard” and “Save”. “Cancel” allows the user to stay put and review their changes. “Discard” (the “Reject” button in this case) gets rid of the changes and the user leaves the view.

```java
status = new Span();
status.setVisible(false);

ConfirmDialog dialog = new ConfirmDialog();
dialog.setHeader("Unsaved changes");
dialog.setText(
        "Do you want to discard or save your changes before navigating away?");

dialog.setCancelable(true);
dialog.addCancelListener(event -> setStatus("Canceled"));

dialog.setRejectable(true);
dialog.setRejectText("Discard");
dialog.addRejectListener(event -> setStatus("Discarded"));

dialog.setConfirmText("Save");
dialog.addConfirmListener(event -> setStatus("Saved"));

Button button = new Button("Open confirm dialog");
button.addClickListener(event -> {
    dialog.open();
    status.setVisible(false);
});
```

## Closing

Confirm Dialog can be closed by clicking one of its buttons (all buttons close the dialog by default), or by pressing  Esc  (which triggers the action associated with the Cancel button if one exists). Closing on  Esc  can be disabled by setting the noCloseOnEsc property to false.

# Context Menu

Context Menu is a component that you can attach to any component to display a context menu. The menu appears on right (default) or left click. On a touch device, a long press opens the context menu.

Open the Context Menu by right-clicking (mouse) or long-pressing (touch) a Grid row.

```java
GridContextMenu<Person> menu = grid.addContextMenu();
menu.addItem("View", event -> {
});
menu.addItem("Edit", event -> {
});
menu.addItem("Delete", event -> {
});
```

## Dividers

You can use dividers to separate and group related content. Use dividers sparingly to avoid creating unnecessary visual clutter.

Open the Context Menu by right-clicking (mouse) or long-pressing (touch) a Grid row.

```java
GridContextMenu<Person> menu = grid.addContextMenu();
menu.addItem("View", event -> {
});
menu.add(new Hr());
menu.addItem("Edit", event -> {
});
menu.addItem("Delete", event -> {
});
menu.add(new Hr());
menu.addItem("Email", event -> {
});
menu.addItem("Call", event -> {
});
```

## Checkable Menu Items

Checkable Menu Items can be used to toggle a setting on and off.

```java
assignee = new Span();
menu = new ContextMenu();
menu.setTarget(assignee);

List<Person> people = DataService.getPeople(5);
for (Person person : people) {
    MenuItem menuItem = menu.addItem(person.getFullName(), event -> {
        setAssignee(person);
    });
    menuItem.setCheckable(true);
}

setAssignee(people.get(0));

...

private void setAssignee(Person person) {
    // Update checked state of menu items
    menu.getItems().forEach(item -> item
            .setChecked(item.getText().equals(person.getFullName())));

    assignee.setText(person.getFullName());
}
```

## Hierarchical Menu

Context Menu, like Menu Bar, supports multi-level sub-menus. You can use a hierarchical menu to organize a large set of options and group related items.

Open the Context Menu by right-clicking (mouse) or long-pressing (touch) a Grid row.

```java
GridContextMenu<File> menu = grid.addContextMenu();
GridMenuItem<File> export = menu.addItem("Export");
GridSubMenu<File> exportSubMenu = export.getSubMenu();
exportSubMenu.addItem("Portable Document Format (.pdf)", event -> {
});
exportSubMenu.addItem("Rich Text Format (.rtf)", event -> {
});
exportSubMenu.addItem("Plain text (.txt)", event -> {
});
```

## Custom Items

You can customize the items to include more than a single line of text.

Open the Context Menu by right-clicking (mouse) or long-pressing (touch) a Grid row.

```java
GridContextMenu<Person> menu = grid.addContextMenu();
GridMenuItem<Person> assign = menu.addItem("Assign");
assign.addComponentAsFirst(createIcon(VaadinIcon.USER_CHECK));

GridSubMenu<Person> assignSubMenu = assign.getSubMenu();
people.subList(5, 10).forEach(person -> {
    assignSubMenu.addItem(createPersonItem(person), event -> {
    });
});

// ...

private Component createPersonItem(Person person) {
    Avatar avatar = new Avatar();
    avatar.setImage(person.getPictureUrl());
    avatar.setName(person.getFirstName());

    Span name = new Span(person.getFullName());
    Span apps = new Span(getApplicationCount());
    apps.getStyle().set("color", "var(--lumo-secondary-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");

    VerticalLayout verticalLayout = new VerticalLayout(name, apps);
    verticalLayout.setPadding(false);
    verticalLayout.setSpacing(false);

    HorizontalLayout horizontalLayout = new HorizontalLayout(avatar,
            verticalLayout);
    horizontalLayout.setAlignItems(FlexComponent.Alignment.CENTER);
    horizontalLayout.getStyle().set("line-height",
            "var(--lumo-line-height-m)");
    return horizontalLayout;
}
```

## Styling Menu Items

Individual menu items can be styled by  applying custom class names  to them, and writing CSS style blocks targeting those class names.

```java
MenuItem item = menu.addItem("Delete");
item.setClassName("text-error");
```

Use theme names instead of class names in V24.2 and older

In versions prior to 24.3, theme names must be used instead (`theme`  property /  `addThemeNames`  Java method). The CSS syntax for targeting a theme name is  `[theme~="custom-theme"]`

## Disabled Menu Items

You can disable menu items to show that they are unavailable.

Open the Context Menu by right-clicking (mouse) or long-pressing (touch) a Grid row.

```java
GridContextMenu<File> menu = grid.addContextMenu();

GridMenuItem<File> export = menu.addItem("Export");
GridSubMenu<File> exportSubMenu = export.getSubMenu();
GridMenuItem<File> exportPDF = exportSubMenu
        .addItem("Portable Document Format (.pdf)", event -> {
        });
exportPDF.setEnabled(false);

GridMenuItem<File> delete = menu.addItem("Delete", event -> {
});
delete.setEnabled(false);
```

## Left-Click

You can use left-click to open Context Menu in situations where left-click doesn’t have any other function, for example a Grid without selection support.

Open the Context Menu by clicking a Grid row.

```java
GridContextMenu<Person> menu = grid.addContextMenu();
menu.setOpenOnClick(true);
menu.addItem("View", event -> {
});
menu.addItem("Edit", event -> {
});
menu.addItem("Delete", event -> {
});
```

## Best Practices

Context Menu is used to provide shortcuts to the user. You shouldn’t use it as the only or primary means to complete a task. The primary way should be accessible elsewhere in the UI.

Open the Context Menu by right-clicking (desktop) or long-pressing (mobile) a Grid row, or use the Menu Bar in the last column.

Name

Size

Annual Report.docx

24 MB

···

Financials.xlsx

42 MB

···


```java
grid.addComponentColumn(file -> {
    MenuBar menuBar = new MenuBar();
    menuBar.addThemeVariants(MenuBarVariant.LUMO_TERTIARY);
    menuBar.addItem("Preview", event -> {
    });
    menuBar.addItem("Edit", event -> {
    });
    menuBar.addItem("Delete", event -> {
    });
    return menuBar;
}).setWidth("70px").setFlexGrow(0);

GridContextMenu<File> menu = grid.addContextMenu();
menu.addItem("Preview", event -> {
});
menu.addItem("Edit", event -> {
});
menu.addItem("Delete", event -> {
});
```

### Context Menu vs Menu Bar

You should use Context Menu when there is no dedicated button for opening an overlay menu, such as right-clicking a grid row. When there is a dedicated element/component, such as an  [overflow menu](https://vaadin.com/docs/latest/components/menu-bar), use Menu Bar.

### Icons

Use icons when applicable to help improve recognition. It’s recommended to use commonly recognized icons to avoid confusion. Use icons consistently throughout a list of options.

### Labelling

Suffix a menu item with “…​” when the associated action won’t be executed, but instead reveal some UI, like a dialog, for completing the action.

# Custom Field

Custom Field is a component for wrapping multiple components as a single field. It provides standard input field features like label, helper, validation, and data binding. Use it to create custom input components.


## Basic Usage

Custom Field is optimized for wrapping the following components:

-   [Text Field](https://vaadin.com/docs/latest/components/text-field)

-   [Number Field](https://vaadin.com/docs/latest/components/number-field)

-   [Password Field](https://vaadin.com/docs/latest/components/password-field)

-   [Text Area](https://vaadin.com/docs/latest/components/text-area)

-   [Select](https://vaadin.com/docs/latest/components/select)

-   [Combo Box](https://vaadin.com/docs/latest/components/combo-box)

-   [Date Picker](https://vaadin.com/docs/latest/components/date-picker)

-   [Time Picker](https://vaadin.com/docs/latest/components/time-picker)


It can also be used to give a label, helper, and other field features for components that don’t have them built-in, such as  [List Box](https://vaadin.com/docs/latest/components/list-box).

## Value Type & Format

The type, format, and further propagation of the Custom Field value are handled differently in Java, and in Lit and React. The following two sections explain how you might configure these aspects depending on the programming language or approach you prefer.

### Java

Custom Field is a generic class that accepts a value type. The value type can be anything: String, List, a bean, or something else.

When the type is specified, you need to establish how the Custom Field’s value should propagate to the child components and vice versa. The value propagation heavily depends on the Custom Field’s structure, contained components, and their types. For this reason, no default implementation is provided. Instead, Custom Field provides two methods that should be implemented manually:  `generateModelValue`; and  `setPresentationValue`.

The  `generateModelValue`  method defines how to generate a Custom Field value from the child components values. Custom Field triggers this method to update its value when a child component emits a change DOM event on the client-side. In this method, you typically need to collect values from all child components and return a single value of the Custom Field type based on those values.

The  `setPresentationValue`  method receives a Custom Field value and defines how to distribute it to the child components. Custom Field triggers this method to update child component values when its value changes programmatically on the server-side. In this method, you typically need to split the given value into parts and apply them to each individual child component, respectively.

The following example shows how to set up value propagation, using a bean as the value type:

```java
class Phone {
    private final String code;
    private final String number;

    public Phone(String code, String number) {
        this.code = code;
        this.number = number;
    }

    public String getCode() {
        return code;
    }

    public String getNumber() {
        return number;
    }
}

class PhoneField extends CustomField<Phone> {
    private final Select code = new Select();
    private final TextField number = new TextField();

    public PhoneField() {
        ...

        add(code, number);
    }

    @Override
    protected String generateModelValue() {
        return new Phone(code.getValue(), number.getValue());
    }

    @Override
    protected void setPresentationValue(Phone value) {
        code.setValue(value.getCode());
        number.setValue(value.getNumber());
    }
}
```

### Lit & React

Custom Field supports only string values. However, it does provide control over the format of the value with a parser and formatter. The parser and formatter define how Custom Field’s value should be split to child component values and vice versa. When a child component emits a change event or the Custom Field’s value changes programmatically, Custom Field propagates values based on the result of the parser or formatter.

#### Parser

When Custom Field’s value changes programmatically, Custom Field passes this value to the parser. The parser is supposed to convert this value into an array of child values, arranged in the order their components appear in the DOM. Custom Field then assigns these values to the child components using their value property.

The default parser returns an array of child component values, splitting the value by the  `\t`  character.

#### Formatter

When Custom Field detects a change event from a child component, it collects the value properties from all child components and passes them as an array to the formatter. The array contains child values in the order their components appear in the DOM. The formatter is supposed to transform this array into a single string value. The Custom Field then updates its value based on the string returned by the formatter.

The default formatter returns a concatenation of the child component values, separated by the  `\t`  character.

You can customize the value format by defining your own value formatter and parser, as shown in the following example:

```ts
render() {
  return html`
    <!-- Phone Custom Field -->
    <vaadin-custom-field
      .formatValue="${([code, number]: unknown[]) => {
        return code && number ? [code, number].join('|') : '';
      }}"
      .parseValue="${(value: string) => {
        return value ? value.split('|') : ['', ''];
      }}"
    >
      <!-- Country code -->
      <vaadin-select></vaadin-select>

      <!-- Phone number -->
      <vaadin-text-field></vaadin-text-field>
    </vaadin-custom-field>
  `
}
```

## Native Input Fields

Custom Field works with native HTML elements. The  `whitespace`  variant can be used when components without an outer margin are used within Custom Field to compensate for the missing space between the label and the component itself.

```java
public class PaymentInformationField extends CustomField<PaymentInformation> {

    private Input cardholderName;
    private Input cardNumber;
    private Input securityCode;

    public PaymentInformationField(String label) {
        this();
        setLabel(label);
    }

    public PaymentInformationField() {
        cardholderName = createInput("Cardholder name", "[\\p{L} \\-]+");
        cardNumber = createInput("Card number", "[\\d ]{12,23}");
        securityCode = createInput("Security code", "[0-9]{3,4}");

        HorizontalLayout layout = new HorizontalLayout(cardholderName,
                cardNumber, securityCode);
        // Removes default spacing
        layout.setSpacing(false);
        // Adds small amount of space between the components
        layout.getThemeList().add("spacing-s");

        // Increases padding of field's label
        addThemeVariants(CustomFieldVariant.LUMO_WHITESPACE);

        add(layout);
    }

    private Input createInput(String label, String pattern) {
        Input input = new Input();
        input.getElement().setAttribute("aria-label", label);
        input.getElement().setAttribute("pattern", pattern);
        input.getElement().setAttribute("required", true);
        input.setPlaceholder(label);
        input.setType("text");
        return input;
    }

    @Override
    protected PaymentInformation generateModelValue() {
        return new PaymentInformation(cardholderName.getValue(),
                cardNumber.getValue(), securityCode.getValue());
    }

    @Override
    protected void setPresentationValue(PaymentInformation paymentInformation) {
        cardholderName.setValue(paymentInformation.getCardholderName());
        cardNumber.setValue(paymentInformation.getCardNumber());
        securityCode.setValue(paymentInformation.getSecurityCode());
    }
}
```

## Size Variants

The small theme variant can be used to make Custom Field’s label, helper, and error message smaller. Custom Field doesn’t propagate its theme variant to its internal components. Each internal component’s theme variant must be set individually.

Price

Currency

```java
public class MoneyField extends CustomField<Money> {

    private TextField amount;
    private Select<String> currency;

    public MoneyField(String label) {
        this();
        setLabel(label);
    }

    public MoneyField() {
        amount = new TextField();
        // Sets title for screen readers
        amount.setAriaLabel("Amount");

        currency = new Select<>();
        currency.setItems("AUD", "CAD", "CHF", "EUR", "GBP", "JPY", "USD");
        currency.setWidth("6em");
        currency.setAriaLabel("Currency");

        HorizontalLayout layout = new HorizontalLayout(amount, currency);
        // Removes default spacing
        layout.setSpacing(false);
        // Adds small amount of space between the components
        layout.getThemeList().add("spacing-s");

        add(layout);
    }

    public void addThemeVariant(CustomFieldVariant variant) {
        super.addThemeVariants(variant);
        amount.addThemeVariants(TextFieldVariant.valueOf(variant.name()));
        currency.addThemeVariants(SelectVariant.valueOf(variant.name()));
    }

    @Override
    protected Money generateModelValue() {
        return new Money(amount.getValue(), currency.getValue());
    }

    @Override
    protected void setPresentationValue(Money money) {
        amount.setValue(money.getAmount());
        currency.setValue(money.getCurrency());
    }
}
```

# Date Picker

Date Picker is an input field that allows the user to enter a date by typing or by selecting from a calendar overlay.

Try clicking the calendar icon. A calendar overlay appears, showing the current month. Click on a date to select it.

```java
DatePicker datePicker = new DatePicker("Start date");
add(datePicker);
```

The date can be entered directly using the keyboard in the format of the current locale or through the date picker overlay. The overlay opens when the field is clicked or any input is entered when the field is focused.

## Validation

To validate a date entered or selected, various ways may be used. For instance, you may want to allow only dates in a certain range, or you might not want to allow certain dates. Below are some of your options for date validation.

### Min & Max Value

The valid input range of Date Picker can be restricted by defining  `min`  and  `max`  values. Dates before the  `min`  and after the  `max`  are disabled in the overlay. Helper text can be used to inform the user about the accepted range.

```java
LocalDate now = LocalDate.now(ZoneId.systemDefault());

datePicker.setMin(now);
datePicker.setMax(now.plusDays(60));
datePicker.setHelperText("Must be within 60 days from today");
datePicker.addValueChangeListener(event -> {
    LocalDate value = datePicker.getValue();
    String errorMessage = null;
    if (value != null) {
        if (value.compareTo(datePicker.getMin()) < 0) {
            errorMessage = "Too early, choose another date";
        } else if (value.compareTo(datePicker.getMax()) > 0) {
            errorMessage = "Too late, choose another date";
        }
    }
    datePicker.setErrorMessage(errorMessage);
});
```

### Custom Validation

Date Picker supports custom validation, such as limiting the options to Monday through Friday. In the following example, select a date that’s on a Sunday or a Saturday to see a custom validation message.

```java
DatePicker datePicker = new DatePicker("Meeting date");
datePicker.setHelperText("Mondays – Fridays only");

Binder<Appointment> binder = new Binder<>(Appointment.class);
binder.forField(datePicker).withValidator(localDate -> {
    int dayOfWeek = localDate.getDayOfWeek().getValue();
    boolean validWeekDay = dayOfWeek >= 1 && dayOfWeek <= 5;
    return validWeekDay;
}, "Select a weekday").bind(Appointment::getStartDate,
        Appointment::setStartDate);
```

## Week Numbers

Week numbers ([ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html)) can be enabled in the calendar overlay. This works only when the first day of the week is set to Monday.

```java
datePicker.setWeekNumbersVisible(true);
datePicker
        .setI18n(new DatePicker.DatePickerI18n().setFirstDayOfWeek(1));
```

## Initial Position

Date Picker’s initial position parameter defines which date is focused in the calendar overlay when the overlay is opened. The default, initial position is the selected or current date.

Use this feature to minimize the need for unnecessary navigation or scrolling when the user’s input is expected to be within a certain time. In the following example, click the Date Picker to open the calendar overlay and notice that the highlighted, focused date is in the future (i.e., the last day of the year), instead of the current date.

```java
LocalDate lastDayOfYear = LocalDate.now(ZoneId.systemDefault())
        .with(TemporalAdjusters.lastDayOfYear());

datePicker.setInitialPosition(lastDayOfYear);
```

## Auto Open

The overlay automatically opens when the field is focused with a click or a tap, and when typing a value in the input. This can be prevented to have the overlay only open when the toggle button or the up/down arrow keys are pressed. This behavior isn’t affected, though, on touch devices.

```java
datePicker.setAutoOpen(false);
```

## Internationalization (i18n)

Date Picker allows localizing text and labels, such as month names and button labels.

```java
DatePicker.DatePickerI18n germanI18n = new DatePicker.DatePickerI18n();
germanI18n.setMonthNames(List.of("Januar", "Februar", "März", "April",
        "Mai", "Juni", "Juli", "August", "September", "Oktober",
        "November", "Dezember"));
germanI18n.setWeekdays(List.of("Sonntag", "Montag", "Dienstag",
        "Mittwoch", "Donnerstag", "Freitag", "Samstag"));
germanI18n.setWeekdaysShort(
        List.of("So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"));
germanI18n.setToday("Heute");
germanI18n.setCancel("Abbrechen");

datePicker.setI18n(germanI18n);
```

See also how to  [configure a custom date format](https://vaadin.com/docs/latest/components/date-picker/date-formats).

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/date-picker#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/date-picker#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/date-picker#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/date-picker#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/date-picker#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/date-picker#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix

A prefix element — rendered at the start of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/date-picker#label), a  [Helper](https://vaadin.com/docs/latest/components/date-picker#helper)  or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-date-picker accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-date-picker accessible-name="This is the label">...
```

```java
DatePicker field = new DatePicker();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.VAADIN_H.create());
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
DatePicker readonlyField = new DatePicker();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue(LocalDate.of(2020, 6, 12));

DatePicker disabledField = new DatePicker();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
DatePicker field = new DatePicker();
field.addThemeVariants(DatePickerVariant.LUMO_SMALL,
        DatePickerVariant.LUMO_ALIGN_RIGHT,
        DatePickerVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Usage Patterns

### Date Range

You can create a date range picker using the Date Picker twice. Imagine the following example is for an airline ticket booking page. It’s asking the user for the date they want to depart and when they want to return. Try it: select a departure date, and then proceed to select a return date. Notice how dates prior to the departure date you chose are now disabled.

```java
DatePicker departureDate = new DatePicker("Departure date");
DatePicker returnDate = new DatePicker("Return date");
departureDate
        .addValueChangeListener(e -> returnDate.setMin(e.getValue()));
returnDate.addValueChangeListener(
        e -> departureDate.setMax(e.getValue()));
```

To disable the days before the start date in the end date picker, you need to handle the selection in the start date picker and change the range in the end date picker.

## Best Practices

### Picking vs. Typing

The calendar overlay is useful when the user needs to choose a day that’s close to the current date or when information such as day of the week, week number, valid dates, and so on can aid in choosing the best option.

For far off dates (i.e., years ago or years from now) and for known dates (i.e., holidays and birthdays), typing the date in the input field can be faster and easier. Because of this, it’s important to verify that the user can enter dates according to their locale.

Instead of a Date Picker, you can use individual input fields (i.e., day, month, and year) to improve usability on small touch devices. In the following example, focus the year field and start to type a year. As you enter each digit, notice the list of choices narrows.

Year

Month

Day

```java
public DatePickerIndividualInputFields() {
    LocalDate now = LocalDate.now(ZoneId.systemDefault());

    List<Integer> selectableYears = IntStream
            .range(now.getYear() - 99, now.getYear() + 1).boxed()
            .collect(Collectors.toList());

    yearPicker = new ComboBox<>("Year", selectableYears);
    yearPicker.setWidth(6, Unit.EM);
    yearPicker.addValueChangeListener(e -> {
        updateMonthPicker();
        updateDayPicker();
    });

    monthPicker = new ComboBox<>("Month", Month.values());
    monthPicker.setItemLabelGenerator(
            m -> m.getDisplayName(TextStyle.FULL, Locale.getDefault()));
    monthPicker.setWidth(9, Unit.EM);
    monthPicker.addValueChangeListener(e -> {
        updateDayPicker();
    });
    monthPicker.setEnabled(false);

    dayPicker = new ComboBox<>("Day");
    dayPicker.setWidth(5, Unit.EM);
    dayPicker.setEnabled(false);

    add(new HorizontalLayout(yearPicker, monthPicker, dayPicker));
}

private void updateMonthPicker() {
    if (yearPicker.getValue() == null) {
        monthPicker.setValue(null);
        monthPicker.setEnabled(false);
        return;
    }

    monthPicker.setValue(null);
    monthPicker.setEnabled(true);
}

private void updateDayPicker() {
    if (yearPicker.getValue() == null || monthPicker.getValue() == null) {
        dayPicker.setValue(null);
        dayPicker.setEnabled(false);
        return;
    }

    dayPicker.setValue(null);
    dayPicker.setEnabled(true);

    LocalDate startOfMonth = LocalDate.of(yearPicker.getValue(),
            monthPicker.getValue(), 1);
    int lengthOfMonth = startOfMonth.lengthOfMonth();

    dayPicker.setItems(IntStream.range(1, lengthOfMonth + 1).boxed()
            .collect(Collectors.toList()));
}
```

Not Production-Ready

The previous example is only a prototype implementation to demonstrate the concept. It isn’t ready for production use.

### Show the Date Format

Use a placeholder or helper to show how the input should be formatted. For example, "12/6/2020" represents different dates for Americans and Europeans. For most Americans, it’s a date in December. For many Europeans, it’s a date in June.

Start date

Format: DD.MM.YYYY

```java
datePicker.setPlaceholder("DD.MM.YYYY");
datePicker.setHelperText("Format: DD.MM.YYYY");
```

Helpers are preferable to placeholders, as they’re always visible. Fields with placeholders are also less noticeable than empty fields, so they are susceptible to being skipped. Use placeholders when space is limited, for example when Date Picker is used as a filter in a data grid header.

# Date Time Picker

Date Time Picker is an input field for selecting both a date and a time.

```java
DateTimePicker dateTimePicker = new DateTimePicker();
dateTimePicker.setLabel("Meeting date and time");
add(dateTimePicker);
```

The date and time can be entered directly using the keyboard in the format of the current locale or through the Date Time Picker’s two overlays. The overlays open when their respective fields are clicked or any input is entered when the fields are focused.

## Step

Date Time Picker’s step parameter defines the time interval in seconds between the items displayed in the time picker overlay. It also specifies the amount by which the time increases or decreases using the up and down arrow keys when the overlays are disabled.

The default step is one hour (that is,  `3600`). Unlike with  [Number Field](https://vaadin.com/docs/latest/components/number-field), Date Time Picker accepts values that don’t align with the specified step.

```java
DateTimePicker dateTimePicker = new DateTimePicker();
dateTimePicker.setLabel("Meeting date and time");
dateTimePicker.setStep(Duration.ofMinutes(30));
dateTimePicker.setValue(LocalDateTime.of(2020, 6, 12, 12, 30, 0));
add(dateTimePicker);
```

Use Even Steps

The step must divide evenly an hour or a day. For example,  _"15 minutes"_,  _"30 minutes"_  and  _"2 hours"_  are valid steps, while  _"42 minutes"_  isn’t.

The displayed time format changes based on the step.

```java
DateTimePicker dateTimePicker = new DateTimePicker();
dateTimePicker.setLabel("Message received");
dateTimePicker.setStep(Duration.ofSeconds(1));
dateTimePicker.setValue(LocalDateTime.of(2020, 6, 12, 15, 45, 8));
add(dateTimePicker);
```

Step

Format

Less than 60 seconds

HH:MM:SS

Less than 1 second

HH:MM:SS:FFF

Limit Number of Steps

The overlay doesn’t appear for steps less than 900 seconds (i.e., 15 minutes) to avoid showing an impractical number of choices.

## Auto Open

The overlay opens automatically when the field is focused using a pointer (i.e., mouse or touch), or when the user types in the field. You can disable this so that the overlay opens only when the toggle button or the  Up/Down  arrow keys are pressed.

```java
dateTimePicker.setAutoOpen(false);
```

## Validation

### Min & Max Values

You can define a  `min`  and  `max`  value for Date Time Picker if you need to restrict the input to a specific range:


```java
DateTimePicker dateTimePicker = new DateTimePicker();
dateTimePicker.setLabel("Appointment date and time");
dateTimePicker.setHelperText("Must be within 60 days from today");
dateTimePicker.setAutoOpen(true);
dateTimePicker.setMin(LocalDateTime.now());
dateTimePicker.setMax(LocalDateTime.now().plusDays(60));
dateTimePicker.setValue(LocalDateTime.now().plusDays(7));
dateTimePicker.addValueChangeListener(event -> {
    LocalDateTime value = event.getValue();
    String errorMessage = null;
    if (value != null) {
        if (value.compareTo(dateTimePicker.getMin()) < 0) {
            errorMessage = "Too early, choose another date and time";
        } else if (value.compareTo(dateTimePicker.getMax()) > 0) {
            errorMessage = "Too late, choose another date and time";
        }
    }
    dateTimePicker.setErrorMessage(errorMessage);
});
add(dateTimePicker);
```

### Custom Validation

If the  `min`  and  `max`  values aren’t enough, you can also apply custom validation.

```java
DateTimePicker dateTimePicker = new DateTimePicker();
dateTimePicker.setLabel("Appointment date and time");
dateTimePicker
        .setHelperText("Open Mondays-Fridays, 8:00-12:00, 13:00-16:00");
dateTimePicker.setStep(Duration.ofMinutes(30));
add(dateTimePicker);

String errorMessage = "The selected day of week or time is not available";
Binder<Appointment> binder = new Binder<>(Appointment.class);
binder.forField(dateTimePicker).withValidator(startDateTime -> {
    boolean validWeekDay = startDateTime.getDayOfWeek().getValue() >= 1
            && startDateTime.getDayOfWeek().getValue() <= 5;
    return validWeekDay;
}, errorMessage).withValidator(startDateTime -> {
    LocalTime startTime = LocalTime.of(startDateTime.getHour(),
            startDateTime.getMinute());
    boolean validTime = !(LocalTime.of(8, 0).isAfter(startTime)
            || (LocalTime.of(12, 0).isBefore(startTime)
                    && LocalTime.of(13, 0).isAfter(startTime))
            || LocalTime.of(16, 0).isBefore(startTime));
    return validTime;
}, errorMessage).bind(Appointment::getStartDateTime,
        Appointment::setStartDateTime);
```

## Week Numbers

You can configure Date Time Picker to show week numbers in the date picker overlay.

```java
dateTimePicker.setWeekNumbersVisible(true);
dateTimePicker.setDatePickerI18n(
        new DatePicker.DatePickerI18n().setFirstDayOfWeek(1));
```

The week numbers are displayed according to  [ISO-8601](https://www.iso.org/iso-8601-date-and-time-format.html). They can only be displayed with the first day of the week set to Monday.

## Initial Position

Date Time Picker’s initial position parameter defines which date is focused in the calendar overlay when the overlay is opened. Use this feature to minimize the need for any additional navigation or scrolling when the user’s input is expected to be between certain dates.

```java
// https://github.com/vaadin/vaadin-date-time-picker/issues/57
DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE;
LocalDate startOfNextMonth = LocalDate.now(ZoneId.systemDefault())
        .with(TemporalAdjusters.firstDayOfNextMonth());
String startOfNextMonthIsoString = formatter.format(startOfNextMonth);

dateTimePicker.getElement().executeJs("this.initialPosition = $0",
        startOfNextMonthIsoString);
```

## Internationalization (i18n)

Date Time Picker allows localizing texts and labels, such as month names and button labels.

```java
DatePicker.DatePickerI18n germanI18n = new DatePicker.DatePickerI18n();
germanI18n.setMonthNames(List.of("Januar", "Februar", "März", "April",
        "Mai", "Juni", "Juli", "August", "September", "Oktober",
        "November", "Dezember"));
germanI18n.setWeekdays(List.of("Sonntag", "Montag", "Dienstag",
        "Mittwoch", "Donnerstag", "Freitag", "Samstag"));
germanI18n.setWeekdaysShort(
        List.of("So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"));
germanI18n.setToday("Heute");
germanI18n.setCancel("Abbrechen");

dateTimePicker.setDatePickerI18n(germanI18n);
```

See also how to  [configure a custom date format](https://vaadin.com/docs/latest/components/date-picker#date-format).

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/date-time-picker#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/date-time-picker#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/date-time-picker#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/date-time-picker#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/date-time-picker#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/date-time-picker#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Invisible Labels (ARIA)

If the built-in label cannot be used, an invisible label should be provided for users of assistive technologies like screen readers. The date and time sub-fields can also be assigned invisible suffixes (e.g.,  `date`  and  `time`) that are appended to their invisible labels.

```html
<!-- Invisible label for screen readers: -->
<date-time-picker accessible-name="Meeting">...
<!-- Suffixes for date and time sub-fields are set through the i18n object -->
```

```java
DateTimePicker field = new DateTimePicker();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setDatePlaceholder("Date");
field.setTimePlaceholder("Time");
field.setTooltipText("Tooltip text");
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.
```java
DateTimePicker readonlyField = new DateTimePicker();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue(LocalDateTime.of(2020, 6, 12, 12, 30));
DateTimePicker disabledField = new DateTimePicker();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
DateTimePicker field = new DateTimePicker();
field.addThemeVariants(DateTimePickerVariant.LUMO_SMALL,
        DateTimePickerVariant.LUMO_ALIGN_RIGHT,
        DateTimePickerVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Usage Patterns

### Date Time Range

You can accomplish a date time range picker using two Date Time Pickers.

```java
DateTimePicker startDateTimePicker = new DateTimePicker(
        "Start date and time");
startDateTimePicker.setValue(LocalDateTime.of(2020, 8, 25, 20, 0, 0));

DateTimePicker endDateTimePicker = new DateTimePicker(
        "End date and time");
endDateTimePicker.setValue(LocalDateTime.of(2020, 9, 1, 20, 0, 0));

startDateTimePicker.addValueChangeListener(
        e -> endDateTimePicker.setMin(e.getValue()));

add(startDateTimePicker, endDateTimePicker);
```

To disable the days before the start date in the end date picker, you need to handle the selection in the start date picker and change the range in the end date picker.

## Best Practices

Use Date Time Picker when the user needs to choose both a date and time of day. If you only need a date or time of day, use  [Date Picker](https://vaadin.com/docs/latest/components/date-picker)  or  [Time Picker](https://vaadin.com/docs/latest/components/time-picker), respectively.

### Picking vs. Typing

The calendar overlay is useful when the user needs to choose a day that’s close to the current date or when information such as day of the week, week number, valid dates, and so on, can aid in choosing the best option.

For far off dates (i.e., years ago or years from now) and for known dates (i.e., holidays and birthdays), typing the date can be a faster and easier approach. It’s important to verify that the user can enter dates according to their locale.

### Providing Input Guidance

Use a helper text to show the expected date and time formats, and placeholders to help users identify the two sub-fields, correctly.

Select date and time

Format: DD/MM/YYYY and HH:MM

```java
DatePickerI18n dateFormat = new DatePickerI18n();
dateFormat.setDateFormat("dd/MM/yyyy");

DateTimePicker dateTimePicker = new DateTimePicker();
dateTimePicker.setLabel("Select date and time");
dateTimePicker.setDatePickerI18n(dateFormat);
dateTimePicker.setHelperText("Format: DD/MM/YYYY and HH:MM");
dateTimePicker.setDatePlaceholder("Date");
dateTimePicker.setTimePlaceholder("Time");
add(dateTimePicker);
```

# Details

Details is an expandable panel for showing and hiding content from the user, to make the UI less cluttered.

```java
Span name = new Span("Sophia Williams");
Span email = new Span("sophia.williams@company.com");
Span phone = new Span("(501) 555-9128");

VerticalLayout content = new VerticalLayout(name, email, phone);
content.setSpacing(false);
content.setPadding(false);

Details details = new Details("Contact information", content);
details.setOpened(true);

add(details);
```

## Anatomy

Details consist of a summary area and a content area.

### Summary

The Summary is the part that’s always visible, and typically describes the content, for example with a title. Clicking on the summary toggles the content area’s visibility.

The summary supports rich content and can contain any component. This can be used, for example, to display the status of the corresponding content.


```java
HorizontalLayout summary = new HorizontalLayout();
summary.setSpacing(false);

Icon icon = VaadinIcon.EXCLAMATION_CIRCLE.create();
icon.getStyle().set("width", "var(--lumo-icon-size-s)");
icon.getStyle().set("height", "var(--lumo-icon-size-s)");

HorizontalLayout errorBadge = new HorizontalLayout(icon,
        new Span(" 2 errors"));
errorBadge.setSpacing(false);
errorBadge.getStyle().set("color", "var(--lumo-error-text-color)");
errorBadge.getStyle().set("margin-left", "var(--lumo-space-s)");

summary.add(new Text("Contact information"), errorBadge);

FormLayout content = new FormLayout();
content.setResponsiveSteps(new FormLayout.ResponsiveStep("0", 1),
        new FormLayout.ResponsiveStep("20em", 2));

TextField address = new TextField("Address");
address.setValue("4027 Amber Lake Canyon");
content.add(address, 2);

TextField zipCode = new TextField("ZIP code");
zipCode.setRequired(true);
content.add(zipCode);

TextField city = new TextField("City");
city.setRequired(true);
content.add(city);

ComboBox<Country> countries = new ComboBox<>("Country");
countries.setItems(DataService.getCountries());
countries.setItemLabelGenerator(Country::getName);
content.add(countries);

Details details = new Details(summary, content);
details.setOpened(true);

add(details);
```

### Content

This is the collapsible part of Details. It can contain any component. When the content area is collapsed, the content is invisible and inaccessible by keyboard or screen reader.

```java
Details analyticsDetails = createDetails("Analytics",
        createStyledAnchor("#", "Dashboard"),
        createStyledAnchor("#", "Reports"),
        createStyledAnchor("#", "Data sources"));

Details customersDetails = createDetails("Customers",
        createStyledAnchor("#", "Accounts"),
        createStyledAnchor("#", "Contacts"));

Details financesDetails = createDetails("Finances",
        createStyledAnchor("#", "Invoices"),
        createStyledAnchor("#", "Transactions"),
        createStyledAnchor("#", "Statements"));

add(analyticsDetails, customersDetails, financesDetails);
```

## Theme Variants

Details has three theme variants:  `filled`,  `small`, and  `reverse`. These variants can be combined with each other. For example, all three theme variants can be applied to the same Details component.

### Filled

The  `filled`  theme variant makes the component’s boundaries visible, which helps tie its content together visually and distinguishes it from the surrounding UI.

```java
UnorderedList content = new UnorderedList(new ListItem("Blake Martin"),
        new ListItem("Caroline Clark"), new ListItem("Avery Torres"),
        new ListItem("Khloe Scott"), new ListItem("Camila Fisher"),
        new ListItem("Gavin Lewis"), new ListItem("Isabella Powell"),
        new ListItem("Zoe Wilson"));

Details details = new Details("Members (8)", content);
details.setOpened(true);
details.addThemeVariants(DetailsVariant.FILLED);

add(details);
```

### Small

Use the  `small`  theme variant for compact UIs.

```java
UnorderedList content = new UnorderedList(new ListItem("Blake Martin"),
        new ListItem("Caroline Clark"), new ListItem("Avery Torres"),
        new ListItem("Khloe Scott"), new ListItem("Camila Fisher"),
        new ListItem("Gavin Lewis"), new ListItem("Isabella Powell"),
        new ListItem("Zoe Wilson"));

Details details = new Details("Members (8)", content);
details.setOpened(true);
details.addThemeVariants(DetailsVariant.SMALL);

add(details);
```

### Reverse

The reverse theme variant places the toggle icon after the summary contents, which can be useful for visually aligning the summary with other content.

Members (8)

-   Blake Martin
-   Caroline Clark
-   Avery Torres
-   Khloe Scott
-   Camila Fisher
-   Gavin Lewis
-   Isabella Powell
-   Zoe Wilson

```java
UnorderedList content = new UnorderedList(new ListItem("Blake Martin"),
        new ListItem("Caroline Clark"), new ListItem("Avery Torres"),
        new ListItem("Khloe Scott"), new ListItem("Camila Fisher"),
        new ListItem("Gavin Lewis"), new ListItem("Isabella Powell"),
        new ListItem("Zoe Wilson"));

Details details = new Details("Members (8)", content);
details.setOpened(true);
details.addThemeVariants(DetailsVariant.REVERSE);

add(details);
```

### Disabling

Details can be disabled to prevent them from being expanded or collapsed. Components inside a disabled expanded Details are automatically disabled as well.

```java
UnorderedList content = new UnorderedList(new ListItem("Blake Martin"),
        new ListItem("Caroline Clark"), new ListItem("Avery Torres"),
        new ListItem("Khloe Scott"), new ListItem("Camila Fisher"),
        new ListItem("Gavin Lewis"), new ListItem("Isabella Powell"),
        new ListItem("Zoe Wilson"));

Details details = new Details("Members (8)", content);
details.setEnabled(false);

add(details);
```

## Best Practices

Use Details to group related content and to reduce the chance of overwhelming the user with information. However, avoid putting important information in a Details component unless it’s expanded by default. Otherwise, the user might not notice it.

Details can be used instead of Accordion if there’s a need to see content from multiple collapsible content areas, simultaneously.

The expandable and collapsible nature of Details can sometimes be difficult for users to discover. Use the  [filled variant](https://vaadin.com/docs/latest/components/details#filled)  and apply a  [tooltips](https://vaadin.com/docs/latest/components/tooltip)  to make this more discoverable.

# Dialog
Dialog is a small window that can be used to present information and user interface elements in an overlay.

```java
Dialog dialog = new Dialog();

dialog.setHeaderTitle("New employee");

VerticalLayout dialogLayout = createDialogLayout();
dialog.add(dialogLayout);

Button saveButton = createSaveButton(dialog);
Button cancelButton = new Button("Cancel", e -> dialog.close());
dialog.getFooter().add(cancelButton);
dialog.getFooter().add(saveButton);

Button button = new Button("Show dialog", e -> dialog.open());

add(dialog, button);
```

## Structure

The Dialog component has static header and footer areas, and a scrolling content area between them. The header and footer are optional, and automatically hidden if empty and not explicitly enabled.

### Header

The header contains an optional title element, and a slot next to it for custom header content, such as a close button.

```java
dialog.setHeaderTitle("User details");

Button closeButton = new Button(new Icon("lumo", "cross"),
        (e) -> dialog.close());
closeButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY);
dialog.getHeader().add(closeButton);
```

### Footer

Buttons for closure actions, such as  _Save_,  _Cancel_,  _Delete_, and so on, should be placed in the footer. See the  [Button](https://vaadin.com/docs/latest/components/button#buttons-in-dialogs)  component for guidelines for the placement of buttons in dialogs. Footer content is right-aligned by default. Components can be left-aligned by applying a margin:


```java
Button deleteButton = new Button("Delete", (e) -> dialog.close());
deleteButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
        ButtonVariant.LUMO_ERROR);
deleteButton.getStyle().set("margin-right", "auto");
dialog.getFooter().add(deleteButton);

Button cancelButton = new Button("Cancel", (e) -> dialog.close());
cancelButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY);
dialog.getFooter().add(cancelButton);
```

### Padding

The content area’s built-in padding can be removed by applying the  `no-padding`  theme variant.

```java
dialog.addThemeVariants(DialogVariant.LUMO_NO_PADDING);
```

## Modality

A modal dialog blocks the user from interacting with the rest of the user interface while the dialog is open. A non-modal dialog, however, doesn’t block interaction.

Dialogs are modal by default.

Use modal dialogs for:

-   displaying important information, like system errors

-   requesting user input as part of a workflow, for example an edit dialog

-   confirmation of irreversible actions, such as deleting data (Confirm Dialog is a convenient alternative for these use cases)

-   breaking out sub-tasks into a separate user interface


Modal parent dialogs in Flow

See the  [Technical](https://vaadin.com/docs/latest/components/dialog#technical)  section for details on the behavior of modal dialogs in Vaadin Flow.

Use non-modal dialogs:

-   when the user needs access to the content below the dialog

-   for less critical, optional, and/or support tasks


```java
Dialog dialog = new Dialog();
dialog.setModal(false);
```

Usually, non-modal dialogs should be draggable, so that the user can move them to access the user interface beneath.

## Draggable

Dialogs can be made draggable, enabling the user to move them around using a pointing device.

By default, the outer edges of a dialog, as well as the space between its components, can be used to move the dialog around.

The default areas from which a dialog can be dragged depend on whether the built-in header is used:

-   If the built-in header or footer is used, they function as the default drag handles of the dialog

-   Without the built-in header, any empty space within the dialog functions as a drag handle


Any component contained within a dialog can be marked and used as a drag handle by applying the  `draggable`  class name to it. You can choose whether to make the component’s content draggable as well, or only the component itself.

```java
dialog.setModal(false);
dialog.setDraggable(true);

...

H2 headline = new H2("Add note");
headline.addClassName("draggable");
```

It’s recommended to make non-modal dialogs draggable, so that the user can interact with content that might otherwise be obscured by the Dialog. For example, a Dialog for taking notes or for adding widgets to a dashboard by dragging can offer a better experience by allowing the user to move the Dialog around.

Modal dialogs don’t benefit from being draggable, as their modality curtain (the dark overlay behind the dialog) obscures the underlying user interface.

## Resizable

A resizable dialog allows the user to resize the Dialog by dragging from the edges of the Dialog with a pointing device. Dialogs aren’t resizable by default.

Dialogs containing dynamic content and/or a lot of information, such as complex forms or Grids, may benefit from being resizable, as this offers the user some flexibility with how much data is visible at once. It also gives the user control over which part of the underlying user interface is obscured.

Dialogs that contain very little, or compact, information don’t need to be resizable.
```java
dialog.setDraggable(true);
dialog.setResizable(true);
```

## Closing

Modal dialogs are closable in three ways:

1.  Pressing the  Esc  key

2.  Clicking outside the Dialog

3.  Programmatically, for example through the click of a Button


Providing an explicit button for closing a Dialog is recommended.

```java
Button closeButton = new Button("Close");
closeButton.addClickListener(e -> dialog.close());
```

## Best Practices

### Use Sparingly

Dialogs are disruptive by nature and should be used sparingly. Don’t use them to communicate non-essential information, such as success messages like “Logged in”, “Copied”, and so on. Instead, use  [Notifications](https://vaadin.com/docs/latest/components/notification)  when appropriate.



## Technical

### Multiple Dialogs and Server-side Modality in Flow

By default, opening multiple Dialog components simultaneously in Flow adds each subsequent Dialog as a child of the previous one.

Due to the  [server-side modality mechanism in Flow](https://vaadin.com/docs/latest/flow/advanced/server-side-modality#server-side-modality), this means that closing a modal Dialog automatically also closes all its children, that is, any subsequent Dialogs opened after the modal.

This can be avoided by explicitly adding each Dialog to the UI before opening it:

```java
Dialog d1 = new Dialog();
Dialog d2 = new Dialog();
add(d1, d2);  // Add dialogs to the UI before opening
d1.open();
d2.open();
```

# Email Field

Email Field is an extension of Text Field that accepts only email addresses as input. If the given address is invalid, the field is highlighted in red and an error message appears underneath the input.

```java
EmailField validEmailField = new EmailField();
validEmailField.setLabel("Email address");
validEmailField.getElement().setAttribute("name", "email");
validEmailField.setValue("julia.scheider@email.com");
validEmailField.setErrorMessage("Enter a valid email address");
validEmailField.setClearButtonVisible(true);

EmailField invalidEmailField = new EmailField();
invalidEmailField.setLabel("Email address");
invalidEmailField.getElement().setAttribute("name", "email");
invalidEmailField.setValue("This is not an email");
invalidEmailField.setErrorMessage("Enter a valid email address");
invalidEmailField.setClearButtonVisible(true);

add(validEmailField, invalidEmailField);
```

The validity of the email addresses is checked according to the  [RFC 5322](https://tools.ietf.org/html/rfc5322#)  standard, which includes the format for email addresses.

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/email-field#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/email-field#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/email-field#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/email-field#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/email-field#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/email-field#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix & Suffix

Prefix and suffix elements — rendered at either end of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix and suffix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/email-field#label), a  [Helper](https://vaadin.com/docs/latest/components/email-field#helper), or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.


```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-email-field accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-email-field accessible-name="This is the label">...
```

```java
EmailField field = new EmailField();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.ENVELOPE.create());
```

## Constraints

Required fields are marked with an indicator next to the label, and become invalid if left empty after having been focused. An error message explaining that the field is required needs to be provided manually.

An instruction text at the top of the form explaining the required indicator is recommended. The indicator itself can be customized with the  `--lumo-required-field-indicator`  style property.

Pattern

The pattern attribute is an additional validation criterion that you can set if, for example, a specific domain is required. The pattern is specified using a regular expression.

The example below uses the pattern  `.+@example\.com`  and only accepts addresses in the  `example.com`  domain.

```java
EmailField field = new EmailField("Email address");
field.setRequiredIndicatorVisible(true);
field.setPattern("^.+@example\\.com$");
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
EmailField readonlyField = new EmailField();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue("example@example.com");

EmailField disabledField = new EmailField();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

Label

Helper text

```java
EmailField field = new EmailField();
field.addThemeVariants(TextFieldVariant.LUMO_SMALL,
        TextFieldVariant.LUMO_ALIGN_RIGHT,
        TextFieldVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

# Form Layout
Form Layout allows you to build responsive forms with multiple columns, and to position input labels above or to the side of the input.

```java
TextField firstName = new TextField("First name");
TextField lastName = new TextField("Last name");
TextField username = new TextField("Username");
PasswordField password = new PasswordField("Password");
PasswordField confirmPassword = new PasswordField("Confirm password");

FormLayout formLayout = new FormLayout();
formLayout.add(firstName, lastName, username, password,
        confirmPassword);
formLayout.setResponsiveSteps(
        // Use one column by default
        new ResponsiveStep("0", 1),
        // Use two columns, if layout's width exceeds 500px
        new ResponsiveStep("500px", 2));
// Stretch the username field over 2 columns
formLayout.setColspan(username, 2);
```

## Columns

By default, Form Layout has two columns: it displays two input fields per line. When the layout width is smaller, it adjusts to a single-column.

### Custom Layout

You can define how many columns that Form Layout should use based on the screen width. Use the draggable split handle to resize Form Layout’s available space and to test its responsiveness.

```java
formLayout.setResponsiveSteps(
        // Use one column by default
        new ResponsiveStep("0", 1),
        // Use two columns, if the layout's width exceeds 320px
        new ResponsiveStep("320px", 2),
        // Use three columns, if the layout's width exceeds 500px
        new ResponsiveStep("500px", 3));
```

A single-column layout is preferable to a multi-column layout. A multi-column layout can be prone to confusion and misinterpretation by the user. However, related fields placed in a line are typically understandable. Examples of this would be first and last name, address fields such as city and postal code, and ranged input for dates, time, and price or cost.

### Column Span

When using a multi-column layout, you can define a  `colspan`  for each component. The  `colspan`  determines how many columns a component extends or stretches across.

For example, if you have a Form Layout with three columns and a component’s  `colspan`  is set to 3, it’ll therefore take the entire width of the Form Layout.

```java
formLayout.setColspan(title, 3);
```

## Label Position

The built-in labels for input fields are positioned above the input. Form Layout supports side-positioned labels, provided they’re wrapped in Form Items and the label position is set to  `aside`.

The only reason for wrapping labels in Form Items is to put the labels to the side of the input.

### Top

Users complete forms that have top-positioned labels more quickly because they provide a consistent scanning pattern — top-down, as opposed to zigzag — while minimizing the distance between the label and input field.

Top-positioned labels are also less prone to causing layout issues due to variable label lengths, which happens usually in multilingual applications. However, they do result in vertically longer forms. This is why  [sectioning](https://vaadin.com/docs/latest/components/form-layout#sectioning)  is important.

### Side

Side-positioned labels help reduce a form’s total height. This is especially useful for longer forms and when vertical space is limited.

The positioning of labels on the side is also useful when there’s a need to compare numeric data.

```java
formLayout.setLabelWidth("60px");
// Use addFormItem instead of add, to wrap fields into form items,
// which displays labels on the side by default
formLayout.addFormItem(revenue, "Revenue");
formLayout.addFormItem(expenses, "Expenses");
formLayout.addFormItem(invoices, "Invoices");
```

Aim for similar-length labels to keep the distance consistent between the labels and the input fields. Inconsistent spacing can slow the user in completing a form.

Forms that use this position require more horizontal space, which isn’t always ideal in narrow forms. Instead, configure Form Layout to use top-positioned labels when the form has a narrow width.

The width of side-positioned labels can be adjusted using the  `--vaadin-form-item-label-width`  CSS property on the Form Layout element, or with the  `setLabelWidth()`  method  on the  `FormLayout`  instance in Flow.

### Responsive Label Position

Similar to the number of columns, the label position is configurable based on the width of the layout. For example, you can position the labels to the side when there’s ample horizontal space available, and on top for narrower screens.

## Spacing

Form Layout allows you to configure the spacing between columns, rows, and between the label and input field when labels are positioned on the side.

To configure the spacing, use the following CSS properties on the Form Layout element:

Property

Default Value

`--vaadin-form-layout-column-spacing`

`var(--lumo-space-l)`

`--vaadin-form-item-row-spacing`

`1em`

`--vaadin-form-item-label-spacing`

`1em`

## Native Input Fields

Form Item allows you to set a label for any type of component that you want to use in a Form Layout. It supports both Vaadin components and native HTML components.

```java
formLayout.addFormItem(new Input(), "Revenue");
```

## Multiple Fields

Form Item only supports placing a single field inside. Where you need to place multiple fields,  [Custom Field](https://vaadin.com/docs/latest/components/custom-field)  should be used as a wrapper:

```java
public class ExpirationField extends CustomField<String> {
    private final List<String> MONTHS = IntStream.range(1, 13)
            .mapToObj(month -> String.format("%02d", month))
            .collect(Collectors.toList());
    private final List<String> YEARS = IntStream
            .range(LocalDate.now().getYear(),
                    LocalDate.now().getYear() + 11)
            .mapToObj(year -> Integer.toString(year))
            .collect(Collectors.toList());

    private final Select<String> month = new Select<String>();
    private final Select<String> year = new Select<String>();

    public ExpirationField() {
        HorizontalLayout layout = new HorizontalLayout();
        layout.setPadding(false);
        layout.setSpacing(false);
        layout.getThemeList().add("spacing-xs");

        month.setItems(MONTHS);
        month.setPlaceholder("Month");
        // Set title for screen readers
        month.setAriaLabel("Month");
        layout.add(month);

        year.setItems(YEARS);
        year.setPlaceholder("Year");
        year.setAriaLabel("Year");
        layout.add(year);

        add(layout);
    }

    @Override
    protected String generateModelValue() {
        String monthValue = month.getValue();
        String yearValue = year.getValue();

        if (monthValue == month.getEmptyValue()
                || yearValue == year.getEmptyValue()) {
            return null;
        }

        return String.join("/", monthValue.toString(),
                yearValue.toString());
    }

    @Override
    protected void setPresentationValue(String expiration) {
        if (expiration == null) {
            month.setValue(null);
            year.setValue(null);
        } else {
            String[] expirationParts = expiration.split("/");
            month.setValue(expirationParts[0]);
            year.setValue(expirationParts[1]);
        }

    }
}

public FormLayoutCustomField() {
    FormLayout formLayout = new FormLayout();
    formLayout.addFormItem(new ExpirationField(), "Expiration");
    add(formLayout);
}
```

Keeping fields in individual Form Items is preferable. Wrapped fields can be hard to distinguish visually since they usually have no individual label except for a placeholder, which is only visible when the field has no value.

## Best Practices

With regards to developing with Form Layout, this section provides some suggestions for better user experiences.

### Sectioning

Longer forms should be split into smaller, more manageable and user-friendly sections using sub-headings,  [Tabs](https://vaadin.com/docs/latest/components/tabs),  [Details](https://vaadin.com/docs/latest/components/details)  or separate views when possible. Each section should consist of related content and fields.

### Button Placement

Use the following guidelines for Button placement in forms:

-   Buttons should be placed below the form with which they’re associated.

-   Buttons should be aligned to the left.

-   Primary action should be placed first, followed by other actions, in order of importance.


For more information, see the  [Button documentation](https://vaadin.com/docs/latest/components/button).

# Grid

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getFirstName).setHeader("First name");
grid.addColumn(Person::getLastName).setHeader("Last name");
grid.addColumn(Person::getEmail).setHeader("Email");
grid.addColumn(Person::getProfession).setHeader("Profession");

List<Person> people = DataService.getPeople();
grid.setItems(people);
```

Auto-generated columns in Flow Grid

Although most code examples define columns explicitly, the Flow component can generated them automatically based root-level properties on the bean class if you pass it as an argument to the constructor, e.g.  `new Grid<>(Person.class);`

## Dynamic Height

Grid has a default height of 400 pixels. It becomes scrollable when items contained in it overflow the allocated space.

In addition to setting any fixed or relative value, the height of a grid can be set by the number of items in the dataset. The grid expands and retracts based on the row count. This feature disables scrolling. It shouldn’t be used with large data sets since it might cause performance issues.

Notice how the height of the rows in the earlier example adjusts because of the text in the  _Address_  cells wrapping. With that in mind, click the gray icon at the top right corner of the example below to open it in a new browser tab. Try resizing it, making it narrower and then wider. Notice how the rows are always the same height and that the text doesn’t wrap. Instead, the text is truncated with ellipses.

```java
grid = new Grid<>(Person.class, false);
grid.setAllRowsVisible(true);
```

## Selection

Grid supports single and multi-select modes. Neither is enabled by default.

### Single-Selection Mode

In single-selection mode, the user can select and deselect rows by clicking anywhere on the row.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getFirstName).setHeader("First name");
grid.addColumn(Person::getLastName).setHeader("Last name");
grid.addColumn(Person::getEmail).setHeader("Email");

List<Person> people = DataService.getPeople();
grid.setItems(people);

grid.addSelectionListener(selection -> {
    Optional<Person> optionalPerson = selection.getFirstSelectedItem();
    if (optionalPerson.isPresent()) {
        // System.out.printf("Selected person: %s%n",
        // optionalPerson.get().getFullName());
    }
});
```

### Multi-Select Mode

In multi-select mode, the user can use a checkbox column to select and deselect more than one row — not necessarily contiguous rows. Or the user can select all rows by clicking on the checkbox in the header row — and then un-check the ones they don’t want to be selected, rather than check many, individually.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.setSelectionMode(Grid.SelectionMode.MULTI);
grid.addColumn(Person::getFirstName).setHeader("First name");
grid.addColumn(Person::getLastName).setHeader("Last name");
grid.addColumn(Person::getEmail).setHeader("Email");

List<Person> people = DataService.getPeople();
grid.setItems(people);

grid.addSelectionListener(selection -> {
    // System.out.printf("Number of selected people: %s%n",
    // selection.getAllSelectedItems().size());
});
```

In addition to selecting rows individually, a range of rows can be selected by dragging from one selection checkbox to another, if enabled:

```java
Grid<Person> g = new Grid<>();
g.setSelectionMode(SelectionMode.MULTI);
GridMultiSelectionModel<Person> selectionModel = (GridMultiSelectionModel<Person>)g.getSelectionModel();
selectionModel.setDragSelect(true);
```

### Selection Modes in Flow

Each selection mode is represented by a  `GridSelectionModel`, accessible through the  `getSelectionModel()`  method, which can be cast that to the specific selection model type,  `SingleSelectionModel`  or  `MultiSelectionModel`. These interfaces provide selection mode specific APIs for configuration and selection events.

To use Grid with  `Binder`  in Flow, you can use  `asSingleSelect()`  or  `asMultiSelect()`, depending on the currently defined selection mode. Both methods return interfaces that implement the  `HasValue`  interface for use with  `Binder`.

## Sorting

Any column can be used for sorting the data displayed. Enable sorting to allow the user to sort items alphabetically, numerically, by date, or by some other method.

The arrowhead symbols in the column header indicate the current sorting direction. When toggled, the direction will cycle between ascending, descending and none.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getId).setHeader("Id").setSortable(true);
grid.addColumn(Person::getFullName).setHeader("Name").setSortable(true);
grid.addColumn(Person::getEmail).setHeader("Email").setSortable(true);
grid.addColumn(Person::getProfession).setHeader("Profession")
        .setSortable(true);
grid.addColumn(new LocalDateRenderer<>(GridSorting::getPersonBirthday,
        "yyyy-MM-dd")).setHeader("Birthday").setSortable(true)
        .setComparator(Person::getBirthday);
```

### Sorting by Multiple Columns

Multi-sort mode allows the Grid to be sorted by multiple columns simultaneously.

In normal multi-sort mode, additional sorting columns are applied simply by clicking their headers.

A separate  multi-sort on shift-click mode  combines single and multi-column sorting by adding more sorting columns only when the user holds the  Shift  key while clicking their headers.

The order in which multi-sort columns (known as sorting criteria) are evaluated is determined by the multi-sort priority setting.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getId).setHeader("Id").setSortable(true);
grid.addColumn(Person::getFullName).setHeader("Name").setSortable(true);
grid.addColumn(Person::getEmail).setHeader("Email").setSortable(true);
grid.addColumn(Person::getProfession).setHeader("Profession")
        .setSortable(true);
grid.addColumn(new LocalDateRenderer<>(GridMultiSort::getPersonBirthday,
        "yyyy-MM-dd")).setHeader("Birthday").setSortable(true)
        .setComparator(Person::getBirthday);
grid.setMultiSort(true, MultiSortPriority.APPEND);
```

Shift-Click Multi-Sorting Accessibility Issues

The multi-sort on shift-click mode is not recommended for applications for which accessibility is important. This feature is unlikely to work well with assistive technologies, and the lack of visual affordance makes it difficult to discover for sighted users.

### Specifying Sort Property

Columns with rich or custom content can be sorted by defining the property by which to sort. For example, in the table here there’s a column containing the employees' first and last names, avatar images, and email addresses. By clicking on the heading for that column, it’ll sort the data by their last names.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(createEmployeeRenderer()).setHeader("Employee")
        .setAutoWidth(true).setFlexGrow(0)
        .setComparator(Person::getLastName);
grid.addColumn(createBirthdayRenderer()).setHeader("Birthdate")
        .setComparator(Person::getBirthday);
```

Sorting helps users find and examine data. Therefore, it’s recommended to enable sorting for all applicable columns. An exception, though, would be when the order is an essential part of the data itself, such as with prioritized lists.

## Filtering

Filtering allows the user to find a specific item or subset of items. You can add filters to Grid columns or use external filter fields.

For instance, try typing  `anna`  in the input box for  _Name_  below. When you’re finished, the data shown is only people who have  _anna_  in their name. That includes some with the names Anna and Annabelle, as well as some with Arianna and Brianna.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
Grid.Column<Person> nameColumn = grid.addColumn(createPersonRenderer())
        .setWidth("230px").setFlexGrow(0);
Grid.Column<Person> emailColumn = grid.addColumn(Person::getEmail);
Grid.Column<Person> professionColumn = grid
        .addColumn(Person::getProfession);

List<Person> people = DataService.getPeople();
GridListDataView<Person> dataView = grid.setItems(people);
PersonFilter personFilter = new PersonFilter(dataView);

grid.getHeaderRows().clear();
HeaderRow headerRow = grid.appendHeaderRow();

headerRow.getCell(nameColumn).setComponent(
        createFilterHeader("Name", personFilter::setFullName));
headerRow.getCell(emailColumn).setComponent(
        createFilterHeader("Email", personFilter::setEmail));
headerRow.getCell(professionColumn).setComponent(
        createFilterHeader("Profession", personFilter::setProfession));

...

private static Component createFilterHeader(String labelText,
        Consumer<String> filterChangeConsumer) {
    NativeLabel label = new NativeLabel(labelText);
    label.getStyle().set("padding-top", "var(--lumo-space-m)")
            .set("font-size", "var(--lumo-font-size-xs)");
    TextField textField = new TextField();
    textField.setValueChangeMode(ValueChangeMode.EAGER);
    textField.setClearButtonVisible(true);
    textField.addThemeVariants(TextFieldVariant.LUMO_SMALL);
    textField.setWidthFull();
    textField.getStyle().set("max-width", "100%");
    textField.addValueChangeListener(
            e -> filterChangeConsumer.accept(e.getValue()));
    VerticalLayout layout = new VerticalLayout(label, textField);
    layout.getThemeList().clear();
    layout.getThemeList().add("spacing-xs");

    return layout;
}

private static class PersonFilter {
    private final GridListDataView<Person> dataView;

    private String fullName;
    private String email;
    private String profession;

    public PersonFilter(GridListDataView<Person> dataView) {
        this.dataView = dataView;
        this.dataView.addFilter(this::test);
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
        this.dataView.refreshAll();
    }

    public void setEmail(String email) {
        this.email = email;
        this.dataView.refreshAll();
    }

    public void setProfession(String profession) {
        this.profession = profession;
        this.dataView.refreshAll();
    }

    public boolean test(Person person) {
        boolean matchesFullName = matches(person.getFullName(), fullName);
        boolean matchesEmail = matches(person.getEmail(), email);
        boolean matchesProfession = matches(person.getProfession(),
                profession);

        return matchesFullName && matchesEmail && matchesProfession;
    }

    private boolean matches(String value, String searchTerm) {
        return searchTerm == null || searchTerm.isEmpty()
                || value.toLowerCase().contains(searchTerm.toLowerCase());
    }
}
```

Place filters outside the grid when the filter is based on multiple columns, or when a bigger field or more complex filter UI is needed, one which wouldn’t fit well in a column. In the example here, whatever you type in the search box can be matched against all of the columns. Type  `Rheumatologist`  in the search box. The results show only the rows with that profession.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(createPersonRenderer()).setHeader("Name").setFlexGrow(0)
        .setWidth("230px");
grid.addColumn(Person::getEmail).setHeader("Email");
grid.addColumn(Person::getProfession).setHeader("Profession");

List<Person> people = DataService.getPeople();
GridListDataView<Person> dataView = grid.setItems(people);

TextField searchField = new TextField();
searchField.setWidth("50%");
searchField.setPlaceholder("Search");
searchField.setPrefixComponent(new Icon(VaadinIcon.SEARCH));
searchField.setValueChangeMode(ValueChangeMode.EAGER);
searchField.addValueChangeListener(e -> dataView.refreshAll());

dataView.addFilter(person -> {
    String searchTerm = searchField.getValue().trim();

    if (searchTerm.isEmpty())
        return true;

    boolean matchesFullName = matchesTerm(person.getFullName(),
            searchTerm);
    boolean matchesEmail = matchesTerm(person.getEmail(), searchTerm);
    boolean matchesProfession = matchesTerm(person.getProfession(),
            searchTerm);

    return matchesFullName || matchesEmail || matchesProfession;
});
```

## Lazy Loading

When you want to display a list of items that would be quite large to load entirely into memory, or you want to load items from a database, data providers can be used to provide lazy loading through pagination.

The following example works like the earlier example, but it uses a data provider for lazy loading, sorting, and filtering items.


```java
private PersonFilter personFilter = new PersonFilter();

private PersonDataProvider dataProvider = new PersonDataProvider();

private ConfigurableFilterDataProvider<Person, Void, PersonFilter> filterDataProvider = dataProvider
        .withConfigurableFilter();

public GridDataProvider() {
    Grid<Person> grid = new Grid<>();
    grid.addColumn(Person::getFullName, "name").setHeader("Name");
    grid.addColumn(Person::getProfession, "profession")
            .setHeader("Profession");
    grid.setItems(filterDataProvider);

    TextField searchField = new TextField();
    searchField.setWidth("50%");
    searchField.setPlaceholder("Search");
    searchField.setPrefixComponent(new Icon(VaadinIcon.SEARCH));
    searchField.setValueChangeMode(ValueChangeMode.EAGER);
    searchField.addValueChangeListener(e -> {
        personFilter.setSearchTerm(e.getValue());
        filterDataProvider.setFilter(personFilter);
    });

    VerticalLayout layout = new VerticalLayout(searchField, grid);
    layout.setPadding(false);
    add(layout);
}
```

To learn more about data providers in Flow, see the  [Binding Items to Components](https://vaadin.com/docs/latest/flow/binding-data/data-provider)  documentation page.

### Lazy Column Rendering

Grids containing a large number of columns can sometimes exhibit performance issues. If many of the columns are typically outside the visible viewport, rendering performance can be optimized by using "lazy column rendering" mode.

This mode enables virtual scrolling horizontally. It renders body cells only when their corresponding columns are inside the visible viewport.

Lazy rendering should be used only with a large number of columns and performance is a high priority. For most use cases, though, the default "eager" mode is recommended.

When considering whether to use the "lazy" mode, keep the following factors in mind:

Row Height

When only a number of columns are visible at once, the height of a row can only be that of the highest cell currently visible on that row. Make sure each cell on a single row has the same height as all of the other cells on the row. Otherwise, users may notice jumpiness when horizontally scrolling the grid as lazily rendered cells with different heights are scrolled into view.

Auto-Width Columns

For columns that are initially outside the visible viewport, but still use auto-width, only the header content is taken into account when calculating the column width. This is because the body cells of the columns outside the viewport are not rendered initially.

Screen Reader Compatibility

Screen readers may not be able to associate the focused cells with the correct headers when only a subset of the body cells on a row is rendered.

Keyboard Navigation

Tabbing through focusable elements inside the grid body may not work as expected. This is because some of the columns that would include focusable elements in the body cells may be outside the visible viewport and thus not rendered.

No Improvement If All Columns Visible

The lazy column rendering mode can only improve the rendering performance when a significant portion of the columns are outside of the Grid’s visible viewport. It has no effect on Grids in which all columns are visible without horizontal scrolling.

```java
grid.setColumnRendering(ColumnRendering.LAZY);
```

## Item Details

Item details are expandable content areas that can be displayed below the regular content of a row. They can be used to display more information about an item. By default, an item’s details are toggled by clicking on the item’s row. Try clicking on one of the rows in the example here. Notice that when you do, the row is expanded to show the person’s email address, telephone number, and home address. If you click on the row again, it’s collapsed back to a single line.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getFullName).setHeader("Name");
grid.addColumn(Person::getProfession).setHeader("Profession");

grid.setItemDetailsRenderer(createPersonDetailsRenderer());

...

private static ComponentRenderer<PersonDetailsFormLayout, Person> createPersonDetailsRenderer() {
    return new ComponentRenderer<>(PersonDetailsFormLayout::new,
            PersonDetailsFormLayout::setPerson);
}

private static class PersonDetailsFormLayout extends FormLayout {
    private final TextField emailField = new TextField("Email address");
    private final TextField phoneField = new TextField("Phone number");
    private final TextField streetField = new TextField("Street address");
    private final TextField zipField = new TextField("ZIP code");
    private final TextField cityField = new TextField("City");
    private final TextField stateField = new TextField("State");

    public PersonDetailsFormLayout() {
        Stream.of(emailField, phoneField, streetField, zipField, cityField,
                stateField).forEach(field -> {
                    field.setReadOnly(true);
                    add(field);
                });

        setResponsiveSteps(new ResponsiveStep("0", 3));
        setColspan(emailField, 3);
        setColspan(phoneField, 3);
        setColspan(streetField, 3);
    }

    public void setPerson(Person person) {
        emailField.setValue(person.getEmail());
        phoneField.setValue(person.getAddress().getPhone());
        streetField.setValue(person.getAddress().getStreet());
        zipField.setValue(person.getAddress().getZip());
        cityField.setValue(person.getAddress().getCity());
        stateField.setValue(person.getAddress().getState());
    }
}
```

The default toggle behavior can be replaced by programmatically toggling the details visibility, such as from a button click.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getFullName).setHeader("Name");
grid.addColumn(Person::getProfession).setHeader("Profession");
grid.addColumn(createToggleDetailsRenderer(grid));

grid.setDetailsVisibleOnClick(false);
grid.setItemDetailsRenderer(createPersonDetailsRenderer());

...

private static Renderer<Person> createToggleDetailsRenderer(
        Grid<Person> grid) {
    return LitRenderer.<Person> of(
            "<vaadin-button theme=\"tertiary\" @click=\"${handleClick}\">Toggle details</vaadin-button>")
            .withFunction("handleClick",
                    person -> grid.setDetailsVisible(person,
                            !grid.isDetailsVisible(person)));
}
```

[Tooltips](https://vaadin.com/docs/latest/components/grid#tooltips)  can be used as a lightweight alternative to the item details panel.

## Empty State

When there’s no data available for the grid to display any rows, the space between the header and footer is left blank by default. You can use the empty state feature to provide a message or other content in this area to inform the user that there are no items to show.

```java
grid.setEmptyStateText("No employees found.");
```

## Context Menu

You can use Context Menu to provide shortcuts for the user. It appears on a right-click by default. In a mobile browser, a long press opens the menu. In the example here, try right-clicking on one of the rows. You’ll notice a box appears with a list of choices: Edit the row, delete it, email the person, or call them. If this example were fully configured, the latter two would open the related application (i.e., the default email program or a telephone application).

Using a context menu shouldn’t be the only way of accomplishing a task, though. The same functionality needs to be accessible elsewhere in the UI. See the documentation page on  [Context Menu](https://vaadin.com/docs/latest/components/context-menu)  for more information.

```java
Grid<Person> grid = new Grid<>(Person.class, false);
grid.addColumn(Person::getFirstName).setHeader("First name");
grid.addColumn(Person::getLastName).setHeader("Last name");
grid.addColumn(Person::getEmail).setHeader("Email");
grid.addColumn(Person::getProfession).setHeader("Profession");

PersonContextMenu contextMenu = new PersonContextMenu(grid);

add(grid);

...

private static class PersonContextMenu extends GridContextMenu<Person> {
    public PersonContextMenu(Grid<Person> target) {
        super(target);

        addItem("Edit", e -> e.getItem().ifPresent(person -> {
            // System.out.printf("Edit: %s%n", person.getFullName());
        }));
        addItem("Delete", e -> e.getItem().ifPresent(person -> {
            // System.out.printf("Delete: %s%n", person.getFullName());
        }));

        add(new Hr());

        GridMenuItem<Person> emailItem = addItem("Email",
                e -> e.getItem().ifPresent(person -> {
                    // System.out.printf("Email: %s%n",
                    // person.getFullName());
                }));
        GridMenuItem<Person> phoneItem = addItem("Call",
                e -> e.getItem().ifPresent(person -> {
                    // System.out.printf("Phone: %s%n",
                    // person.getFullName());
                }));

        setDynamicContentHandler(person -> {
            // Do not show context menu when header is clicked
            if (person == null)
                return false;
            emailItem
                    .setText(String.format("Email: %s", person.getEmail()));
            phoneItem.setText(String.format("Call: %s",
                    person.getAddress().getPhone()));
            return true;
        });
    }
}
```

## Tooltips

Tooltips on cells can be useful in many situations: They can be used to give more details on the contents of a cell — if an  [item details panel](https://vaadin.com/docs/latest/components/grid#item-details)  would be overkill or otherwise undesirable. They can show the full text of a cell if it’s too long to fit feasibly into the cell itself — if  [wrapping the cell contents](https://vaadin.com/docs/latest/components/grid/styling#wrap-cell-content)  is insufficient or otherwise undesirable. Or they can give textual explanations for non-text content, such as status icons.

In the example here, hold your mouse pointer over the birthday date for one of the rows. A tooltip should appear indicating the age of the person. Now hover over one of the status icons, an X or a checkmark. It’ll use Tooltips to interpret the meaning of the icons.


```java
grid.addColumn(person -> getFormattedPersonBirthday(person))
        .setTooltipGenerator(person -> "Age: " + getPersonAge(person))
        .setHeader("Birthday");
grid.addComponentColumn(person -> createStatusIcon(person.getStatus()))
        .setTooltipGenerator(person -> person.getStatus())
        .setHeader("Status");
```

See the  [Tooltips](https://vaadin.com/docs/latest/components/tooltip)  documentation page for details on tooltip configuration.

## Cell Focus

Many of the explanations and examples above alluded to giving the focus to rows and cells. Cells can be focused by clicking on a cell, or with the keyboard. The following keyboard shortcuts are available with Grid:

Keys

Action

Tab

Switches focus between sections of the grid (i.e., header, body, footer).

Left,  Up,  Right, and  Down  Arrow Keys

Moves focus between cells within a section of the grid.

Page Up

Moves cell focus up by one page of visible rows.

Page Down

Moves cell focus down by one page of visible rows.

Home

Moves focus to the first cell in a row.

End

Moves focus to the last cell in a row.

The cell focus event can be used to be notified when the user changes focus between cells. By default, the focus outline is only visible when using keyboard navigation. For illustrative purposes, the example below also uses custom styles to show the focus outline when clicking on cells. Try clicking on a cell. Notice how the cell is highlighted and notice the information shown at the bottom, the information provided about the event.

```java
grid.addCellFocusListener(event -> {
    CellFocusEvent.GridSection section = event.getSection();
    String column = event.getColumn().map(Grid.Column::getKey)
            .orElse("Not available");
    String row = event.getItem()
            .map(value -> String.valueOf(people.indexOf(value)))
            .orElse("Not available");
    String fullName = event.getItem().map(Person::getFullName)
            .orElse("Not available");

    String eventSummary = String.format(
            "Section: %s%nRow: %s%nColumn: %s%nPerson: %s", section,
            row, column, fullName);

    textArea.setValue(eventSummary);
});
```

# Horizontal Layout

Horizontal Layout places components side-by-side in a row. By default, it defines its width and height automatically, determined by the components it contains (i.e., it “hugs” the content).

See  [Vertical Layout](https://vaadin.com/docs/latest/components/vertical-layout)  for placing components top-to-bottom.

```java
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));
```

Components in a Horizontal Layout can be aligned horizontally, as you’d expect, but also vertically.

## Vertical Alignment

You can position components at the top, middle, or bottom. You can also stretch items or position them along the text baseline in the layout.

```java
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.setAlignItems(FlexComponent.Alignment.CENTER);
layout.add(new TextArea("Text area 1"));
layout.add(new TextArea("Text area 2"));
layout.add(new TextArea("Text area 3"));
```

Value

Description

`STRETCH`  (default)

Vertically stretches items that have undefined height.

`START`

Positions items at the top of the layout.

`CENTER`

Centers items, vertically.

`END`

Positions items at the bottom of the layout.

`BASELINE`

Positions items along the layout’s text baseline.

It’s also possible to set a different vertical alignment for individual items by overriding the general alignment setting of the layout.

```java
TextArea textArea1 = new TextArea("Text area 1");
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(textArea1);
layout.setAlignSelf(FlexComponent.Alignment.START, textArea1);
layout.add(new TextArea("Text area 2"));
TextArea textArea3 = new TextArea("Text area 3");
layout.add(textArea3);
layout.setAlignSelf(FlexComponent.Alignment.END, textArea3);
```

## Horizontal Alignment

Components in a Horizontal Layout can be left-aligned, centered or right-aligned. You can also position components by specifying how the excess space in a layout is distributed among them.

```java
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.setJustifyContentMode(FlexComponent.JustifyContentMode.CENTER);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));
```

Value

Description

`START`  (default)

Left-aligns for left-to-right language items. For right-to-left languages, right-aligns items.

`CENTER`

Centers items, horizontally.

`END`

Right-aligns for left-to-right language items. For right-to-left languages, left-aligns items.

`BETWEEN`

Available space is distributed evenly between items. No space is added before the first item, or after the last.

`AROUND`

Available space is distributed evenly around items. The space before the first item and after the last, is half of that between items.

`EVENLY`

Available space is distributed evenly between items. The space before the first item, between items, and after the last item is the same.

## Spacing

Spacing is used to create space among components in the same layout. Spacing can help prevent misclicks and distinguish content areas.

```java
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Spacing");
radioButtonGroup.setItems(ENABLED_OPTION, DISABLED_OPTION);
radioButtonGroup.setValue(ENABLED_OPTION);
radioButtonGroup.addValueChangeListener(
        e -> layout.setSpacing(ENABLED_OPTION.equals(e.getValue())));
```

Five different spacing theme variants are available:

```java
HorizontalLayout layout = new HorizontalLayout();
layout.setSpacing(false);
layout.getThemeList().add(SPACING_XL_THEME);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Spacing variant");
radioButtonGroup.setItems(SPACING_XS_THEME, SPACING_S_THEME,
        SPACING_THEME, SPACING_L_THEME, SPACING_XL_THEME);
radioButtonGroup.setValue(SPACING_XL_THEME);
radioButtonGroup.addValueChangeListener(e -> {
    layout.getThemeList().remove(e.getOldValue());
    layout.getThemeList().add(e.getValue());
});
```

Theme Variant

Usage Recommendation

`spacing-xs`

Extra-small space between items.

`spacing-s`

Small space between items.

`spacing`

Medium space between items.

`spacing-l`

Large space between items.

`spacing-xl`

Extra-large space between items.


```typescript
<vaadin-horizontal-layout
  theme="spacing-xs padding">
</vaadin-horizontal-layout>
```

## Padding

Padding is the space between the outer border and the content in a layout. Padding can help distinguish the content in a layout from its surrounding. Padding is applied using the padding theme variant.


```java
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Padding");
radioButtonGroup.setItems(ENABLED_OPTION, DISABLED_OPTION);
radioButtonGroup.setValue(ENABLED_OPTION);
radioButtonGroup.addValueChangeListener(
        e -> layout.setPadding(ENABLED_OPTION.equals(e.getValue())));
```

## Margin

```java
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.setWidth("auto");
layout.setMargin(true);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Margin");
radioButtonGroup.setItems(ENABLED_OPTION, DISABLED_OPTION);
radioButtonGroup.setValue(ENABLED_OPTION);
radioButtonGroup.addValueChangeListener(
        e -> layout.setMargin(ENABLED_OPTION.equals(e.getValue())));
```

## Expanding Items

Components can be made to expand and take up any excess space a layout may have.

```java
Button button1 = new Button("Button 1");
HorizontalLayout layout = new HorizontalLayout();
layout.setPadding(true);
layout.add(button1);
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Item sizing");
radioButtonGroup.setItems(DEFAULT_SIZE_OPTION, EXPANDED_SIZE_OPTION);
radioButtonGroup.setValue(DEFAULT_SIZE_OPTION);
radioButtonGroup.addValueChangeListener(e -> layout.setFlexGrow(
        DEFAULT_SIZE_OPTION.equals(e.getValue()) ? 0 : 1, button1));
```

When multiple components expand, they do so relative to each other. For example, having two items with expand ratios of 2 and 1 results in the first item taking up twice as much of the available space as the second item.

# Icons

The icon component can render SVG and font icons. Two icon collections are available out-of-the-box.


```java
Icon lumoIcon = LumoIcon.PHOTO.create();
Icon vaadinIcon = VaadinIcon.PHONE.create();

layout.add(lumoIcon, vaadinIcon);
```

## Default Icon Collections

Two icon collections are available through Vaadin dependencies: Vaadin Icons and Lumo Icons. The Flow API provides enumations for these collections that makes them easy to use.

Explicitly Import Icon Collections

To use icons in client-side code (React / HTML), remember to import the necessary iconset explicitly. For Vaadin icons, use  `import '@vaadin/icons';`  etc. Failing to do so may result in icons being visible only in development mode but not in production.

### Vaadin Icons

Vaadin Icons is a collection of over six-hundred icons.

```java
Icon phoneIcon = VaadinIcon.PHONE.create();
Icon calendarIcon = VaadinIcon.CALENDAR.create();
Icon alarmIcon = VaadinIcon.ALARM.create();
Button button = new Button(VaadinIcon.BELL.create());

layout.add(phoneIcon, calendarIcon, alarmIcon, button);
```

The  [Default Icons](https://vaadin.com/docs/latest/components/icons/default-icons)  tab contains a list of the full Vaadin Icons collection.

#### Lumo Icons

Lumo Icons are used in the default Lumo theme for Vaadin components.

```java
Icon phoneIcon = LumoIcon.PHOTO.create();
Icon calendarIcon = LumoIcon.CALENDAR.create();
Icon alarmIcon = LumoIcon.CLOCK.create();
Button button = new Button(LumoIcon.BELL.create());

layout.add(phoneIcon, calendarIcon, alarmIcon, button);
```

Lumo Icons are rendered on a 24×24 pixel canvas, with a 16×16 pixel active area for the icon itself and 4 pixels of whitespace around the icon.

The  [Default Icons](https://vaadin.com/docs/latest/components/icons/default-icons)  contains a list of the full Lumo Icons collection.

## Using Third-Party Icons

Third-party icons can be rendered with the icon component. Three common formats are supported: standalone SVG files; SVG sprites; and icon fonts.

### Standalone SVG Images

Standalone SVG images can be rendered as inline SVG icons using the icon component.

```java
StreamResource iconResource = new StreamResource("code-branch.svg",
        () -> getClass().getResourceAsStream("/icons/code-branch.svg"));
SvgIcon icon = new SvgIcon(iconResource);
```

Thanks to inline SVG rendering, an icon can be styled with CSS. For example, you could change its fill color or stroke.

The advantage of standalone SVG images is that only the icons actually needed in the UI are loaded into the browser.

### SVG Sprites

SVG sprites are SVG files containing multiple images wrapped in  `<symbol>`  tags. An  `id`  attribute on the symbol tag is used to identify the images.

Using an image from an SVG sprite is similar to using a standalone SVG image — append the symbol  `id`  to the file path, prefixed by  `#`:

```java
StreamResource iconResource = new StreamResource("solid.svg",
        () -> getClass().getResourceAsStream("/icons/solid.svg"));

SvgIcon codeBranchIcon = new SvgIcon(iconResource, "code-branch");
SvgIcon userIcon = new SvgIcon(iconResource, "user");
```

Like standalone SVG images, sprite icons are also rendered as inline SVG for styling support.

The advantage of using an SVG sprite is that only one file needs to be loaded into the browser. Custom SVG sprites that contain only the icons needed in the application, can provide performance benefits compared to standalone SVG images.

Many  [third-party tools for creating SVG sprites](https://www.google.com/search?q=svg+sprite+generator)  are available.

### Icon Fonts

Icon fonts are loaded into the UI through a combination of a few factors:

-   First, a font file — usually placed in the theme folder;

-   Second, a  [`@font-face`  declaration](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face) — usually in a stylesheet provided with the font and imported into your theme’s master stylesheet,  `styles.css`; and

-   Optionally, a stylesheet with CSS classes representing the font and the icons in it — usually also imported into  `styles.css`, which may be included in same stylesheet as the  `@font-face`  declaration.


The desired icon can be specified in three different ways, depending on the font and stylesheets provided:

-   Icon-specific CSS class (e.g.,  `fa-calendar`), which requires a stylesheet defining CSS classes for each icon, usually bundled with the icon font;

-   Ligature (e.g.,  `calendar`), which requires an icon font that supports ligatures; and

-   Character code (e.g.,  `f199`), corresponding to the code point of the icon’s glyph in the font.


```java
FontIcon codeBranchIcon = new FontIcon("fa", "fa-code-branch");
FontIcon userIcon = new FontIcon("fa", "fa-user");

layout.add(codeBranchIcon, userIcon);
```

Theme folder with files for FontAwesome icon font

```
themes/
  └── my-theme/
      ├── styles.css
      └── fontawesome/
          ├── fontawesome.css (classes for individual icons in the font)
          ├── solid.css (stylesheet with @font-face declaration)
          └── fa-solid-900.woff2 (icon font)
...
```

```css
@import url('fontawesome/solid.css');
@import url('fontawesome/fontawesome.css');
```

```css
@font-face {
  font-family: 'Font Awesome 6 Free';
  font-style: normal;
  font-weight: 900;
  font-display: block;
  src: url("fa-solid-900.woff2") format("woff2"), url("fa-solid-900.ttf") format("truetype");
}
```

The  `@font-face`  declaration defining the icon font family must be placed in a global stylesheet, not in a Shadow DOM stylesheet.

Icon Font Stylesheets Inside a Shadow Root

To use CSS classes for icon fonts inside a Shadow DOM, such as that of a Lit template, they must be loaded separately into it. The easiest way to do this is to load them as part of the application’s theme, and  [apply the theme inside the Shadow DOM](https://vaadin.com/docs/latest/flow/create-ui/templates/styling-templates)  with  `applyTheme()`.

The font can also be defined using its  `font-family`  name — as defined in the  `@font-face`  declaration.

```html
<vaadin-icon font-family="Material Icons" ligature="home"></vaadin-icon>
```

Note that the rendering quality of icon fonts is inferior to SVGs, especially in smaller sizes.

## Icon Configuration

You may configure a few properties or styles for the icons.

### Color & Other Styles

The icon’s fill color can be set to any CSS color value.

```java
StreamResource codeBranch = new StreamResource("svg-branch.svg",
        () -> getClass().getResourceAsStream("/icons/code-branch.svg"));
SvgIcon svgIcon = new SvgIcon(codeBranch);
svgIcon.setColor("red");

FontIcon fontIcon = new FontIcon("fa", "fa-user");
fontIcon.setColor("red");

layout.add(svgIcon, fontIcon);
```

### Size & Padding

The icon component has a property for setting the desired outer size of the icon in pixels. This automatically sets the icon’s width and height to the same value, as icons are rendered in a square (i.e., 1:1) aspect ratio, by default.

```java
SvgIcon iconDefaultSize = new SvgIcon(codeBranch);

SvgIcon iconLumoSize = new SvgIcon(codeBranch);
iconLumoSize.setSize("var(--lumo-icon-size-l)");

SvgIcon iconPxSize = new SvgIcon(codeBranch);
iconPxSize.setSize("48px");

layout.add(iconDefaultSize, iconLumoSize, iconPxSize);
```

The internal padding of the icon can be adjusted to compensate for the lack of surrounding whitespace in the icon itself.

```java
SvgIcon iconDefaultSize = new SvgIcon(codeBranch);

SvgIcon iconSmallPadding = new SvgIcon(codeBranch);
iconSmallPadding.getStyle().set("padding", "0.25em");

SvgIcon iconLargePadding = new SvgIcon(codeBranch);
iconLargePadding.getStyle().set("padding", "0.5em");

layout.add(iconDefaultSize, iconSmallPadding, iconLargePadding);
```

## Custom Icon Collection APIs

Within the application context, various icon libraries — including FontAwesome, Material Symbol, and others — may be utilized. Implementing custom icon libraries, as exemplified by the  `VaadinIcon`  enumeration, simplifies developer workflows by eliminating the need to recall specific URL paths, or to remember which CSS classes to apply when working with font icons:

```java
public enum FontAwesomeIcons {
    CODE_BRANCH("fa-code-branch"), USER("fa-user");

    private String iconClass;

    FontAwesomeIcons(String iconClass) {
        this.iconClass = iconClass;
    }

    public FontIcon create() {
        return new FontIcon("fa", iconClass);
    }
}

...

FontIcon codeBranch = FontAwesomeIcons.CODE_BRANCH.create();
add(codeBranch);
```

## Accessibility

Screen readers are not able to announce icons correctly, by default. In fact, the icon component is built in a way that is completely ignored by assistive technologies.

However, in most cases, there shouldn’t be a need to make icons themselves screen reader friendly. Instead, the component (e.g., Button) in which the icon is used, should provide a screen reader friendly accessible name.

```java
Button closeButton = new Button(VaadinIcon.CLOSE.create());
closeButton.setAriaLabel("Close dialog");
```

In situations where icons are used to convey information on their own (e.g., in a table column to convey a value in a graphical manner), they need to be given an accessible name and an ARIA image role attribute in order to be announced correctly by screen readers.

```html
<vaadin-icon icon="vaadin:star" role="img" aria-label="Favorite"></vaadin-icon>
```
# List Box
List Box allows the user to select one or more values from a scrollable list of items.

```java
MultiSelectListBox<String> listBox = new MultiSelectListBox<>();
listBox.setItems(SHOW_ASSIGNEE, SHOW_DUE_DATE, SHOW_STATUS);
listBox.select(SHOW_ASSIGNEE, SHOW_STATUS);
```

Although functionally similar to  [Checkbox Group](https://vaadin.com/docs/latest/components/checkbox)  and  [Radio Button Group](https://vaadin.com/docs/latest/components/radio-button), List Box is designed to be used as a lightweight scrollable selection list, rather than as a form input field.

## Dividers

You can use dividers to group related items. Use them sparingly to avoid creating unnecessary visual clutter.

```java
listBox.setItems(SHOW_ASSIGNEE, SHOW_DUE_DATE, SHOW_STATUS,
        SHOW_THUMBNAIL, SHOW_PREVIEW);
listBox.addComponents(SHOW_STATUS, new Hr());
```

## Disabled Items

Disable items to show that they are currently unavailable for selection.

```java
ListBox<Status> listBox = new ListBox<>();
listBox.setItems(inProgress, done, cancelled);
listBox.setItemEnabledProvider(status -> status.getCount() > 0);
```

Accessibility

Some assistive technologies don’t announce disabled items.

## Selection

List Box supports both single and multiple selection. Single selection allows the user to select only one item, whereas multiple selection enables more than one item to be selected.

### Single

```java
ListBox<String> listBox = new ListBox<>();
listBox.setItems(IN_PROGRESS, DONE, CANCELLED);
listBox.setValue(IN_PROGRESS);
```

### Multi

```java
MultiSelectListBox<Person> listBox = new MultiSelectListBox<>();
listBox.setItems(items);
listBox.select(items.get(0), items.get(3));
```

## Custom Item Presentation

Items can be rendered with rich content instead of plain text. This can be useful to provide additional information in a more legible fashion than appending it to the item text.


![](data:image/jpeg;base64,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)Aria Bailey Endocrinologist

![](data:image/jpeg;base64,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)Aaliyah Butler Nephrologist

![](data:image/jpeg;base64,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)Eleanor Price Ophthalmologist

![](data:image/jpeg;base64,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)Allison Torres Allergist

![](data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAEyUExURUdwTJO40YvV+1RodDtOW2zI+EFTX2TI/VyszWTJ/ktea3bM+m3K/WvK/UNXZTlLWGnJ/XLF8WrK/EZfb2vJ/EFVYlloczdSYsnm9nXM+57U8Upldp2+0I2Xn46ZoDxPXGXJ/2TI/ztOW/T19fPz8+66imTK/+u4iWHJ/2XJ/vO+jdinfDhJVRgfJfnCkDJFUuOwg/79/CkoKR0ZFV3J//r39UI0JqFSIys9SvW4g2bP/1BLR+7s6zs4Nl1WT+W5kIJ5c21pZMK/scadeINqVOHh4mOmyonE3srn96phNJh7YKemo6KAYsDj9ti7nszNzrh3S9GSbX+MlUxEOmd1f2nO/2i65pqHda6Qc8iLXf9RcPPPrleFn3FeTFJzhqrAwsKuloc6P+yfgcdHWLBCT/Ph0Yd5RuYAAAAfdFJOUwAKLjb7/f3/Avv+G5m4pf/ZYMeFdNv+If5A/l/Ou7qP39rVAAAGKElEQVRYw5WXi1/aSBDHUSEhVIn12drekQRC2CSEEMELIFgR0Wo/Inqovfpu+///Czcz2UBAfHSUxy77++7M7uxmNxZ7xpLJ2Gw5t72/v50rz2LpDw0E63+fraUEIbV29tc6VfyZfC4t2CVbljUZPoT03B8hkrGZdEbT4hlucU3LpGfeTkjG5lYDuZbhb4BYnXsrAfQCyLVMxDRACG8kcP0TezMhObMa6HH4yGxZCwirM29yIJ2JZ2TQwQT+SwaTiRioTr/uAgYgl+y1s+Me5lC1XK5mIZt6x2drckl+QxDgQCl11tsug7KazZFlq8Apb/fOUqXXXICMXU8d75fLXBq1bLm8f5xaf5GA+f95P1Rn0egdCwFj//NL6wJ+WNnIVYfqHJdnOYqqN1aeTWqonhc/hPqhmn/PkSO56gdx/hkCLIAFJhEgG9roG48EABJbmLosQL+kSoXDatA1j3o0hEFlrnpYkNSlKQSoWFAlVviAAC4e75sg4EGBSerC0yiSsXkmMRZ4EIhz20Pj3SPgsMCg4fwkIBl7zySRiQjIYf7lfv/48cPZcQ3D2DHh6+/tarkahADNJPZ+nADzL6mSKpIHmDCXR9/AOh3TccxOB78fXWKCkQciNJVmJ3xYIL1SOCxne8fNIjevA+bxwmbzqpctHxYUIixEARQAExWmVDZ6AugarV20lue18BUUGkASehsVaCay8SCSyUVgqorKxPzxzY3X/BLYbrHjOJ3iLi82vZubYxgCaAjNF5NPHFAYUxM7jus1W60GGPR5ZZrfPF5qNT3X2UmojCmTLiSXyAEgFBI7unHunTebTc+Dl6XrFnxS6dxrwJQkCqAnF5ZGDnxkqggOBADDOSp6YJubm8Ub0zDMVjEoecUjJwQooqiyj9wFyiFyIPBANxrFTbKmhQCrGZSKDUPXQwBMZJhNsAhgCMkBBccAJUQonu85Opi5d07FBuJwDKipCMMYLAlIIohADQCs0q4BwT1qNVpHrmlZrmtZw6Jh1NoFxgEQwywHrDDuAMXQhuzVHd3VHdN098BcSEcs6vBDm0dALrAVDpgfAhgEUbkDH8AL0/r+/XvfsvrwYZkm1tXuKhAAGwLCJYWTyAGQZJUDBOju6T9oX7/Sx6mL/dcOKqLCQ1DCiYyOIRIYg4lwTwPh6d7Jyd5pAAIGTgEbhRCMYjL2LqGG+nAc9T7ov57227gZtPunWOrrtXZlKEeCmngXAKQoQGGVA90wDZgAp7NF1nFgKqBKP6hE9ACQpgHAxwJMpW7qzt4WN8gHUzfIAfY6gC8ImIejEAApDMNKSfg6AAkQBBDMztbDz1+/fj5sdWASdQpgegiJcQARjJphnj/8R/ZwbkKR9OMAPojRaQxcUIFwUtOv+o+Prvv42L/SayegV8cdoGkc7ofKJCFxZzimHphj3CUm9cpwX4ymciQKtXLv4qYO5rr3lMJj+lEq04amTrjARJa/t4Z2n8cJHHdg+HCgZ4I4BDDY85gowiPiBJcymXtSoCrYM9kIEExCuJrC5QiLRRTz9fqgUIFhpAh0GMJKoT6o54EB2+lwDJeGe+IKj4HkSn1w0b2+brchm4IxhBxqt8+uuxeDuhIioH++HYQxiKQXxXqieyvIvm/VjIjVag1fE267iTo0RAJsSKOnW5ImUkV9ftBN2TacK/0vlL74j4E4V76c0Ww71R3kkaCOPdz4vq4qYv3i1pbpYFvyLx0z7B/Wle3TadW2by/qoqJGd/XQBVEV69A9nazhr+TvWiZsiybsiO5lyadKRKS6dWg6/nSljRn1gkyne2ps+6XdyyvYVC93Zb/E9fAvC0gIt+TR+USR6heg1/jpHluWfN/Hl18irsZvD7JwUZeU8TMKrqh8AvznlwSNN5dtMDqrh3oaiFQivzjz5IgyuLZHlwwiREpRvZaxrwezUw5JghyP3FK0CYv8EpeF99POecuZeFybuKYE2vHbTzyeWZ5+0lyGH7XMK4ZNpuqxDgmZFxF4+QL9c4fl2CfhZQJd3j49fwfFCyM5MZWhUfcvXx9hj10WNBymaX7A7VNYfuUCi3fuNCGiDLq7ojz9+i08Gdy7cf4IQj2jWIsHN/BJ/f/ILK3WwmHBWAAAAABJRU5ErkJggg==)Madeline Lewis Gastroenterologist

```java
listBox.setRenderer(new ComponentRenderer<>(person -> {
    HorizontalLayout row = new HorizontalLayout();
    row.setAlignItems(FlexComponent.Alignment.CENTER);

    Avatar avatar = new Avatar();
    avatar.setName(person.getFullName());
    avatar.setImage(person.getPictureUrl());

    Span name = new Span(person.getFullName());
    Span profession = new Span(person.getProfession());
    profession.getStyle()
            .set("color", "var(--lumo-secondary-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");

    VerticalLayout column = new VerticalLayout(name, profession);
    column.setPadding(false);
    column.setSpacing(false);

    row.add(avatar, column);
    row.getStyle().set("line-height", "var(--lumo-line-height-m)");
    return row;
}));
```

## Best Practices

List Box isn’t designed to be used as an input field in forms, and lacks features such as label, helper, and validation errors. See related components later for better options for use in forms. List Box is best suited for use as a lightweight, scrollable, single-column list for single or multi-selection of items.

# Login
Login is a component that contains a log-in form. You can use it to authenticate the user with a username and password. It’s compatible with password managers, supports internationalization, and works on all device sizes.

```java
LoginForm loginForm = new LoginForm();
add(loginForm);
```

## Basic Login Component

The basic Login component consists of a title (i.e., "Log In"), two input fields ("Username" and "Password"), and two buttons ("Log In" and "Forgot Password").

You can customize the form’s title and labels using internationalization.

```java
LoginI18n i18n = LoginI18n.createDefault();

LoginI18n.Form i18nForm = i18n.getForm();
i18nForm.setTitle("Kirjaudu sisään");
i18nForm.setUsername("Käyttäjänimi");
i18nForm.setPassword("Salasana");
i18nForm.setSubmit("Kirjaudu sisään");
i18nForm.setForgotPassword("Unohtuiko salasana?");
i18n.setForm(i18nForm);

LoginI18n.ErrorMessage i18nErrorMessage = i18n.getErrorMessage();
i18nErrorMessage.setTitle("Väärä käyttäjätunnus tai salasana");
i18nErrorMessage.setMessage(
        "Tarkista että käyttäjätunnus ja salasana ovat oikein ja yritä uudestaan.");
i18n.setErrorMessage(i18nErrorMessage);

LoginForm loginForm = new LoginForm();
loginForm.setI18n(i18n);
```

The basic Login component can be used to create log-in pages featuring rich content.

```java
// See login-rich-content.css
addClassName("login-rich-content");

LoginForm loginForm = new LoginForm();
loginForm.getElement().getThemeList().add("dark");
```

Password Managers

Login is incompatible with password managers if placed inside another component’s shadow root.  [[1](https://vaadin.com/docs/latest/components/login#_footnotedef_1 "View footnote.")]  This isn’t an issue, though, when using Login’s modal overlay.

## Modal Overlay

Login features its own modal overlay. Use it to create simple log-in pages — which are full-screen on mobile devices — or to handle authentication without a dedicated log-in page. You can also use it to handle re-authentication when the user’s session has expired.

The overlay can be opened programmatically or through user interaction (e.g., by using a log-in button).

```java
LoginOverlay loginOverlay = new LoginOverlay();
add(loginOverlay);

Button login = new Button("Log in");
login.addClickListener(event -> loginOverlay.setOpened(true));
```

### Header

The overlay has a header and the log-in form. By default, the header contains placeholders for the application’s title and description. Both properties are configurable.

```java
LoginOverlay loginOverlay = new LoginOverlay();
loginOverlay.setTitle("TaskMob");
loginOverlay.setDescription("Built with ♥ by Vaadin");
```

### Custom Form Area

The overlay provides a custom form area for adding fields in addition to username and password. This area is placed above the "Submit" button. Use the  `name`  attribute to ensure the custom field’s  `value`  is submitted with the form.

```java
LoginOverlay loginOverlay = new LoginOverlay();
IntegerField code = new IntegerField("One-time code");
code.getElement().setAttribute("name", "code");
loginOverlay.getCustomFormArea().add(code);
```

### Footer

The footer area can be used for placing additional custom content, such as text, buttons, etc. Adding components after the overlay is opened is not supported.

```java
LoginOverlay loginOverlay = new LoginOverlay();
Paragraph text = new Paragraph("Never tell your password to anyone");
text.addClassName(LumoUtility.TextAlignment.CENTER);
loginOverlay.getFooter().add(text);
```

## Validation

Login shows an error message when authentication fails. The error message includes a title in addition to the message. It’s displayed directly below the title of the form.

```java
loginOverlay.setError(true);
```

The error message is customizable using internationalization. It should contain instructions on how to resolve the problem.

More information can be provided to the user, for example, by linking to a page with helpful material or by displaying contact information.

```java
LoginI18n i18n = LoginI18n.createDefault();
i18n.setAdditionalInformation(
        "Contact admin@company.com if you're experiencing issues logging into your account");

LoginOverlay loginOverlay = new LoginOverlay();
loginOverlay.setI18n(i18n);
```

## Internationalization (i18n)

Login’s titles, descriptions, labels, and messages are all customizable using internationalization.

```java
LoginI18n i18n = LoginI18n.createDefault();

LoginI18n.Header i18nHeader = new LoginI18n.Header();
i18nHeader.setTitle("Sovelluksen nimi");
i18nHeader.setDescription("Sovelluksen kuvaus");
i18n.setHeader(i18nHeader);

LoginI18n.Form i18nForm = i18n.getForm();
i18nForm.setTitle("Kirjaudu sisään");
i18nForm.setUsername("Käyttäjänimi");
i18nForm.setPassword("Salasana");
i18nForm.setSubmit("Kirjaudu sisään");
i18nForm.setForgotPassword("Unohtuiko salasana?");
i18n.setForm(i18nForm);

LoginI18n.ErrorMessage i18nErrorMessage = i18n.getErrorMessage();
i18nErrorMessage.setTitle("Väärä käyttäjätunnus tai salasana");
i18nErrorMessage.setMessage(
        "Tarkista että käyttäjätunnus ja salasana ovat oikein ja yritä uudestaan.");
i18n.setErrorMessage(i18nErrorMessage);

i18n.setAdditionalInformation("Jos tarvitset lisätietoja käyttäjälle.");

LoginOverlay loginOverlay = new LoginOverlay();
loginOverlay.setI18n(i18n);
```

### Header

The header is only shown for modal log-in forms.

Property

Default Value

Title

_"App name"_

Description

_"Application description"_

### Form

Customize the form’s title, input field and button labels.

Property

Default Value

Title

_"Log in"_

Username

_"Username"_

Password

_"Password"_

Submit

_"Log in"_

Forgot password

_"Forgot password"_

### Error Message

Login’s error message is shown when authentication fails. It includes a title in addition to the message.

Property

Default Value

Title

_"Incorrect username or password"_

Message

_"Check that you have entered the correct username and password and try again."_

### Additional Information

This property is hidden unless its value is explicitly set.

Property

Default Value

Additional information

-

## Technical

### Handling Events

#### Login Event

You can add a listener to log-in events or define an action for which a  `POST`  request is fired. From the event, you can prevent the  `POST`  request.

The log-in button is disabled when clicked, to prevent multiple submissions. To restore it, call  `component.setEnabled(true)`.

#### Forgotten Password

You can add an event listener, which gives you the opportunity to provide your users with instructions for password recovery.

#### Cross-Site Request Forgery (CSRF) Tokens

If the page contains the following meta tags with a CSRF token, the token is automatically included in a form  `POST`  request:

```html
<meta name="_csrf_parameter" content="_csrf">
<meta name="_csrf" content="71dac59f-34ee-4b31-b478-2891cbd0c55d">
```

This token is submitted as  `_csrf=71dac59f-34ee-4b31-b478-2891cbd0c55d`, that is, using the  `_csrf_parameter`  content as the variable name and the  `_csrf`  content as the value.

----------

[1](https://vaadin.com/docs/latest/components/login#_footnoteref_1). When added to a web component that uses shadow root, password managers are unable to find the input fields and therefore won’t work.

# Menu Bar
Menu Bar is a horizontal button bar with hierarchical drop-down menus. Menu items can trigger an action, open a menu, or work as a toggle.

```java
MenuBar menuBar = new MenuBar();
Text selected = new Text("");
ComponentEventListener<ClickEvent<MenuItem>> listener = e -> selected
        .setText(e.getSource().getText());
Div message = new Div(new Text("Clicked item: "), selected);

menuBar.addItem("View", listener);
menuBar.addItem("Edit", listener);

MenuItem share = menuBar.addItem("Share");
SubMenu shareSubMenu = share.getSubMenu();
MenuItem onSocialMedia = shareSubMenu.addItem("On social media");
SubMenu socialMediaSubMenu = onSocialMedia.getSubMenu();
socialMediaSubMenu.addItem("Facebook", listener);
socialMediaSubMenu.addItem("Twitter", listener);
socialMediaSubMenu.addItem("Instagram", listener);
shareSubMenu.addItem("By email", listener);
shareSubMenu.addItem("Get Link", listener);

MenuItem move = menuBar.addItem("Move");
SubMenu moveSubMenu = move.getSubMenu();
moveSubMenu.addItem("To folder", listener);
moveSubMenu.addItem("To trash", listener);

menuBar.addItem("Duplicate", listener);
```

## Styles

### Default Variants

The following variants are available to adjust the appearance of the component:

```java
MenuBar menuWithDefaultTheme = new MenuBar();
addItem(menuWithDefaultTheme, "Default");

MenuBar menuWithTertiaryTheme = new MenuBar();
menuWithTertiaryTheme.addThemeVariants(MenuBarVariant.LUMO_TERTIARY);
addItem(menuWithTertiaryTheme, "Tertiary");

MenuBar menuWithPrimaryTheme = new MenuBar();
menuWithPrimaryTheme.addThemeVariants(MenuBarVariant.LUMO_PRIMARY);
addItem(menuWithPrimaryTheme, "Primary");

MenuBar menuWithSmallTheme = new MenuBar();
menuWithSmallTheme.addThemeVariants(MenuBarVariant.LUMO_SMALL);
addItem(menuWithSmallTheme, "Small");
```

Variant

Usage Recommendation

Tertiary

Corresponds to the  [tertiary button variant](https://vaadin.com/docs/latest/components/button#styles), omitting the background color.

Primary

Corresponds to the primary button variant. Since only one primary action should be presented in the same part of the UI, this should be used only for  [drop-down button use cases](https://vaadin.com/docs/latest/components/menu-bar#dropdown-buttons).

Small

Compact variant. Can be combined with Tertiary and Primary.

Customize Default Menu Button Styles

The standard Menu Button styles can be adjusted using  [the Lumo style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties). These variants should be used only to differentiate special instances of the component.

### Alignment

Top-level items are aligned by default to the start of the Menu Bar. Use instead the  `end-aligned`  theme variant to align them to the end.

```java
MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_END_ALIGNED);
```

### Styling Menu Items

Individual menu items can be styled by  applying custom class names to them, and writing CSS style blocks targeting those class names. Notice that root-level menu items in the Menu Bar are wrapped in  `vaadin-menu-bar-button`  elements, which inherit the class names from the items within them.

```java
MenuItem view = menuBar.addItem("View");
view.addClassNames(LumoUtility.Background.PRIMARY,
        LumoUtility.TextColor.PRIMARY_CONTRAST);
;

MenuItem edit = menuBar.addItem("Edit");

MenuItem share = menuBar.addItem("Share");
SubMenu shareSubMenu = share.getSubMenu();

shareSubMenu.addItem("By email").addClassNames(
        LumoUtility.Background.PRIMARY,
        LumoUtility.TextColor.PRIMARY_CONTRAST);
shareSubMenu.addItem("Get Link");
```

Use Theme Names, Not Class Names pre-V24.3

In versions prior to 24.3, theme names must be used instead of class names (`theme`  property /  `addThemeNames`  Java method). The CSS syntax for targeting a theme name is  `[theme~="custom-theme"]`

### Drop-down Indicators

Menu buttons with sub-menu can be visually identified from items that trigger an action immediately using  `dropdown-indicators`  theme variant.

```java
MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_DROPDOWN_INDICATORS);
```

## Overflow

Items that don’t fit into the current width of the menu bar collapse into an overflow menu at the end.

By default, collapsed items are removed from the end of the menu bar, but the component can be configured to  remove items from the start instead.

```java
MenuBar menuBar = new MenuBar();
addItems(menuBar);
Div div = new Div();
div.setText("Move the splitter to see overflow feature");

SplitLayout splitLayout = new SplitLayout(menuBar, div);
```

## Menu Item Features

Several features are available for menu items. They’re described in the following sub-sections.

### Icons

Menu items can have icons in addition to text — or instead of text.

```java
MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_ICON);
MenuItem share = createIconItem(menuBar, VaadinIcon.SHARE, "Share",
        null);
SubMenu shareSubMenu = share.getSubMenu();
createIconItem(shareSubMenu, VaadinIcon.SHARE, "By Email", null, true);
createIconItem(shareSubMenu, VaadinIcon.LINK, "Get link", null, true);
createIconItem(menuBar, VaadinIcon.COPY, null, "duplicate");

...

private MenuItem createIconItem(HasMenuItems menu, VaadinIcon iconName,
        String label, String ariaLabel) {
    return createIconItem(menu, iconName, label, ariaLabel, false);
}

private MenuItem createIconItem(HasMenuItems menu, VaadinIcon iconName,
        String label, String ariaLabel, boolean isChild) {
    Icon icon = new Icon(iconName);

    if (isChild) {
        icon.getStyle().set("width", "var(--lumo-icon-size-s)");
        icon.getStyle().set("height", "var(--lumo-icon-size-s)");
        icon.getStyle().set("marginRight", "var(--lumo-space-s)");
    }

    MenuItem item = menu.addItem(icon, e -> {
    });

    if (ariaLabel != null) {
        item.setAriaLabel(ariaLabel);
    }

    if (label != null) {
        item.add(new Text(label));
    }

    return item;
}
```

Most actions are difficult to represent reliably with icons, so use them sparingly. The benefit of icons in addition to text should be weighed against the visual distractions they may create. Menu items in drop-down menus should always have text labels.

Icon-only menu buttons should be used primarily for common recurring actions with highly standardized, universally understood icons. Menu buttons should include a textual alternative for screen readers using the  `aria-label`  attribute or  [tooltips](https://vaadin.com/docs/latest/components/menu-bar#tooltips). Menu Bars with icon-only top-level items can use the  **Tertiary Inline**  style variant to reduce the horizontal padding around the icons.

```java
MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_TERTIARY_INLINE);

createIconItem(menuBar, VaadinIcon.EYE, "View");
createIconItem(menuBar, VaadinIcon.PENCIL, "Edit");

MenuItem share = createIconItem(menuBar, VaadinIcon.SHARE, "Share");
SubMenu shareSubMenu = share.getSubMenu();
MenuItem onSocialMedia = shareSubMenu.addItem("On social media");
SubMenu socialMediaSubMenu = onSocialMedia.getSubMenu();
socialMediaSubMenu.addItem("Facebook");
socialMediaSubMenu.addItem("Twitter");
socialMediaSubMenu.addItem("Instagram");
shareSubMenu.addItem("By email");
shareSubMenu.addItem("Get Link");

MenuItem move = createIconItem(menuBar, VaadinIcon.FOLDER, "Move");
SubMenu moveSubMenu = move.getSubMenu();
moveSubMenu.addItem("To folder");
moveSubMenu.addItem("To trash");

createIconItem(menuBar, VaadinIcon.COPY, "Duplicate");

...

private MenuItem createIconItem(MenuBar menu, VaadinIcon iconName,
        String ariaLabel) {
    Icon icon = new Icon(iconName);
    MenuItem item = menu.addItem(icon);
    item.setAriaLabel(ariaLabel);

    return item;
}
```

Other Components in Menu Items

While it’s technically possible to put any UI element in a menu item, this can cause problems for accessibility as it may not be possible to focus them, and they may not be interpreted correctly by assistive technologies.

### Disabled Items

Menu items can be disabled to show that they are unavailable currently.

```java
MenuBar menuBar = new MenuBar();

menuBar.addItem("View");
MenuItem edit = menuBar.addItem("Edit");
edit.setEnabled(false);

MenuItem share = menuBar.addItem("Share");
SubMenu shareSubMenu = share.getSubMenu();
shareSubMenu.addItem("By email").setEnabled(false);
shareSubMenu.addItem("Get Link");
```

### Checkable Menu Items

Menu items in drop-down menus can be configured as checkable to toggle options on and off.

```java
MenuBar menuBar = new MenuBar();
MenuItem options = menuBar.addItem("Options");
SubMenu subItems = options.getSubMenu();

MenuItem saveItem = subItems.addItem("Save automatically");
saveItem.setCheckable(true);
saveItem.setChecked(true);
MenuItem notifyItem = subItems.addItem("Notify watchers");
notifyItem.setCheckable(true);
notifyItem.setChecked(false);

ComponentEventListener<ClickEvent<MenuItem>> listener = event -> {
    // System.out.println(event.getSource().isChecked());
};

saveItem.addClickListener(listener);
notifyItem.addClickListener(listener);
```

Not a Radio Button Replacement

A Menu Bar with checkable items shouldn’t be used as a replacement for  [radio buttons](https://vaadin.com/docs/latest/components/radio-button)  in a form.

## Dividers

You can use dividers to separate and group related content. However, use dividers sparingly to avoid creating unnecessary visual clutter.

```java
MenuBar menuBar = new MenuBar();
MenuItem item = menuBar.addItem("Share");
SubMenu subMenu = item.getSubMenu();
subMenu.addItem("Facebook");
subMenu.addItem("Twitter");
subMenu.addItem("Instagram");
subMenu.add(new Hr());
subMenu.addItem("By email");
subMenu.addItem("Get link");
subMenu.add(new Hr());
subMenu.addItem("Set permissions");
```

Other Content Not Accessible

While it’s technically possible to put any UI element in a drop-down menu — including interactive components — they’re not accessible by keyboard or assistive technologies.

## Open on Hover

A component can be configured to open drop-down menus on hover, instead of on click.

```java
MenuBar menuBar = new MenuBar();
menuBar.setOpenOnHover(true);
addItems(menuBar);
```

## Tooltips

Tooltips can be configured on top-level items to provide additional information, especially for icon-only items. When a top-level item is disabled, the corresponding tooltip isn’t shown.

```java
MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_ICON);

createIconItem(menuBar, VaadinIcon.EYE, "View");
createIconItem(menuBar, VaadinIcon.PENCIL, "Edit");
createIconItem(menuBar, VaadinIcon.FOLDER, "Move");
createIconItem(menuBar, VaadinIcon.COPY, "Duplicate");
MenuItem archive = createIconItem(menuBar, VaadinIcon.ARCHIVE,
        "Archive");
archive.setEnabled(false);

...

private MenuItem createIconItem(MenuBar menu, VaadinIcon iconName,
        String tooltipText) {
    Icon icon = new Icon(iconName);
    MenuItem item = menu.addItem(icon, tooltipText);
    return item;
}
```

See the  [Tooltips documentation page](https://vaadin.com/docs/latest/components/tooltip)  for details on tooltip configuration.

## Keyboard Usage

### Top-Level Items

Interaction

Keyboard Shortcut

Navigate between top-level items.

Left  and  Right  arrow keys

Open top-level menu.

Down  /  Space  /  Enter

Trigger top-level item with a menu.

Space  /  Enter

### Menu-Items

Interaction

Keyboard Shortcut

Navigate between items in a drop-down menu.

Up  and  Down  arrow keys

Open sub-menu.

Right  /  Space  /  Enter

Trigger menu item without a sub-menu.

Space  /  Enter

Return to previous menu.

Left

Close the drop-down menu.

Esc

## Drop-Down & Combo Buttons

A Menu Bar with a single top-level item is essentially a drop-down button. This solution provides a better user experience and better accessibility than a regular  [Button](https://vaadin.com/docs/latest/components/button)  paired with a  [Context Menu](https://vaadin.com/docs/latest/components/context-menu).

```java
MenuBar menuBar = new MenuBar();
MenuItem item = menuBar.addItem("John Smith");
SubMenu subMenu = item.getSubMenu();
subMenu.addItem("Profile");
subMenu.addItem("Account");
subMenu.addItem("Preferences");
subMenu.add(new Hr());
subMenu.addItem("Sign out");
```

So-called  _combo buttons_  can be created in a similar way. For example, they can be created to provide a set of variations on an action.

```java
MenuBar menuBar = new MenuBar();
menuBar.addThemeVariants(MenuBarVariant.LUMO_ICON,
        MenuBarVariant.LUMO_PRIMARY);
menuBar.addItem("Save");
MenuItem item = menuBar.addItem(new Icon(VaadinIcon.CHEVRON_DOWN));
SubMenu subItems = item.getSubMenu();
subItems.addItem("Save as draft");
subItems.addItem("Save as copy");
subItems.addItem("Save and publish");
```

## Internationalization (i18n)

Menu Bar provides an API for localization. Currently, only the accessible label for the overflow menu button can be customized.

```java
MenuBar menuBar = new MenuBar();
MenuBar.MenuBarI18n customI18n = new MenuBar.MenuBarI18n()
        // Provide accessible label for the overflow menu button
        // to screen readers
        .setMoreOptions("More actions");

menuBar.setI18n(customI18n);
```

## Best Practices

Menu Bar shouldn’t be used for navigation. Use  [tabs](https://vaadin.com/docs/latest/components/tabs)  to switch between content, or anchor elements for regular navigation. It isn’t an input field. Use instead  [Select](https://vaadin.com/docs/latest/components/select),  [Combo Box](https://vaadin.com/docs/latest/components/combo-box), or  [Radio Button](https://vaadin.com/docs/latest/components/radio-button).

Menu Bar is an interactive component. Using other interactive components like Combo Box as menu items is not advised as this may produce conflicts in keyboard navigation and interaction. Although items are children of Menu Bar, it’s not supposed to act as a layout component.

# Message Input
Message Input allows users to author and send messages.

```java
MessageInput input = new MessageInput();
input.addSubmitListener(submitEvent -> {
    Notification.show("Message received: " + submitEvent.getValue(),
            3000, Notification.Position.MIDDLE);
});
add(input);
```

The user can send the message with one of the following actions:

-   by pressing  Enter  (use  Shift+Enter  to add a new line)

-   by clicking the “send” button.


Use the  [Message List](https://vaadin.com/docs/latest/components/message-list)  component to show messages that users have sent.

```java
MessageList list = new MessageList();
MessageInput input = new MessageInput();
input.addSubmitListener(submitEvent -> {
    MessageListItem newMessage = new MessageListItem(
            submitEvent.getValue(), Instant.now(), "Milla Sting");
    newMessage.setUserColorIndex(3);
    List<MessageListItem> items = new ArrayList<>(list.getItems());
    items.add(newMessage);
    list.setItems(items);
});

Person person = DataService.getPeople(1).get(0);
MessageListItem message1 = new MessageListItem(
        "Nature does not hurry, yet everything gets accomplished.",
        LocalDateTime.now().minusDays(1).toInstant(ZoneOffset.UTC),
        "Matt Mambo");
message1.setUserColorIndex(1);
MessageListItem message2 = new MessageListItem(
        "Using your talent, hobby or profession in a way that makes you contribute with something good to this world is truly the way to go.",
        LocalDateTime.now().minusMinutes(55).toInstant(ZoneOffset.UTC),
        "Linsey Listy", person.getPictureUrl());
message2.setUserColorIndex(2);
list.setItems(message1, message2);

VerticalLayout chatLayout = new VerticalLayout(list, input);
chatLayout.setHeight("500px");
chatLayout.setWidth("400px");
chatLayout.expand(list);
add(chatLayout);
```

# Message List
Message List allows you to show a list of messages, for example, a chat log. You can configure the text content, information about the sender, and the time of sending for each message.

```java
Person person = DataService.getPeople(1).get(0);
MessageList list = new MessageList();
Instant yesterday = LocalDateTime.now().minusDays(1)
        .toInstant(ZoneOffset.UTC);
Instant fiftyMinsAgo = LocalDateTime.now().minusMinutes(50)
        .toInstant(ZoneOffset.UTC);
MessageListItem message1 = new MessageListItem(
        "Linsey, could you check if the details with the order are okay?",
        yesterday, "Matt Mambo");
message1.setUserColorIndex(1);
MessageListItem message2 = new MessageListItem("All good. Ship it.",
        fiftyMinsAgo, "Linsey Listy", person.getPictureUrl());
message2.setUserColorIndex(2);
list.setItems(Arrays.asList(message1, message2));
add(list);
```

The messages in the list can be populated with the  `items`  property. The  `items`  property is of type  `Array`, with JSON objects in it. Each JSON object is a single message.

## Styling

You can style individual messages by adding a theme property to some items and providing CSS for that theme. The following example shows how to highlight the current user’s own messages:

```java
Person person = DataService.getPeople(1).get(0);
MessageList list = new MessageList();

Instant yesterday = LocalDateTime.now(ZoneOffset.UTC).minusDays(1)
        .toInstant(ZoneOffset.UTC);
MessageListItem message1 = new MessageListItem(
        "Linsey, could you check if the details with the order are okay?",
        yesterday, "Matt Mambo");
message1.setUserColorIndex(1);

Instant fiftyMinsAgo = LocalDateTime.now(ZoneOffset.UTC)
        .minusMinutes(50).toInstant(ZoneOffset.UTC);
MessageListItem message2 = new MessageListItem("All good. Ship it.",
        fiftyMinsAgo, "Linsey Listy", person.getPictureUrl());
message2.setUserColorIndex(2);
// Add custom class name
message2.addClassNames("current-user");

list.setItems(Arrays.asList(message1, message2));
add(list);
```

Use Theme Names, Not Class Names pre-V24.3

In versions prior to 24.3, theme names must be used instead of class names (`theme`  property /  `addThemeNames`  Java method). The CSS syntax for targeting a theme name is  `[theme~="custom-theme"]`.

# Message List
Message List allows you to show a list of messages, for example, a chat log. You can configure the text content, information about the sender, and the time of sending for each message.

```java
Person person = DataService.getPeople(1).get(0);
MessageList list = new MessageList();
Instant yesterday = LocalDateTime.now().minusDays(1)
        .toInstant(ZoneOffset.UTC);
Instant fiftyMinsAgo = LocalDateTime.now().minusMinutes(50)
        .toInstant(ZoneOffset.UTC);
MessageListItem message1 = new MessageListItem(
        "Linsey, could you check if the details with the order are okay?",
        yesterday, "Matt Mambo");
message1.setUserColorIndex(1);
MessageListItem message2 = new MessageListItem("All good. Ship it.",
        fiftyMinsAgo, "Linsey Listy", person.getPictureUrl());
message2.setUserColorIndex(2);
list.setItems(Arrays.asList(message1, message2));
add(list);
```

The messages in the list can be populated with the  `items`  property. The  `items`  property is of type  `Array`, with JSON objects in it. Each JSON object is a single message.

## Styling

You can style individual messages by adding a theme property to some items and providing CSS for that theme. The following example shows how to highlight the current user’s own messages:
```java
Person person = DataService.getPeople(1).get(0);
MessageList list = new MessageList();

Instant yesterday = LocalDateTime.now(ZoneOffset.UTC).minusDays(1)
        .toInstant(ZoneOffset.UTC);
MessageListItem message1 = new MessageListItem(
        "Linsey, could you check if the details with the order are okay?",
        yesterday, "Matt Mambo");
message1.setUserColorIndex(1);

Instant fiftyMinsAgo = LocalDateTime.now(ZoneOffset.UTC)
        .minusMinutes(50).toInstant(ZoneOffset.UTC);
MessageListItem message2 = new MessageListItem("All good. Ship it.",
        fiftyMinsAgo, "Linsey Listy", person.getPictureUrl());
message2.setUserColorIndex(2);
// Add custom class name
message2.addClassNames("current-user");

list.setItems(Arrays.asList(message1, message2));
add(list);
```

Use Theme Names, Not Class Names pre-V24.3

In versions prior to 24.3, theme names must be used instead of class names (`theme`  property /  `addThemeNames`  Java method). The CSS syntax for targeting a theme name is  `[theme~="custom-theme"]`.

# Multi-Select Combo Box
Multi-Select Combo Box allows the user to choose one or more values from a filterable list of options presented in an overlay. The component  [supports the same features as the regular Combo Box](https://vaadin.com/docs/latest/components/combo-box), such as lazy loading or allowing custom typed values. This page explains how to add this component to your project and how to configure it.

```java
MultiSelectComboBox<Country> comboBox = new MultiSelectComboBox<>(
        "Countries");
comboBox.setItems(DataService.getCountries());
comboBox.setItemLabelGenerator(Country::getName);
add(comboBox);
```

The overlay opens when the user clicks the field using a pointing device. Using the  Up  and  Downarrow keys, or typing a character — that occurs in at least one of the options — when the field is focused also opens the popup.

## Common Combo Box Features

## Selection

The component allows selecting multiple values, each of which is displayed as a chip inside the component. If there isn’t enough space in the component to display chips for all selected values, some values are collapsed into an overflow chip. The example below shows a Multi-Select Combo Box with multiple preselected values, some of which are collapsed into the overflow chip:

```java
comboBox.select(countries.subList(0, 4));
```

When the overlay is closed, items can be removed one by one (starting with the most recently selected item) using the  Backspace  key. The first  Backspace  press moves focus to the last chip; the second press removes that chip, and the corresponding item, from the selection.

### Selection Change

The following example demonstrates how to listen for selection changes:


Use  `addValueChangeListener()`  to be notified about the user changing the selection. Alternatively,  `addSelectionChangeListener()`  can be used to get more detailed information about the selection change.

```java
TextArea selectedCountries = new TextArea("Selected Countries");
selectedCountries.setReadOnly(true);

comboBox.addValueChangeListener(e -> {
    String selectedCountriesText = e.getValue().stream()
            .map(Country::getName).collect(Collectors.joining(", "));

    selectedCountries.setValue(selectedCountriesText);
});
```

## Read-Only

The component can be set to read-only, which prevents the user from modifying its value. A read-only Multi-Select Combo Box still allows opening the overlay, which then shows only the selected values, instead of all the options. This can be useful if selected values have been collapsed into the overflow chip.

```java
comboBox.setReadOnly(true);
```

## Auto Expand

The component can be configured to auto-expand so as to accommodate chips for selected items. It’s possible to expand both horizontally (i.e., until max-width is reached) and vertically — in which case the field with chips wraps in multiple lines. These modes can be used together.

```java
comboBox.setAutoExpand(AutoExpandMode.BOTH);
```

## Selected Items on Top

The component can be configured to group selected items at the top of the overlay. When the selection changes, a set of items to be shown in the top group is only updated after the overlay is closed.

```java
comboBox.setSelectedItemsOnTop(true);
```

## Item Class Names

See  [Combo Box, Item Class Names](https://vaadin.com/docs/latest/components/combo-box#item-class-names). In addition to items in the overlay, custom class names also apply to chips representing selected items.

```java
MultiSelectComboBox<String> comboBox = new MultiSelectComboBox<>(
        "Fruit");
List<String> items = List.of("Apple", "Banana", "Orange", "Pear");
comboBox.setItems(items);
comboBox.setClassNameGenerator((item) -> {
    switch (item) {
    case "Apple":
        return "coral";
    case "Banana":
        return "gold";
    case "Orange":
        return "orange";
    case "Pear":
        return "yellowgreen";
    default:
        return "";
    }
});
```

## Internationalization (i18n)

Multi-Select Combo Box allows localizing the following messages. These are only used in screen reader announcements, and can’t be observed visually.

Message

Default

Description

`cleared`

"Selection cleared"

Announced by screen readers when the clear button is clicked.

`focused`

" focused. Press Backspace to remove"

Announced by screen readers when a chip is focused.

`selected`

" added to selection"

Announced by screen readers when an item is added to the selection.

`deselected`

" removed from selection"

Announced by screen readers when an item is removed from the selection.

`total`

"{count} items selected"

Announced by screen readers to inform about the total number of selected items. The string must contain a  `{count}`  placeholder, which is replaced with the actual count of selected items by the component.

The following example demonstrates how to localize the component’s messages into German:

```java
MultiSelectComboBoxI18n i18n = new MultiSelectComboBoxI18n();
i18n.setCleared("Alle Einträge entfernt");
i18n.setFocused(" ausgewählt. Drücke Rücktaste zum Entfernen");
i18n.setSelected(" hinzugefügt");
i18n.setDeselected(" entfernt");
i18n.setTotal("{count} Einträge ausgewählt");

comboBox.setI18n(i18n);
```

## Best Practices

Multi-Select Combo Box supports lazy loading for large datasets. It reduces the initial load time, and consumes less bandwidth and resources.

For consistency, the default width of the Multi-Select Combo Box matches that of other input fields. You should increase the width of the component when using items with long labels, or if you expect users to select several items, to avoid collapsing selected items into the overflow chip.

```html
<vaadin-multi-select-combo-box
  style="width: 300px"
></vaadin-multi-select-combo-box>
```
# Notification
Notification is used to provide feedback to the user about activities, processes, and events in the application.

```java
// When creating a notification using the `show` static method,
// the duration is 5-sec by default.
Notification notification = Notification
        .show("Financial report generated");
```

## Theme Variants

Notification comes with a few theme variants:  [`success`](https://vaadin.com/docs/latest/components/notification#success);  [`warning`](https://vaadin.com/docs/latest/components/notification#warning);  [`error`](https://vaadin.com/docs/latest/components/notification#error);  [`primary`](https://vaadin.com/docs/latest/components/notification#primary); and  [`contrast`](https://vaadin.com/docs/latest/components/notification#contrast). These variants are described in the following sub-sections:

### Success

The  `success`  theme variant can be used to display success messages, such as when a task or operation is completed.

```java
Notification notification = Notification.show("Application submitted!");
notification.addThemeVariants(NotificationVariant.LUMO_SUCCESS);
```

Users shouldn’t be notified always, or even frequently, of successful operations. Too many notifications can be more distracting than helpful to users. Use success notifications only for operations whose successful completion may otherwise be difficult to discern.

### Warning

The  `warning`  theme variant can be used to display warnings.

```java
// When creating a notification using the constructor,
// the duration is 0-sec by default which means that
// the notification does not close automatically.
Notification notification = new Notification();
notification.addThemeVariants(NotificationVariant.LUMO_WARNING);

Div text = new Div(new Text(
        "Your session will expire in 5 minutes due to inactivity."),
        new HtmlComponent("br"),
        new Text("Close this warning to continue working."));

Button closeButton = new Button(new Icon("lumo", "cross"));
closeButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY_INLINE);
closeButton.setAriaLabel("Close");
closeButton.addClickListener(event -> {
    notification.close();
});

HorizontalLayout layout = new HorizontalLayout(text, closeButton);
layout.setAlignItems(Alignment.CENTER);

notification.add(layout);
notification.open();
```

Warning notifications should be persistent, and provide the user with a button that closes the notification or allows the user to take appropriate action.

### Error

The  `error`  theme variant can be used to display errors.

```java
// When creating a notification using the constructor,
// the duration is 0-sec by default which means that
// the notification does not close automatically.
Notification notification = new Notification();
notification.addThemeVariants(NotificationVariant.LUMO_ERROR);

Div text = new Div(new Text("Failed to generate report"));

Button closeButton = new Button(new Icon("lumo", "cross"));
closeButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY_INLINE);
closeButton.setAriaLabel("Close");
closeButton.addClickListener(event -> {
    notification.close();
});

HorizontalLayout layout = new HorizontalLayout(text, closeButton);
layout.setAlignItems(Alignment.CENTER);

notification.add(layout);
notification.open();
```

Error notifications should be persistent, and provide the user with a button that closes the notification or allows the user to take appropriate action.

Notifications are non-modal and can be ignored. Therefore, they’re usually inappropriate for displaying unexpected technical errors that prevent the application from functioning, or situations that require immediate user action. Use instead a modal  [Dialog](https://vaadin.com/docs/latest/components/dialog)  in such situations.

The built-in error message feature, included with input field components, should be used for field-specific input validation errors.

### Primary

The  `primary`  theme variant can be used for important informational messages or to draw extra attention to a notification.

```java
// When creating a notification using the `show` static method,
// the duration is 5-sec by default.
Notification notification = Notification
        .show("New project plan available");
notification.addThemeVariants(NotificationVariant.LUMO_PRIMARY);
```

### Contrast

The contrast variant can improve legibility and distinguish the notification from the rest of the UI.

```java
// When creating a notification using the `show` static method,
// the duration is 5-sec by default.
Notification notification = Notification.show("5 tasks deleted");
notification.addThemeVariants(NotificationVariant.LUMO_CONTRAST);
```

## Duration

By default, notifications stay on-screen for five seconds. The duration can be set — in milliseconds — and should be done so based on the content and its importance:

-   Use short durations for notifications that contain short text, are of lesser importance (e.g., operations that finished without errors), and have no interactive elements.

-   Use longer durations for notifications that contain longer text, are of higher importance (e.g., errors), and have interactive elements (e.g., links or "undo" actions).


A duration of at least five seconds (i.e.,  `5000`  milliseconds) is recommended — this is why it’s the default — to ensure that the user has a chance to read and understand the notification.

### Persistent Notifications

Setting the duration to  `0`  milliseconds disables auto-closing. It keeps the notification visible until it’s explicitly dismissed by the user. This should be used for notifications that provide vital information to the user, such as errors.

Persistent notifications should contain a Button that closes the notification, or allows the user to take appropriate action. Less-important notifications shouldn’t be persistent, and instead disappear automatically after an appropriate delay.

## Position

Notifications can be positioned in the viewport in seven non-stretched positions, or stretched across the top or bottom:

```java
add(createButton(Position.TOP_STRETCH),
        createButton(Position.TOP_START),
        createButton(Position.TOP_CENTER),
        createButton(Position.TOP_END), createButton(Position.MIDDLE),
        createButton(Position.BOTTOM_START),
        createButton(Position.BOTTOM_CENTER),
        createButton(Position.BOTTOM_END),
        createButton(Position.BOTTOM_STRETCH));

...

private Button createButton(Notification.Position position) {
    Button button = new Button(position.getClientName());
    button.addClickListener(event -> show(position));
    return button;
}

...

private void show(Notification.Position position) {
    Notification.show(position.getClientName(), 5000, position);
}
```

**Top End**  or  **Bottom Start**  are recommended for most notifications. They’re unobtrusive, but still noticeable.  **Middle**  is the most disruptive position, and should be used only for important notifications, such as errors.  **Bottom End**  is the least obtrusive position, but can go unnoticed.  **Stretch**  notifications, which span the full width of the viewport, are disruptive, and should be reserved for important notifications whose content requires more space.

Applications with a notification button, or a drop-down in the header or footer, should position notifications to appear in the same part of the screen. For a consistent user experience, use one or two positions throughout the application. Avoid using positions that may obstruct important parts of the UI, such as navigation.

## Stacking

Multiple simultaneously displayed notifications are stacked vertically. The ordering of them, though, depends on their positioning.

When using the bottom half of the screen as the position, a new notification appears below the older notifications. With the position set to the top half, a new notification appears above the existing notifications.

## Size

The notification card is automatically sized based on its content.

In large viewports, the card’s maximum width is one-third of the viewport. In small viewports, the card always consumes the entire width of the viewport.

## Interactive Elements

Notifications can contain interactive content (e.g., Buttons or links) that allow the user to perform related actions.

For example, if an operation fails, the error notification could offer the user the opportunity to try again. Or it could contain a link to a view that allows the user to resolve the problem.

```java
Notification notification = new Notification();
notification.addThemeVariants(NotificationVariant.LUMO_ERROR);

// this is the default, 0 or negative means the Notificaiton
// is not closed automatically
notification.setDuration(0);

// Now we can compose the content from components
Button retryButton = new RetryButton();
Button closeButton = new CloseButton();

var layout = new HorizontalLayout(new Text("Failed to generate report"),
        retryButton, closeButton);
notification.add(layout);

notification.open();
```

In situations where the user might want to revert an action, display an "Undo" button.

```java
Notification notification = new Notification();
notification.setDuration(10000);
notification.addThemeVariants(NotificationVariant.LUMO_CONTRAST);

Button undoButton = new UndoButton();
undoButton.addClickListener(event -> {
    // In this example we just close the Notification
    notification.close();
});

var layout = new HorizontalLayout(new Text("5 tasks deleted"),
        undoButton, new CloseButton());
layout.setAlignItems(Alignment.CENTER);
notification.add(layout);

notification.open();
```

Notifications can also contain links to relevant information.

```java
// When creating a notification using the constructor,
// the duration is 0-sec by default which means that
// the notification does not close automatically.
Notification notification = new Notification();

Div text = new Div(new Text("Jason Bailey mentioned you in "),
        new Anchor("#", "Project Q4"));

Button closeButton = new Button(new Icon("lumo", "cross"));
closeButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY_INLINE);
closeButton.setAriaLabel("Close");
closeButton.addClickListener(event -> {
    notification.close();
});

HorizontalLayout layout = new HorizontalLayout(text, closeButton);
layout.setAlignItems(Alignment.CENTER);

notification.add(layout);
notification.open();
```

### Keyboard-Accessible

Make sure that keyboard-only users can access interactive elements in notifications.

Make the notification persistent to prevent it from disappearing before the user has had a chance to react. Provide a keyboard shortcut — either to trigger the action itself or to move focus to the notification card — in cases where multiple interactive elements are present. Finally, make the shortcut discoverable, for example, by displaying it as part of the notification’s content.

```java
public Notification show() {
    Notification notification = new Notification();
    notification.setDuration(10000);
    notification.addThemeVariants(NotificationVariant.LUMO_CONTRAST);

    Div statusText = new Div(new Text("5 tasks deleted"));

    var layout = new HorizontalLayout(statusText,
            new CloseButtonWithShortcutHint());
    layout.setAlignItems(Alignment.CENTER);

    notification.add(layout);
    notification.open();

    return notification;
}

// ...

public void setupUndoShortcut(Notification notification) {
    Shortcuts.addShortcutListener(notification, notification::close,
            Key.of("z"), KeyModifier.META);
    Shortcuts.addShortcutListener(notification, notification::close,
            Key.of("z"), KeyModifier.CONTROL);
}
```

## Icons & Other Rich Formatting

Icons and other content formatting can be used to provide information and helpful visual cues. For example, you might do this to make error and success notifications easier to distinguish for users with color blindness.

```java
public static Notification createSubmitSuccess() {
    Notification notification = new Notification();
    notification.addThemeVariants(NotificationVariant.LUMO_SUCCESS);

    Icon icon = VaadinIcon.CHECK_CIRCLE.create();

    Button viewBtn = new Button("View", clickEvent -> notification.close());
    viewBtn.getStyle().setMargin("0 0 0 var(--lumo-space-l)");

    var layout = new HorizontalLayout(icon,
            new Text("Application submitted!"), viewBtn,
            createCloseBtn(notification));
    layout.setAlignItems(FlexComponent.Alignment.CENTER);

    notification.add(layout);

    return notification;
}

public static Notification createReportError() {
    Notification notification = new Notification();
    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);

    Icon icon = VaadinIcon.WARNING.create();
    Button retryBtn = new Button("Retry",
            clickEvent -> notification.close());
    retryBtn.getStyle().setMargin("0 0 0 var(--lumo-space-l)");

    var layout = new HorizontalLayout(icon,
            new Text("Failed to generate report!"), retryBtn,
            createCloseBtn(notification));
    layout.setAlignItems(FlexComponent.Alignment.CENTER);

    notification.add(layout);

    return notification;
}

public static Notification createMentionNotification() {
    Notification notification = new Notification();

    Avatar avatar = new Avatar("Jason Bailey");

    Span name = new Span("Jason Bailey");
    name.getStyle().set("font-weight", "500");

    Div info = new Div(name, new Text(" mentioned you in "),
            new Anchor("#", "Project Q4"));

    HorizontalLayout layout = new HorizontalLayout(avatar, info,
            createCloseBtn(notification));
    layout.setAlignItems(FlexComponent.Alignment.CENTER);

    notification.add(layout);

    return notification;
}

public static Notification createUploadSuccess() {
    Notification notification = new Notification();

    Icon icon = VaadinIcon.CHECK_CIRCLE.create();
    icon.setColor("var(--lumo-success-color)");

    Div uploadSuccessful = new Div(new Text("Upload successful"));
    uploadSuccessful.getStyle().set("font-weight", "600")
            .setColor("var(--lumo-success-text-color)");

    Span fileName = new Span("Financials.xlsx");
    fileName.getStyle().set("font-size", "var(--lumo-font-size-s)")
            .set("font-weight", "600");

    Div info = new Div(uploadSuccessful,
            new Div(fileName, new Text(" is now available in "),
                    new Anchor("#", "Documents")));

    info.getStyle().set("font-size", "var(--lumo-font-size-s)")
            .setColor("var(--lumo-secondary-text-color)");

    var layout = new HorizontalLayout(icon, info,
            createCloseBtn(notification));
    layout.setAlignItems(FlexComponent.Alignment.CENTER);

    notification.add(layout);

    return notification;
}

public static Button createCloseBtn(Notification notification) {
    Button closeBtn = new Button(VaadinIcon.CLOSE_SMALL.create(),
            clickEvent -> notification.close());
    closeBtn.addThemeVariants(LUMO_TERTIARY_INLINE);

    return closeBtn;
}
```

## Static Helper

For simple, one-off notifications, it’s convenient to use the static  `show()`  helper method. The helper manages the notification’s lifecycle, and adds and removes it from the DOM, automatically.

```java
// Show a simple text-based notification
Notification notification = Notification
        .show("Financial report generated");
notification.setPosition(Notification.Position.MIDDLE);
```

## Best Practices

### Use Sparingly

Notifications are disruptive by design and should be used sparingly. Use fewer notifications by reserving them for more-important information that might otherwise go unnoticed by the user.

Less-urgent notifications can be provided through a link or a drop-down in the application header or footer, instead of via immediate notifications.

```java
var bellBtn = new MessagesButton();
bellBtn.setUnreadMessages(4);

ContextMenu menu = new ContextMenu();
menu.setOpenOnClick(true);
menu.setTarget(bellBtn);
menu.addItem("This is ContextMenu");
menu.addItem("Consider Using");
menu.addItem("ContextMenu");
menu.addItem("Instead of Notifications");
```

### Limit Content Length

Notifications should be brief and to the point. Try to limit the content to one or two lines. More information can be provided through an embedded link or Button.

Aria Bailey

Yeah, I know. But could you help me with...

View

Show a preview of longer content, and link to the full details.

New message from Aria Bailey

Yeah, I know. But could you help me with this. I’m not sure where the bug is in my CSS? The checkmark doesn’t get the right color. I’m trying to use the CSS custom properties from our design system, but for some reason it’s not working.

Don’t display all details in the notification.

# Number Field
Number Field is an input field that accepts only numeric input. The input can be a decimal or an  [integer](https://vaadin.com/docs/latest/components/number-field#integer-field). There is also a  [big decimal](https://vaadin.com/docs/latest/components/number-field#bigdecimal-field)  for Flow.

You can specify a unit as a prefix, or a suffix for the field.

```java
NumberField dollarField = new NumberField();
dollarField.setLabel("Balance");
dollarField.setValue(200.0);
Div dollarPrefix = new Div();
dollarPrefix.setText("$");
dollarField.setPrefixComponent(dollarPrefix);

NumberField euroField = new NumberField();
euroField.setLabel("Balance");
euroField.setValue(200.0);
Div euroSuffix = new Div();
euroSuffix.setText("€");
euroField.setSuffixComponent(euroSuffix);

add(dollarField, euroField);
```

## Step Buttons

Step buttons allow the user to make small adjustments, quickly.

```java
IntegerField adultsField = new IntegerField();
adultsField.setValue(2);
adultsField.setStepButtonsVisible(true);
adultsField.setMin(0);
adultsField.setMax(9);
```

## Minimum and Maximum Value

The valid input range of a Number Field is set by defining the minimum and maximum values.

You can set the helper text to give information about the range.

```java
IntegerField integerField = new IntegerField();
integerField.setLabel("Quantity");
integerField.setHelperText("Max 10 items");
integerField.setMin(0);
integerField.setMax(10);
integerField.setValue(2);
integerField.setStepButtonsVisible(true);
add(integerField);
```

## Step

The step value of a Number Field defines the numeric intervals that are allowed.

It specifies the amount by which the value increases or decreases when using the Up or Down arrow keys, or the step buttons.

It also invalidates the field if the value entered doesn’t align with the specified step.

```java
NumberField numberField = new NumberField();
numberField.setLabel("Duration (hours)");
numberField.setStep(0.5);
numberField.setValue(12.5);
numberField.setStepButtonsVisible(true);
add(numberField);
```

## Number Type Variants

### Integer Field

To allow only integers to be entered, you can use the Integer Field like so:

```java
IntegerField xField = new IntegerField();
xField.setLabel("X");
xField.setValue(-1284);

IntegerField yField = new IntegerField();
yField.setLabel("Y");
yField.setValue(3910);

add(xField, yField);
```

### BigDecimal Field (Flow)

Flow developers who need to support the  [BigDecimal](https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html)  type can use BigDecimal Field:

```java
BigDecimalField bigDecimalField = new BigDecimalField();
bigDecimalField.setLabel("Result");
bigDecimalField.setWidth("240px");
bigDecimalField.setValue(new BigDecimal("948205817.472950487"));
add(bigDecimalField);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/number-field#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/number-field#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/number-field#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/number-field#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/number-field#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/number-field#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix & Suffix

Prefix and suffix elements — rendered at either end of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix and suffix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/number-field#label), a  [Helper](https://vaadin.com/docs/latest/components/number-field#helper), or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.


```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-number-field accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-number-field accessible-name="This is the label">...
```

```java
NumberField field = new NumberField();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(new Span("$"));
field.setSuffixComponent(VaadinIcon.DOLLAR.create());
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
NumberField readonlyField = new NumberField();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue(200.0);

NumberField disabledField = new NumberField();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
NumberField field = new NumberField();
field.addThemeVariants(TextFieldVariant.LUMO_SMALL,
        TextFieldVariant.LUMO_ALIGN_RIGHT,
        TextFieldVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Best Practices

Number Field should be used for actual number values, such as counts and measures — values that may be part of a calculation. Don’t use it for other digit-based values, such as telephone, credit card, and social security numbers. These values can have leading zeros and be greater than Number Field’s maximum supported value.

When applicable, set the most common choice as the default value. For example, airline, bus, train and other travel companies typically set the default number of passengers to 1.

# Password Field

Password Field is an input field for entering passwords. The input is masked by default. On mobile devices, though, the last typed letter is shown for a brief moment. The masking can be toggled using an optional reveal button.

```java
PasswordField passwordField = new PasswordField();
passwordField.setLabel("Password");
passwordField.setValue("Ex@mplePassw0rd");
add(passwordField);
```

## Reveal Button

The reveal button allows the user to disable masking and see the value they entered. This is especially helpful on mobile devices, where typing is more error-prone. In cases where this feature isn’t desired, it can be disabled.

```java
PasswordField passwordField = new PasswordField();
passwordField.setRevealButtonVisible(false);
passwordField.setLabel("Password");
passwordField.setValue("Ex@mplePassw0rd");
add(passwordField);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/password-field#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/password-field#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/password-field#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/password-field#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/password-field#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/password-field#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix & Suffix

Prefix and suffix elements — rendered at either end of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix and suffix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/password-field#label), a  [Helper](https://vaadin.com/docs/latest/components/password-field#helper), or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-password-field accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-password-field accessible-name="This is the label">...
```

```java
PasswordField field = new PasswordField();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.LOCK.create());
```

## Constraints

Required

Required fields are marked with an indicator next to the label, and become invalid if left empty after having been focused. An error message explaining that the field is required needs to be provided manually.

An instruction text at the top of the form explaining the required indicator is recommended. The indicator itself can be customized with the  `--lumo-required-field-indicator`  style property.

Min & Max Length

The minimum and maximum input length value constraints dictate the smallest, and the largest number of characters a field accepts. It triggers a validation error if a value shorter than the minimum length is entered, and limits text entered to the maximum length. They can be used to enforce specific formats, or to cap the value to the length supported by the underlying database schema.

In cases where the length requirements may not be clear to the user, it’s recommended to provide this information, for example by using a Helper.

Allowed Characters

A separate single-character, regular expression can be used to restrict the characters that can be entered into the field. Characters that don’t match the expression are rejected.

```java
PasswordField field = new PasswordField("Password");
field.setRequiredIndicatorVisible(true);
field.setAllowedCharPattern("[A-Za-z0-9]");
field.setMinLength(6);
field.setMaxLength(12);
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
PasswordField readonlyField = new PasswordField();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue("Ex@mplePassw0rd");

PasswordField disabledField = new PasswordField();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
PasswordField field = new PasswordField();
field.addThemeVariants(TextFieldVariant.LUMO_SMALL,
        TextFieldVariant.LUMO_ALIGN_RIGHT,
        TextFieldVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Best Practices

Express clearly your password requirements to the user, so that they don’t have to guess. The  [Helper](https://vaadin.com/docs/latest/components/password-field#helper)  feature is appropriate for this purpose.

```java
PasswordField passwordField = new PasswordField();
passwordField.setLabel("Password");
passwordField.setHelperText(
        "A password must be at least 8 characters. It has to have at least one letter and one digit.");
passwordField.setPattern("^(?=.*[0-9])(?=.*[a-zA-Z]).{8}.*$");
passwordField.setErrorMessage("Not a valid password");
add(passwordField);
```

Showing the strength of the entered password can also be a motivating factor for users to create better passwords. You could display it with a more advanced Helper:

```java
PasswordField passwordField = new PasswordField();
passwordField.setLabel("Password");
passwordField.setRevealButtonVisible(false);

checkIcon = VaadinIcon.CHECK.create();
checkIcon.setVisible(false);
checkIcon.getStyle().set("color", "var(--lumo-success-color)");
passwordField.setSuffixComponent(checkIcon);

Div passwordStrength = new Div();
passwordStrengthText = new Span();
passwordStrength.add(new Text("Password strength: "),
        passwordStrengthText);
passwordField.setHelperComponent(passwordStrength);

add(passwordField);
```
# Popover
A generic overlay whose position is anchored to an element in the UI.

```java
Popover popover = new Popover();
popover.setTarget(button);
popover.setWidth("300px");
popover.addThemeVariants(PopoverVariant.ARROW,
        PopoverVariant.LUMO_NO_PADDING);
popover.setPosition(PopoverPosition.BOTTOM);
popover.setAriaLabelledBy("notifications-heading");
```

Popovers support focusable, interactive content, and can be used to build virtually any type of anchored overlays from custom drop-down fields and drop-down buttons to and interactive tooltips.

The popover’s position is anchored to an element in the UI, called the  **target element**.

Popovers differ from  [Dialogs](https://vaadin.com/docs/latest/components/dialog)  in that they are visually anchored to a target element, and they differ from  [Tooltips](https://vaadin.com/docs/latest/components/tooltip)  in that they can be focused and support rich, interactive content.

## Opening and Closing

Popovers can be configured to open and close based on different pointer and keyboard based triggers. See  [Typical Use Cases](https://vaadin.com/docs/latest/components/popover#typical-use-cases)  for examples.

### Opening Triggers

Three target element triggers can be configured to open the popover:

-   **Click**: clicking the target element, or pressing  Space  when the target element has focus (**default**)

-   **Hover**: hovering over the target element

-   **Focus**: focusing the target element

```java
Popover popover = new Popover();
popover.setOpenOnClick(false);
popover.setOpenOnHover(true);
popover.setOpenOnFocus(true);
```

All three triggers can be enabled simultaneously. If no opening trigger is enabled, the popover can only be opened programmatically.

The hover and focus opening triggers have a configurable opening delay.

```java
Popover popover = new Popover();
popover.setHoverDelay(500);
popover.setFocusDelay(500);
```

### Closing Triggers

The following triggers close the popover by default:

-   **Target click**: Clicking the target element (non-modal popovers only)

-   **Outside click**: clicking anywhere outside the overlay (can be disabled)

-   **Esc**: pressing  Esc  (can be disabled)

```java
Popover popover = new Popover();
popover.setCloseOnEsc(false);
popover.setCloseOnOutsideClick(false);
```

Additionally:

-   When opened on hover, the popover closes on mouseout, i.e. when the pointer leaves the target element and the overlay.

-   When opened on focus, the popover closes on blur, i.e. when focus is no longer on the target element or in the overlay.


The mouseout closing trigger has a configurable delay.

```java
Popover popover = new Popover();
popover.setHideDelay(500);
```

### Auto Focus

Keyboard focus can be automatically moved to the Popover when it opens. This is recommended for popovers with interactive content that the user is expected to interact with. Modal popovers have auto-focus behavior by default. Popovers opened with hover or focus should not use auto-focus.

```java
Popover popover = new Popover();
popover.setAutofocus(true);
```

## Positioning

By default, popovers open below their target element, horizontally centered to its midpoint, but the positioning options allow this to be changed to any edge or corner, depending on what is most appropriate for the use case.

The popover’s position is automatically maintained if the target element scrolls within the viewport. If there is insufficient space in the viewport for the desired positioning, the popover automatically shifts to fit within the viewport.

```java
select.addValueChangeListener(event -> {
    PopoverPosition position = event.getValue();
    popover.setPosition(position);
});
```

### Target Gap

The distance between the popover and the target element can be customized by setting the following CSS properties on the Popover component:

-   `--vaadin-popover-offset-top`

-   `--vaadin-popover-offset-bottom`

-   `--vaadin-popover-offset-start`

-   `--vaadin-popover-offset-end`


### Target Arrow

Popovers can render a wedge-shaped arrow tip pointing at the target element.

```java
Popover popover = new Popover();
popover.addThemeVariants(PopoverVariant.ARROW);
```

## Configuring Delays

The delay before popover opens can be configured separately for hover and focus. There is no delay before the popover appears on click or when opening programmatically.

The delay before popover closes — when the pointer leaves the target element — can also be configured separately. On blur, though, the popover is closed immediately to avoid confusion when focusing another element.

```java
// Global delay configuration:
Popover.setDefaultFocusDelay(2000);
Popover.setDefaultHoverDelay(1000);
Popover.setDefaultHideDelay(1000);

// Overriding delays for a particular popover:
Popover popover = new Popover();
popover.setHoverDelay(0);
```

## Dimensions

By default, the Popover’s size is determined by its contents, but an explicit width and height can be set on the Popover itself.

Contents that exceed the width of the popover will scroll.

The maximum width of popovers is limited to the width of the viewport, minus a small margin that can be customized with CSS by overriding the  `inset`  property of the  `vaadin-popover-overlay`  element.

## Modality

A modal Popover blocks the user from interacting with the rest of the user interface while open, automatically moves focus from the target element to the Popover, and traps keyboard focus within it.

When combined with an outside click closing trigger, modality prevents accidentally triggering other UI elements when clicking outside the Popover to close it.

By default, modal popovers do not render a modality curtain (or  _backdrop_), but one can be enabled separately. A modality curtain can be useful for de-emphasizing the UI in the background and to give a visual indication that the rest of the UI is blocked from user interaction.


```java
Popover popover = new Popover();
popover.setModal(true);
popover.setBackdropVisible(true);
```

## Accessibility

By default, the Popover overlay has the ARIA role  `dialog`. This can be changed to another role to provide appropriate semantics for the type of content and interaction in the popover (see  [Typical Use Cases](https://vaadin.com/docs/latest/components/popover#typical-use-cases)  for examples).

-   `menu`: when the content is a list of actions or links

-   `listbox`: when the content is a list form which you can select one or more items

-   `grid`: when the content is a tabular structure from which you select an item

-   `tree`: when the content is a hierarchical list


Remember that, unlike  [Tooltip](https://vaadin.com/docs/latest/components/tooltip), the contents of a Popover are  _not_  automatically announced by screen readers when it opens. Consider using a live region to announce non-interactive popovers, and ensure keyboard access to interactive popovers.

The target element is automatically applied  `aria-controls`  (with a reference to the Popover overlay),  `aria-haspopup`  (with the overlay’s role as the value), and  `aria-expanded`  (set to  `true`  when open, and to  `false`  otherwise).

An accessible name can be provided for the overlay using the ARIA label API:

```java
Popover popover = new Popover();
popover.setAriaLabel("Label");
// OR
popover.setAriaLabelledby("label-element-id");
```

## Typical Use Cases

Here are a few examples of common use cases for the Popover component with recommended configurations.

### Drop-Down Field

```java
TextField field = new TextField("Search date range");
field.setWidth("340px");
Icon icon = LumoIcon.DROPDOWN.create();
field.setSuffixComponent(icon);

popover = new Popover();
popover.setModal(true);
popover.setWidth("325px");
popover.setAriaLabel("Select a date range");
popover.setOpenOnFocus(true);
popover.setFocusDelay(0);
popover.setTarget(field);
```

-   Opens on click, focus

-   Closes on  Esc, blur, outside click, target click, and programmatically upon selection

-   Modal, no modality curtain (drop-down fields typically don’t have curtains)

-   Auto-focused

-   ARIA role  `dialog`

-   ARIA label  _“Select a date range”_


### User Menu

```java
String name = person.getFirstName() + " " + person.getLastName();
String pictureUrl = person.getPictureUrl();

Avatar avatar = new Avatar(name);
avatar.setImage(pictureUrl);
avatar.getStyle().set("display", "block");
avatar.getElement().setAttribute("tabindex", "-1");

Button button = new Button(avatar);
button.addThemeVariants(ButtonVariant.LUMO_ICON,
        ButtonVariant.LUMO_TERTIARY_INLINE);
button.getStyle().set("margin", "var(--lumo-space-s)");
button.getStyle().set("margin-inline-start", "auto");
button.getStyle().set("border-radius", "50%");

Popover popover = new Popover();
popover.setModal(true);
popover.setOverlayRole("menu");
popover.setAriaLabel("User menu");
popover.setTarget(button);
```

-   Opens on click

-   Closes on  Esc, outside click, target click

-   Modal, no modality curtain (small popovers like this usually don’t need them)

-   ARIA role  `menu`  (the overlay’s content is a menu; although there are non-list elements, they are not interactive, nor do they need to be announced by screen readers)

-   ARIA label  _“User menu”_


Note: if the popover only needs to contain menu items, consider using a  [Menu Bar](https://vaadin.com/docs/latest/components/menu-bar)  or  [Context Menu](https://vaadin.com/docs/latest/components/context-menu)  instead.

### Notification Panel

```java
Popover popover = new Popover();
popover.setTarget(button);
popover.setWidth("300px");
popover.addThemeVariants(PopoverVariant.ARROW,
        PopoverVariant.LUMO_NO_PADDING);
popover.setPosition(PopoverPosition.BOTTOM);
popover.setAriaLabelledBy("notifications-heading");
```

-   Opens on click

-   Closes on  Esc, outside click, target click

-   Modal, no modality curtain (small popovers like this usually don’t need them)

-   ARIA role  `dialog`  (although mainly a list, there interactive non-list elements as well)

-   ARIA labelled-by pointing to heading in overlay

-   Arrow variant


### Rich, Interactive Tooltip

```java
IntegerField cvv = new IntegerField("CVV");
cvv.setWidth("60px");

Popover popover = new Popover();
popover.addThemeVariants(PopoverVariant.ARROW);
popover.setPosition(PopoverPosition.TOP);
popover.setOpenOnClick(false);
popover.setOpenOnHover(true);
popover.setOpenOnFocus(true);

H3 header = new H3("Card Verification Value");
header.setId("cvv-heading");
header.getStyle().set("margin", "0");
header.getStyle().set("font-size", "1rem");

Div content = new Div(
        "A three or four digit code, usually printed on the back of the card, "
                + "next to, or at the end of, the signature strip.");
content.getStyle().set("max-width", "300px");

Anchor link = new Anchor("https://www.cvvnumber.com/cvv.html",
        "See where to find CVV on different cards", AnchorTarget.BLANK);

popover.add(header, content, link);
popover.setAriaLabelledBy("cvv-heading");
popover.setTarget(cvv);

add(cvv, popover);
```

-   Opens on hover, focus

-   Closes on  Esc, outside click (as well as mouseout and blur)

-   Non-modal

-   Not auto-focused

-   ARIA role  `dialog`  (`tooltip`  would be invalid due to interactive contents)

-   ARIA labelled-by pointing to heading in overlay

-   Positioned above target

-   Arrow variant


### Anchored Modal Dialog
```java
Popover popover = new Popover();
popover.setModal(true);
popover.setBackdropVisible(true);
popover.setPosition(PopoverPosition.BOTTOM_END);
popover.setTarget(button);

H4 heading = new H4("Configure columns");
heading.getStyle().set("margin", "0");

List<String> columns = List.of("firstName", "lastName", "email",
        "phone", "birthday", "profession");

CheckboxGroup<String> group = new CheckboxGroup<>();
group.addThemeVariants(CheckboxGroupVariant.LUMO_VERTICAL);
group.setItems(columns);
group.setItemLabelGenerator((item) -> {
    String label = StringUtils
            .join(StringUtils.splitByCharacterTypeCamelCase(item), " ");
    return StringUtils.capitalize(label.toLowerCase());
});
group.addValueChangeListener((e) -> {
    columns.stream().forEach((key) -> {
        grid.getColumnByKey(key).setVisible(e.getValue().contains(key));
    });
});

Set<String> defaultColumns = Set.of("firstName", "lastName", "email",
        "profession");
group.setValue(defaultColumns);

Button showAll = new Button("Show all", (e) -> {
    group.setValue(new HashSet<String>(columns));
});

Button reset = new Button("Reset", (e) -> {
    group.setValue(defaultColumns);
});

HorizontalLayout footer = new HorizontalLayout(showAll, reset);
footer.setSpacing(false);
footer.getThemeList().add("spacing-xs");

popover.add(heading, group, footer);
```

-   Opens on click

-   Closes on  Esc, outside click

-   Modal, with curtain

-   Auto-focused

-   ARIA role  `dialog`

-   ARIA labelled-by pointing to heading in the overlay


Note: if the dialog doesn’t benefit from being anchored-positioned to another element, consider using a  [Dialog](https://vaadin.com/docs/latest/components/dialog)  instead.

# Progress Bar

Progress Bar shows the amount of completion of a task or process. The progress can be determinate or indeterminate. Use Progress Bar to show an ongoing process that takes a noticeable time to finish.

```java
ProgressBar progressBar = new ProgressBar();
progressBar.setValue(0.5);
add(progressBar);
```

Global loading indicator

A global loading indicator shows at the top of the viewport while processing a server request, after a configurable delay. You don’t need to provide an explicit Progress Bar for these situations.

## Modes

### Determinate

Use a determinate Progress Bar when progress can be computed.

```java
ProgressBar progressBar = new ProgressBar();
progressBar.setValue(0.5);
```

### Indeterminate

Use an indeterminate Progress Bar to show that progress is ongoing but can’t be computed.

```java
ProgressBar progressBar = new ProgressBar();
progressBar.setIndeterminate(true);
```

## Bounds and Initial Value

The progress value defaults to a range from 0 to 1, with an initial value of 0. These can be changed to any numeric values:


```java
ProgressBar progressBar = new ProgressBar();
progressBar.setMin(0);
progressBar.setMax(100);
progressBar.setValue(50);
```

## Theme Variants

Progress Bar comes with three theme variants: contrast, success, and error.

```java
// Contrast
ProgressBar progressBarContrast = new ProgressBar();
progressBarContrast.addThemeVariants(ProgressBarVariant.LUMO_CONTRAST);
progressBarContrast.setValue(0.5);

// Success
ProgressBar progressBarSuccess = new ProgressBar();
progressBarSuccess.addThemeVariants(ProgressBarVariant.LUMO_SUCCESS);
progressBarSuccess.setValue(0.75);

// Error
ProgressBar progressBarError = new ProgressBar();
progressBarError.addThemeVariants(ProgressBarVariant.LUMO_ERROR);
progressBarError.setValue(0.2);
```

Variant

Theme name

Usage recommendations

Success

success

* When progress is satisfactory and/or nearing completion

* Visual preference

Error

error

* When progress is unsatisfactory

* Draw the user’s attention to a stalled or failed process

Contrast

contrast

* Visual preference

## Best Practices

### Provide a Label

Use labels to give context to a Progress Bar. Labels can also show the progress of a determinate progress bar in text in addition to a graphical representation, for example the percentage of completion, or the number of items processed.

```java
ProgressBar progressBar = new ProgressBar();
progressBar.setValue(0.5);

NativeLabel progressBarLabelText = new NativeLabel(
        "Processing Financials.xlsx");
progressBarLabelText.setId("pblabel");
// Associates the label with the progressbar for screen readers:
progressBar.getElement().setAttribute("aria-labelledby", "pblabel");

Span progressBarLabelValue = new Span("50%");
HorizontalLayout progressBarLabel = new HorizontalLayout(
        progressBarLabelText, progressBarLabelValue);
progressBarLabel.setJustifyContentMode(JustifyContentMode.BETWEEN);

add(progressBarLabel, progressBar);
```

### State Switching

Switch from indeterminate to determinate if the progress becomes computable, and similarly from determinate to indeterminate if it becomes non-computable.

### Estimate Completion Time

Provide estimates when possible. If a process takes approximately 20 minutes, communicate that to the user.

```java
ProgressBar progressBar = new ProgressBar();
progressBar.setIndeterminate(true);

NativeLabel progressBarLabel = new NativeLabel("Generating report...");
progressBarLabel.setId("pblbl");
progressBarLabel.addClassName(LumoUtility.TextColor.SECONDARY);

Span progressBarSubLabel = new Span(
        "Process can take upwards of 10 minutes");
progressBarSubLabel.setId("sublbl");
progressBarSubLabel.addClassNames(LumoUtility.TextColor.SECONDARY,
        LumoUtility.FontSize.XSMALL);

// Associates the labels with the bar programmatically, for screen
// readers:
progressBar.getElement().setAttribute("aria-labelledby", "pblbl");
progressBar.getElement().setAttribute("aria-describedby", "sublbl");

add(progressBarLabel, progressBar, progressBarSubLabel);
```

### Asynchronous Processes

If the user is waiting for a process to finish, consider using a Notification to notify them upon its completion and/or failure. This is useful if the processing takes place “off-screen” or the user is doing other work while waiting.

Avoid blocking processes

Use asynchronous processes whenever possible so as not to block the user from completing other tasks while waiting for the process to finish.

### When to Use

If a backend process takes longer than 1 second, use a Progress Bar to show the user that something is happening, especially if it blocks the user’s workflow.

### Placement

A Progress Bar’s location in the UI implies its scope and whether the surrounding UI is operable during its progression.

For example, a Vaadin application’s built-in loading indicator is placed at the top of the viewport to show that it affects the entire application. The UI is not operable during pending server requests.

Placing a Progress Bar in a dialog, details panel or an otherwise defined section implies that the process displayed is specific to that section. Depending on the use case, the user may or may not be able to interact with the UI.

# Radio Button

API:  [TypeScript](https://cdn.vaadin.com/vaadin-web-components/24.5.0-alpha11/#/elements/vaadin-radio-group)  /  [Java](https://vaadin.com/api/platform/24.5.0.alpha15/com/vaadin/flow/component/radiobutton/RadioButtonGroup.html)

Source:  [TypeScript](https://github.com/vaadin/web-components/tree/v24.5.0-alpha11/packages/radio-group)  /  [Java](https://github.com/vaadin/flow-components/tree/24.5.0.alpha15/vaadin-radio-button-flow-parent)

-   Usage
-   [Styling](https://vaadin.com/docs/latest/components/radio-button/styling)

-   [States](https://vaadin.com/docs/latest/components/radio-button#states)
-   [Orientation](https://vaadin.com/docs/latest/components/radio-button#orientation)
-   [Custom Item Presentation](https://vaadin.com/docs/latest/components/radio-button#custom-item-presentation)
-   [Basic Features](https://vaadin.com/docs/latest/components/radio-button#basic-features)
-   [Style Variants](https://vaadin.com/docs/latest/components/radio-button#style-variants)
-   [Best Practices](https://vaadin.com/docs/latest/components/radio-button#best-practices)
-   [Related Components](https://vaadin.com/docs/latest/components/radio-button#related-components)

Radio Button Group allows users to select one value among multiple choices.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-basic-wc.js&import=component/radiobutton/radio-button-basic.ts,component/radiobutton/react/radio-button-basic.tsx)

Hide code

LitFlowReact

RadioButtonBasic.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> radioGroup = new RadioButtonGroup<>();
radioGroup.addThemeVariants(RadioGroupVariant.LUMO_VERTICAL);
radioGroup.setLabel("Travel class");
radioGroup.setItems("Economy", "Business", "First Class");
add(radioGroup);
```

## [](https://vaadin.com/docs/latest/components/radio-button#states)States

### [](https://vaadin.com/docs/latest/components/radio-button#read-only)Read-Only

Use read-only when content needs to be accessible but not editable. Read-only elements can’t be edited, but they’re part of the tabbing order and can thus receive focus. The content of a read-only input can be selected and copied.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-readonly-wc.js&import=component/radiobutton/radio-button-readonly.ts,component/radiobutton/react/radio-button-readonly.tsx)

Hide code

LitFlowReact

RadioButtonReadonly.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> radioGroup = new RadioButtonGroup<>();
radioGroup.setLabel("Status");
radioGroup.setItems("In progress", "Done", "Cancelled");
radioGroup.setValue("In progress");
radioGroup.setReadOnly(true);
add(radioGroup);
```

### [](https://vaadin.com/docs/latest/components/radio-button#disabled)Disabled

Disable a field to mark it as currently unavailable. The disabled state is used for fields that aren’t editable and don’t need to be readable. Disabled elements can’t be focused and may be inaccessible to assistive technologies such as screen readers.

Disabling can be preferable to hiding an element to prevent changes in layout when the element’s visibility changes, and to make users aware of its existence even when it’s currently unavailable.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-disabled-wc.js&import=component/radiobutton/radio-button-disabled.ts,component/radiobutton/react/radio-button-disabled.tsx)

Hide code

LitFlowReact

RadioButtonDisabled.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> radioGroup = new RadioButtonGroup<>();
radioGroup.setLabel("Status");
radioGroup.setItems("In progress", "Done", "Cancelled");
radioGroup.setValue("In progress");
radioGroup.setEnabled(false);
add(radioGroup);
```

## [](https://vaadin.com/docs/latest/components/radio-button#orientation)Orientation

The component’s default orientation is horizontal. However, vertical orientation is recommended whenever possible, since it’s generally easier for the user to scan a vertical list of options:

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-vertical-wc.js&import=component/radiobutton/radio-button-vertical.ts,component/radiobutton/react/radio-button-vertical.tsx)

Hide code

LitFlowReact

RadioButtonVertical.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> radioGroup = new RadioButtonGroup<>();
radioGroup.addThemeVariants(RadioGroupVariant.LUMO_VERTICAL);
radioGroup.setLabel("Status");
radioGroup.setItems("Pending", "Submitted", "Confirmed");
radioGroup.setValue("Pending");
add(radioGroup);
```

In cases where vertical space needs to be conserved, horizontal orientation can be used. However, it’s recommended that there be no more than three options:

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-horizontal-wc.js&import=component/radiobutton/radio-button-horizontal.ts,component/radiobutton/react/radio-button-horizontal.tsx)

Hide code

LitFlowReact

RadioButtonHorizontal.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> radioGroup = new RadioButtonGroup<>();
radioGroup.setLabel("Status");
radioGroup.setItems("Pending", "Submitted", "Confirmed");
radioGroup.setValue("Pending");
add(radioGroup);
```

In cases where more options are needed, the Select component can be used instead.

## [](https://vaadin.com/docs/latest/components/radio-button#custom-item-presentation)Custom Item Presentation

Items can be customized to include more than a single line of text:

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-presentation-wc.js&import=component/radiobutton/radio-button-presentation.ts,component/radiobutton/react/radio-button-presentation.tsx)

Hide code

LitFlowReact

RadioButtonPresentation.javaCard.javaDataService.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<Card> radioGroup = new RadioButtonGroup<>();
radioGroup.addThemeVariants(RadioGroupVariant.LUMO_VERTICAL);
radioGroup.setLabel("Payment method");

List<Card> cards = DataService.getCards();
radioGroup.setItems(cards);
radioGroup.setValue(cards.get(0));
radioGroup.setRenderer(new ComponentRenderer<>(card -> {
    Image logo = new Image(card.getPictureUrl(), card.getName());
    logo.setHeight("1em");
    Span number = new Span(new Text(card.getAccountNumber()));
    Text expiryDate = new Text("Expiry date:" + card.getExpiryDate());

    return new Div(new HorizontalLayout(logo, number),
            new Div(expiryDate));
}));

add(radioGroup);
```

## [](https://vaadin.com/docs/latest/components/radio-button#basic-features)Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/radio-button#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/radio-button#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/radio-button#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/radio-button#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

HTMLJava

,Copyto clipboard

```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-radio-button-group accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-radio-button-group accessible-name="This is the label">...
```

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-group-basic-features-wc.js&import=component/radiobutton/radio-button-group-basic-features.ts,component/radiobutton/react/radio-button-group-basic-features.tsx)

Hide code

LitFlowReact

RadioButtonGroupBasicFeatures.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> field = new RadioButtonGroup<>();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setTooltipText("Tooltip text");
```

## [](https://vaadin.com/docs/latest/components/radio-button#style-variants)Style Variants

The following style variants can be applied:

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-group-styles-wc.js&import=component/radiobutton/radio-button-group-styles.ts,component/radiobutton/react/radio-button-group-styles.tsx)

Hide code

LitFlowReact

RadioButtonGroupStyles.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> field = new RadioButtonGroup<>();
field.addThemeVariants(RadioGroupVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## [](https://vaadin.com/docs/latest/components/radio-button#best-practices)Best Practices

### [](https://vaadin.com/docs/latest/components/radio-button#group-labels)Group Labels

It’s important to provide labels for Radio Button Groups to distinguish them from each other, especially with multiple adjacent groups.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-group-labels-wc.js&import=component/radiobutton/radio-button-group-labels.ts,component/radiobutton/react/radio-button-group-labels.tsx)

Hide code

LitFlowReact

RadioButtonGroupLabels.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<String> jobTitleGroup = new RadioButtonGroup<>();
jobTitleGroup.addThemeVariants(RadioGroupVariant.LUMO_VERTICAL);
jobTitleGroup.setLabel("Job title");
jobTitleGroup.setItems("Analyst", "Administrator", "Engineer");
jobTitleGroup.setValue("Analyst");
add(jobTitleGroup);

RadioButtonGroup<String> departmentGroup = new RadioButtonGroup<>();
departmentGroup.addThemeVariants(RadioGroupVariant.LUMO_VERTICAL);
departmentGroup.setLabel("Department");
departmentGroup.setItems("Engineering", "Human Resources", "Marketing");
departmentGroup.setValue("Engineering");
add(departmentGroup);
```

### [](https://vaadin.com/docs/latest/components/radio-button#custom-option)Custom Option

To enable the user to enter a custom option instead of picking one from the list, use an "Other" radio button choice at the bottom of the list with an associated Text Field for entry. The field should be hidden or disabled until the "Other" option is selected.

[Open in a
new tab](https://vaadin.com/docs/latest/example?embed=radio-button-custom-option-wc.js&import=component/radiobutton/radio-button-custom-option.ts,component/radiobutton/react/radio-button-custom-option.tsx)

Payment method

![Visa](data:image/png;base64,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)**** **** **** 1234

![Mastercard](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAwCAMAAACIXLyeAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABsUExURUdwTOwAG/mIIPifG+wAG+wAG/eeG+sAG/tFJ/leIO0AHO0AHPqgHfieG/eeG+wAG/mgHfieG/ifG/ifG+wAG/ieG/mgHOwAG/tOCusAG/eeG/9fAP5rBfmXGPYxDf15C/IcE/pECP5VA/qLE2jxkIMAAAAZdFJOUwBsIZPfsu/wCRQ7Vy/gx8w/tWp9hqVZmOTex8qZAAABoklEQVRIx62XWXLDIBBEEWLXvhvkJE5y/ztG3mLZQgOU6V9VvaJpBNMIvUpkEyVcc1LRXonXr3k7lAUzrCiHViKXZEL1Wpxmq6/1wMxaZYdBWM/1RiS5LXEszVbDLlAkFtgFqM4ubbBFLLV7xpXe1SQ7sytWW2iKa0CHDwOo3dASCKa/5yPISwNpcxBPOWku3tov5m7awoNw5pGHqCDaab7rC8Ix7LdxP/+4GbQ73BcHWv180Bx28yuuBxc3r/UL4Zrrj+q9OK80vHfOuXuXw0f9YvUItwgKwiuMLMSrw22H0OSfqzPbMnDrHDiGEAnDgVkYiYKScOEw0jFxeejqju/gTsFmo0YhYh+UPu4xjvyTRb4CIl9QYW7d12e8yz33eBf9c729jILEeRhx1Gf7MfVEGSqkFLepV3rZdeWA69pr9PQZyManAS+LOi4uPP7OMNttR21w/w5gCqOtowD59qJl+79qbu8pGQFqCm52ltaJoN5T3VtZbQOmYM8TGeXPFU+t62JaPA+IHqVRqJ5W5Nw/p0Rtq9aYNksDLcomHS0u/wCadzZdj+ddpQAAAABJRU5ErkJggg==)**** **** **** 7890

![American Express](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURRV70wBvz/////D3/CaF10eX3Xq05pPC69bp+KfO7zuR21ih4Ap10rza82iq41FJ1oUAAAABdFJOU/2D6lbHAAABpUlEQVQ4y2OQwQ5EGASxA4FRCRIkBFx8XFxEXKDAkcUFyPdxcRBgkFXSVFJKUoICCyDWBEEBBqesJtW1uqtVVy2vWlqUqbsrKcqo65FVpwBDhdQjHT5VFp3cGwnTzy7rCb8pldQo2QiUMPM4rPPA5onO6r0JM88uK1DSimRqXACSMNjJrjPnSYlOWG4iY9GyEqXGlycbGwKBEjWhC3Rmi5cAjUoxebSs8cWDUK9GS0GgRJiSyZW7HLNUGNhLNTy3a671VGqYYLQBKKF0SwnJrcZKSqlKSrog54Y6Lg2FgoDQ0IUuLgeBXgwNITcQHxsbG9tdNkYGFmCJ5N277xVZz4uKtd6dfHv35rZ3l+ueQSTEynslQ0zCYhqfec8pL2Z91+r3EiIhndZUyKFSNLGxdvectGSxGVo7L0MkRHc3XXRWETzWeHDFnN2bpq6ZsZUbIiHZYcHmrVKs1HjbeU5Hk7HpY+MUiISgYOmmnpLizMampRMFJQQFugSPgyVAEahhpKQsp6QMChpjI2VjZbDEsrS0tISwtDyp8tJyKHg1mj9IkMABWAD0UMnWDyQ8pAAAAABJRU5ErkJggg==)**** **** **** 5432

Other

Hide code

LitFlowReact

RadioButtonCustomOption.java

Expand code,Copyto clipboard

```java
RadioButtonGroup<Card> radioGroup = new RadioButtonGroup<>();
radioGroup.addThemeVariants(RadioGroupVariant.LUMO_VERTICAL);
radioGroup.setLabel("Payment method");

List<Card> cards = new ArrayList<>(DataService.getCards());
Card other = new Card();
other.setId(-1);
cards.add(other);
radioGroup.setItems(cards);
radioGroup.setValue(cards.get(0));

radioGroup.setRenderer(new ComponentRenderer<>(card -> {
    if (other.equals(card)) {
        return new Text("Other");
    } else {
        Image logo = new Image(card.getPictureUrl(), card.getName());
        logo.setHeight("1em");
        Span number = new Span(new Text(card.getAccountNumber()));
        return new HorizontalLayout(logo, number);
    }
}));

TextField textField = new TextField("Card number");
textField.setVisible(false);
radioGroup.addValueChangeListener(
        e -> textField.setVisible(other.equals(e.getValue())));

add(radioGroup, textField);
```

### [](https://vaadin.com/docs/latest/components/radio-button#default-value-blank-option)Default Value & Blank Option

It’s recommended that you set the most common option as the default value for Radio Button Groups. Place the default option at the top of the list.

In cases where it’s important that the user make a conscious choice, the Radio Button Group should be blank by default.

In situations where the user isn’t required to select a value, use a "blank" option:

Repeat

None

Daily

Weekly

Monthly

### Alternative to Checkbox

Two Radio Buttons can sometimes be a good alternative to a single Checkbox. If the Checkbox doesn’t represent a simple yes/no choice, and its label can’t clearly communicate the meaning of its unchecked state, it’s better to use a Radio Button Group with two options:

Reply All by default (unchecked state not clear)

Default reply behavior

Reply

Reply to all

In a Horizontal Layout, Radio Button Groups also align better with other input fields than a single checkbox.

# Scroller
Scroller is a component container for creating scrollable areas in the UI.
```java
// Personal information
H3 personalTitle = new H3("Personal information");
personalTitle.setId(PERSONAL_TITLE_ID);

TextField firstName = new TextField("First name");
firstName.setWidthFull();

TextField lastName = new TextField("Last name");
lastName.setWidthFull();

DatePicker birthDate = new DatePicker("Birthdate");
birthDate.setInitialPosition(LocalDate.of(1990, 1, 1));
birthDate.setWidthFull();

Section personalInformation = new Section(personalTitle, firstName,
        lastName, birthDate);
personalInformation.getElement().setAttribute("aria-labelledby",
        PERSONAL_TITLE_ID);

// Employment information
H3 employmentTitle = new H3("Employment information");
employmentTitle.setId(EMPLOYMENT_TITLE_ID);

TextField position = new TextField("Position");
position.setWidthFull();

TextArea additionalInformation = new TextArea("Additional Information");
additionalInformation.setWidthFull();

Section employmentInformation = new Section(employmentTitle, position,
        additionalInformation);
employmentInformation.getElement().setAttribute("aria-labelledby",
        EMPLOYMENT_TITLE_ID);

// NOTE
// We are using inline styles here to keep the example simple.
// We recommend placing CSS in a separate style sheet and to
// encapsulating the styling in a new component.
Scroller scroller = new Scroller(
        new Div(personalInformation, employmentInformation));
scroller.setScrollDirection(Scroller.ScrollDirection.VERTICAL);
scroller.getStyle()
        .set("border-bottom", "1px solid var(--lumo-contrast-20pct)")
        .set("padding", "var(--lumo-space-m)");
add(scroller);
```

## Scroll Direction

Scroller has four different scroll directions:  **vertical**,  **horizontal**,  **both**, and  **none**. Scroller’s default scroll direction is  **both**.

### Vertical

When the scroll position is vertical, the user can scroll vertically if the content overflows the container vertically. Content that overflows horizontally is clipped and inaccessible, so the width of the content should be 100%.

### Horizontal

When the scroll position is horizontal, the user can scroll horizontally if the content overflows the container horizontally. Content that overflows vertically is clipped and inaccessible, so the height of the content should be 100%.

Use horizontal scrolling with caution, as it’s much less common and may be difficult for users to recognize and use, in particular on non-mobile devices.

#### Desktop

Excluding Grids, horizontal scrolling isn’t commonly used in desktop and/or business applications, as it can be non-obvious and cumbersome to use.

It’s recommended to use Buttons to help users notice and navigate horizontally scrollable sections. For horizontally scrollable lists, it’s considered good practice to display the number of items there are in the list, and which items the user is currently viewing.

#### Mobile

Scrolling horizontally or swiping is more common on mobile, for example for navigation purposes. It can also be used to conserve vertical space, for example in situations where the user is exploring less-important information, such as shortcuts or images.

```java
Scroller scroller = new Scroller();
scroller.setScrollDirection(Scroller.ScrollDirection.HORIZONTAL);

Button auditBtn = new Button("Audit");
auditBtn.setIcon(new Icon(VaadinIcon.CLIPBOARD_CHECK));
auditBtn.setHeight("100px");

Button reportBtn = new Button("Report");
reportBtn.setIcon(new Icon(VaadinIcon.BOOK_DOLLAR));
reportBtn.setHeight("100px");

Button dashboardBtn = new Button("Dashboard");
dashboardBtn.setIcon(new Icon(VaadinIcon.LINE_CHART));
dashboardBtn.setHeight("100px");

Button invoiceBtn = new Button("Invoice");
invoiceBtn.setIcon(new Icon(VaadinIcon.INVOICE));
invoiceBtn.setHeight("100px");

HorizontalLayout buttons = new HorizontalLayout(auditBtn, reportBtn,
        dashboardBtn, invoiceBtn);
buttons.setPadding(true);
buttons.getStyle().set("display", "inline-flex");

scroller.setContent(buttons);
add(scroller);
```

### Both

When the scroll position is  **Both**  (default), the user can scroll vertically and horizontally if the content overflows in both directions.

This scroll direction is best suited to allowing the user to pan around large elements, such as images. It can also be used as a fallback for a responsive layout that can’t be guaranteed not to overflow in some situations.

```java
Scroller scroller = new Scroller();
scroller.setWidthFull();
scroller.setHeight("300px");

StreamResource imageResource = new StreamResource("reindeer+.jpg",
        () -> getClass().getResourceAsStream("/images/reindeer.jpg"));

Image img = new Image(imageResource,
        "A reindeer walking on a snowy lake shore at dusk");
scroller.setContent(img);

add(scroller);
```

### None

Use  **None**  to hide content that overflows in either direction. No scrollbars are available to the user to access the clipped content.  **None**  can be used in fixed-size/fixed-layout situations, where overflow would cause issues.

# Select
Select allows users to choose a single value from a list of options presented in an overlay.

```java
Select<String> select = new Select<>();
select.setLabel("Sort by");
select.setItems("Most recent first", "Rating: high to low",
        "Rating: low to high", "Price: high to low",
        "Price: low to high");
select.setValue("Most recent first");

add(select);
```

The drop-down menu can be opened with a click, up and down arrow keys, or by typing the initial character of one of the options.

## Dividers

Dividers can be used to group related options. Use dividers sparingly to avoid creating unnecessary visual clutter.

```java
Select<String> select = new Select<>();
select.setLabel("Sort by");
select.setItems("Most recent first", "Rating: high to low",
        "Rating: low to high", "Price: high to low",
        "Price: low to high");
select.addComponents("Most recent first", new Hr());
select.addComponents("Rating: low to high", new Hr());
select.setValue("Most recent first");

add(select);
```

For large data sets, it’s preferable to use Combo Box instead of Select. This allows users to filter the list of options.

## Disabled Items

Items can be disabled. This prevents users from selecting them, while still showing that the items would be available for selection under different circumstances.

```java
Select<String> select = new Select<>();
select.setLabel("Size");
select.setItems("XS (out of stock)", "S", "M", "L", "XL");
select.setItemEnabledProvider(
        item -> !"XS (out of stock)".equals(item));
select.setValue("XL");

add(select);
```

Accessibility

Some assistive technologies might not announce disabled options.

## Overlay

You can customize the position and the width of the Select overlay, where the list of options is rendered. You can also add CSS class names to the overlay to customize its styles.

### Overlay Position

The overlay is shown on top of the input field by default. You can configure the placement so that it doesn’t cover the input field.

```java
Select<String> select = new Select<>();
select.setNoVerticalOverlap(true);
```

### Overlay Width

The overlay is as wide as the options in it and at least as wide as the input field. The overlay width can be overridden to any fixed width in cases where the default width is too narrow.

```java
Select<Person> select = new Select<>();
select.setOverlayWidth("350px");
```

### Overlay Class Name

Like other field components with overlays, Select provides dedicated API to set a CSS class name on the overlay for styling. See  [Styling Component Instances](https://vaadin.com/docs/latest/styling/styling-components/styling-component-instances)  for more information.

```java
Select<String> select = new Select<>();
select.addOverlayClassName("locales");
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/select#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/select#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/select#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/select#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Prefix

A prefix element — rendered at the start of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/select#label), a  [Helper](https://vaadin.com/docs/latest/components/select#helper)  or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-select accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-select accessible-name="This is the label">...
```

```java
Select<String> field = new Select<>();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setPrefixComponent(VaadinIcon.VAADIN_H.create());
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
Select<String> readonlyField = new Select<>();
readonlyField.setReadOnly(true);
Select<String> disabledField = new Select<>();
disabledField.setEnabled(false);
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
Select<String> field = new Select<>();
field.addThemeVariants(SelectVariant.LUMO_SMALL,
        SelectVariant.LUMO_ALIGN_RIGHT,
        SelectVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Placeholder

Use the placeholder feature to provide an inline text prompt for the field. Don’t create or use a separate item for this purpose.

```java
Select<String> select = new Select<>();
select.setLabel("Size");
select.setItems("XS", "S", "M", "L", "XL");
select.setPlaceholder("Select size");

add(select);
```

## Empty Selection Item (Flow)

An empty item can be set as the first option. Use it in cases where you want to allow users to clear their selection. The value of the empty item is represented as  `null`.

```java
select.setEmptySelectionAllowed(true);
```

### Customizing Empty Selection Caption

The label for the empty item is customizable. The caption that you set replaces the placeholder for the empty selection item.

```java
select.setEmptySelectionAllowed(true);
select.setEmptySelectionCaption("Unknown size");
```

## Custom Item Label

When using complex values, a label can be set to represent the item value as plain text.
```java
Select<Person> select = new Select<>();
select.setLabel("Assignee");
// Display full name of the person as item text and selected value label
select.setItemLabelGenerator(Person::getFullName);

List<Person> people = DataService.getPeople(5);
select.setItems(people);
```

When using custom item renderers with rich content, a label can be set to represent the item value when it’s selected.

```java
Select<Person> select = new Select<>();
select.setLabel("Assignee");
// Use a custom renderer for items in the dropdown
select.setRenderer(SelectCustomRendererLabel.createPersonRenderer());
// Display full name of the person as selected value label
select.setItemLabelGenerator(Person::getFullName);

List<Person> people = DataService.getPeople(5);
select.setItems(people);
```

Flow-Specific

When using  `setItemLabelGenerator()`  in combination with  `setEmptySelectionAllowed()`, ensure that the implementation is capable of handling null values, as the empty selection item has the value  `null`.

```java
select.setEmptySelectionAllowed(true);
select.setItemLabelGenerator(person -> {
  if (person == null) {
      return "No assignee";
  }
  return person.getFullName();
});
```

The same applies when using a data source that may contain null values.

## Custom Item Presentation

Items can be rendered with rich content instead of plain text. This can be useful to provide information in a more legible fashion than appending it to the item text.

```java
Select<Person> select = new Select<>();
select.setLabel("Choose doctor");
select.setRenderer(new ComponentRenderer<>(person -> {
    FlexLayout wrapper = new FlexLayout();
    wrapper.setAlignItems(Alignment.CENTER);

    // NOTE
    // We are using inline styles here to keep the example simple.
    // We recommend placing CSS in a separate style sheet and to
    // encapsulating the styling in a new component.

    Image image = new Image();
    image.setSrc(person.getPictureUrl());
    image.setAlt("Portrait of " + person.getFirstName() + " "
            + person.getLastName());
    image.setWidth("var(--lumo-size-m)");
    image.getStyle().set("margin-right", "var(--lumo-space-s)");

    Div info = new Div();
    info.setText(person.getFirstName() + " " + person.getLastName());

    Div profession = new Div();
    profession.setText(person.getProfession());
    profession.getStyle().set("font-size", "var(--lumo-font-size-s)");
    profession.getStyle().set("color",
            "var(--lumo-secondary-text-color)");
    info.add(profession);

    wrapper.add(image, info);
    return wrapper;
}));
select.setItems(items);
add(select);
```

## Best Practices

### Set a Default Value

Where applicable, set the most common choice as the default value.

### Don’t Use as a Menu

Select is an input field component, not a generic menu component. Use  [Menu Bar](https://vaadin.com/docs/latest/components/menu-bar)  to create overlays for actions.

# Side Navigation
Side Navigation provides a vertical list of navigation links with support for collapsible, nested sections.

Navigation Disabled in Examples

For technical reasons, actual navigation is disabled in the examples on this page.
```java
SideNav nav = new SideNav();

SideNavItem dashboardLink = new SideNavItem("Dashboard",
        DashboardView.class, VaadinIcon.DASHBOARD.create());
SideNavItem inboxLink = new SideNavItem("Inbox", InboxView.class,
        VaadinIcon.ENVELOPE.create());
SideNavItem calendarLink = new SideNavItem("Calendar",
        CalendarView.class, VaadinIcon.CALENDAR.create());
SideNavItem settingsLink = new SideNavItem("Settings",
        SettingsView.class, VaadinIcon.COG.create());
SideNavItem vaadinLink = new SideNavItem("Vaadin website",
        "https://vaadin.com", VaadinIcon.VAADIN_H.create());

nav.addItem(dashboardLink, inboxLink, calendarLink, settingsLink,
        vaadinLink);
```

The Side Navigation component can be used, for example, in a drawer of an  [App Layout](https://vaadin.com/docs/latest/components/app-layout).

## Automatic Highlighting of Current Item

The navigation item matching the current URL is highlighted automatically to indicate it’s active.

### Nested Matching

By default, items only match the exact path of the current URL. To enable matching of nested paths or routes, set the  `matchNested`  property to  `true`. With nested matching, an item with the path  `/parent`  not only matches  `/parent`, but also  `/parent/child`,  `/parent/child/grandchild`, etc.

```java
SideNavItem item = new SideNavItem("Users", "/users");
item.setMatchNested(true);
```

### Query Parameters

If an item’s path contains  [query parameters](https://vaadin.com/docs/latest/flow/routing/additional-guides/query-parameters), only URLs containing those parameters are considered a match. Additional parameters in the URL not specified in the item path are ignored — the URL is considered a match.

## Prefix & Suffix Elements

Navigation items have slots for prefix and suffix elements. The prefix slot is intended primarily for icons, while the suffix slot can be used, for example, for notification badges.

Interactive prefix and suffix elements aren’t recommended since the entire item row acts as a link.

```java
SideNav nav = new SideNav();

SideNavItem inboxLink = new SideNavItem("Inbox", InboxView.class,
        VaadinIcon.ENVELOPE.create());
Span inboxCounter = new Span("12");
inboxCounter.getElement().getThemeList().add("badge contrast pill");
inboxCounter.getElement().setAttribute("aria-label",
        "12 unread messages");
inboxLink.setSuffixComponent(inboxCounter);

SideNavItem calendarLink = new SideNavItem("Calendar",
        CalendarView.class, VaadinIcon.CALENDAR.create());
Icon calendarNotification = VaadinIcon.BELL.create();
calendarNotification.getElement().getThemeList()
        .add("badge error pill");
calendarNotification.getStyle().set("padding", "var(--lumo-space-xs");
calendarNotification.getElement().setAttribute("aria-label",
        "Upcoming appointment");
calendarLink.setSuffixComponent(calendarNotification);

nav.addItem(inboxLink, calendarLink);
```

## Hierarchy

Navigation items can contain sub-items, which are collapsed by default. There’s no technical limitation on the number of nesting levels. However, a maximum of three levels is recommended for better usability.

Parent items can be links. Clicking them expands their sub-items in addition to navigating. Non-link parent items can be achieved by omitting the target path.

```java
SideNav nav = new SideNav();

SideNavItem messagesLink = new SideNavItem("Messages",
        MessagesView.class, VaadinIcon.ENVELOPE.create());
messagesLink.addItem(new SideNavItem("Inbox", InboxView.class,
        VaadinIcon.INBOX.create()));
messagesLink.addItem(new SideNavItem("Sent", SentView.class,
        VaadinIcon.PAPERPLANE.create()));
messagesLink.addItem(new SideNavItem("Trash", TrashView.class,
        VaadinIcon.TRASH.create()));

SideNavItem adminSection = new SideNavItem("Admin");
adminSection.setPrefixComponent(VaadinIcon.COG.create());
adminSection.addItem(new SideNavItem("Users", UsersView.class,
        VaadinIcon.GROUP.create()));
adminSection.addItem(new SideNavItem("Permissions",
        PermissionsView.class, VaadinIcon.KEY.create()));

nav.addItem(messagesLink, adminSection);
```

## Labeled Collapsible List

A label can be applied to the top of the navigation list. This can be useful for cases with multiple adjacent Side Navigation lists. A labeled Side Navigation list can be made collapsible.

```java
SideNav messagesNav = new SideNav();
messagesNav.setLabel("Messages");
messagesNav.addItem(new SideNavItem("Inbox", InboxView.class,
        VaadinIcon.INBOX.create()));
messagesNav.addItem(new SideNavItem("Sent", SentView.class,
        VaadinIcon.PAPERPLANE.create()));
messagesNav.addItem(new SideNavItem("Trash", TrashView.class,
        VaadinIcon.TRASH.create()));

SideNav adminNav = new SideNav();
adminNav.setLabel("Admin");
adminNav.setCollapsible(true);
adminNav.addItem(new SideNavItem("Users", UsersView.class,
        VaadinIcon.GROUP.create()));
adminNav.addItem(new SideNavItem("Permissions", PermissionsView.class,
        VaadinIcon.KEY.create()));
```

## Another Browser Tab or Window

A navigation link can be opened in another browser tab or window — depending on the browser’s configuration — by specifying the name of the tab or window as the link’s target. A new, unnamed tab or window can be set as the target by providing the name  `_blank`, for which the Flow API provides the shorthand method  `setOpenInNewBrowserTab()`.

```java
SideNavItem item = new SideNavItem("Example", "https://example.com");
item.setOpenInNewBrowserTab(true);
```

## Scrolling

The Side Navigation component doesn’t contain a scroll area. Instead, it can be made scrollable by wrapping it inside a  [Scroller](https://vaadin.com/docs/latest/components/scroller).

## Keyboard Usage

Shortcut

Function

Tab

Navigation between list items.

Tab

Navigation between link and expand and collapse button.

Enter  /  Space

Toggles expand and collapse.

Enter

Trigger link.

## Styling Individual Items

Individual navigation items can be styled by applying a CSS class name to them.

```java
SideNav nav = new SideNav();

SideNavItem dashboardLink = new SideNavItem("Dashboard",
        DashboardView.class, VaadinIcon.DASHBOARD.create());
SideNavItem inboxLink = new SideNavItem("Inbox", InboxView.class,
        VaadinIcon.ENVELOPE.create());
SideNavItem vaadinLink = new SideNavItem("Vaadin website",
        "https://vaadin.com", VaadinIcon.VAADIN_H.create());
vaadinLink.addClassName("external");

nav.addItem(dashboardLink, inboxLink, vaadinLink);
```

## Client-Side Router Integration

By default, clicking a navigation link in a client-side application triggers a full page reload. When using a client-side router (e.g., React Router), this might be undesirable as it disrupts the single-page application experience.

To prevent this behavior, you can assign a callback function to the Side Navigation component’s  `onNavigate`  property. That would cancel the default action on a link click and delegate the responsibility of navigation to the provided function. The function receives an object with properties of the clicked navigation item, including  `path`, which can be used to navigate to the desired route.

Additionally, the Side Navigation component needs to be notified of route changes to have it automatically highlight the currently active item. This can be achieved by updating the Side Navigation component’s  `location`  property whenever the route changes.

The following example demonstrates how to integrate the  `<SideNav>`  component with React Router:

```typescript
const navigate = useNavigate();
const location = useLocation();

return (
  <SideNav
    location={location}
    onNavigate={({ path }) => {
      if (path) {
        navigate(path);
      }
    }}
  >
    <SideNavItem path="/inbox">Inbox</SideNavItem>
    <SideNavItem path="/calendar">Calendar</SideNavItem>
  </SideNav>
);
```
# Split Layout
Split Layout is a component with two content areas and a draggable split handle between them.

```java
MasterContent master = new MasterContent();
DetailContent detail = new DetailContent();

SplitLayout splitLayout = new SplitLayout(master, detail);
```

## Orientation

The default orientation is horizontal, placing the content areas side by side. The orientation can also be vertical.

Orientation should be set based on the content and the screen size. The user can also be allowed to choose which orientation they want to use.

```java
MasterContent master = new MasterContent();
DetailContent detail = new DetailContent();

SplitLayout splitLayout = new SplitLayout(master, detail);
splitLayout.setOrientation(SplitLayout.Orientation.VERTICAL);
```

## Splitter Position

The initial splitter position is determined by the default size of the two content area components. Their height and width affect the position when using a vertical and horizontal orientation, respectively.

The initial split position can also be explicitly set using a percentage value. When using vertical orientation, the split layout must have an explicit height for this to work. This can be either an absolute or a percentage value. When using a percentage value, ensure that ancestors have an explicit height as well.

```java
MasterContent master = new MasterContent();
DetailContent detail = new DetailContent();

SplitLayout splitLayout = new SplitLayout(master, detail);
// Sets the width for the first child to 70%, giving
// the second child the remaining width of 30%
splitLayout.setSplitterPosition(70);
```

The splitter respects the minimum and maximum size of the content area components.

```java
MasterContent master = new MasterContent();
master.setMinWidth("200px");
master.setMaxWidth("400px");

DetailContent detail = new DetailContent();

SplitLayout splitLayout = new SplitLayout(master, detail);
```

The split can be adjusted programmatically, for example by using a Button. This is useful when the user wants to toggle between certain positions.

```java
button = new Button();
leftArrowIcon = VaadinIcon.ARROW_LEFT.create();
rightArrowIcon = VaadinIcon.ARROW_RIGHT.create();
Div masterContainer = new Div();
DetailContent detailContent = new DetailContent();
MasterContent masterContent = new MasterContent();

sidebarCollapsed = false;

button.addClickListener(event -> {
    sidebarCollapsed = !sidebarCollapsed;
    updateSidebar();
});
button.setAriaLabel("Expand/collapse sidebar");
button.addThemeVariants(ButtonVariant.LUMO_TERTIARY);
button.getStyle().set("float", "right");

masterContainer.add(button, masterContent);
masterContainer.getStyle().set("overflow", "hidden");

splitLayout = new SplitLayout(masterContainer, detailContent);

updateSidebar();

...

private void updateSidebar() {
    button.setIcon(sidebarCollapsed ? rightArrowIcon : leftArrowIcon);
    splitLayout.setSplitterPosition(sidebarCollapsed ? 13 : 40);
}
```

## Theme Variants

Split Layout has two theme variants:  `small`  and  `minimal`.

```java
MasterContent master = new MasterContent();
DetailContent detail = new DetailContent();

SplitLayout splitLayout = new SplitLayout(master, detail);
splitLayout.addThemeVariants(SplitLayoutVariant.LUMO_SMALL);
```

The  `small`  theme variant makes the divider smaller. The  `minimal`  theme variant hides the visual divider. Both variants only show the split handle on hover and aren’t ideal for touch devices.

```java
MasterContent master = new MasterContent();
DetailContent detail = new DetailContent();

SplitLayout splitLayout = new SplitLayout(master, detail);
splitLayout.addThemeVariants(SplitLayoutVariant.LUMO_MINIMAL);
```

When using the  `minimal`  theme variant, it’s recommended to somehow suggest the split between the two sides, for example by styling one side as a layer on top of the other.

While these variants reduce visual clutter, they make it less obvious to the user that the content is resizable.

## Best Practices

-   Don’t use Split Layout when either content area has, or should have, a fixed size.

-   Split Layouts can be difficult to use in responsive applications, due to the splitter position being percentage-based, so that the content scales with the viewport.

-   Use Split Layout to give the user the ability to adjust the layout. However, if only specific positions, such as collapsed and expanded, are useful to the user, use a toggle button instead. Non-adjustable layouts should use Ordered Layouts or Flex Layout.

# Tabs
Tabs are used to organize and group content into sections that the user can navigate.

Below is a simple example of tabs with labels:

```java
Tab details = new Tab("Details");
Tab payment = new Tab("Payment");
Tab shipping = new Tab("Shipping");

Tabs tabs = new Tabs(details, payment, shipping);
```

Use Tabs when you want to allow in-place navigation within a certain part of the UI — that is to say, without having to load another page and instead of showing everything at once, or forcing the user to navigate to different views.

## Tab Sheet

Tabs are most conveniently used as part of a Tab Sheet that includes automatically switched content areas for each tab. Try clicking on the tabs in the example below. Notice how different text is displayed for each tab.

```java
TabSheet tabSheet = new TabSheet();
tabSheet.add("Dashboard",
        new Div(new Text("This is the Dashboard tab content")));
tabSheet.add("Payment",
        new Div(new Text("This is the Payment tab content")));
tabSheet.add("Shipping",
        new Div(new Text("This is the Shipping tab content")));
add(tabSheet);
```

## States

A Tab can be selected, unselected, or disabled.

```java
Tab selected = new Tab("Selected");

Tab unselected = new Tab("Unselected");

Tab disabled = new Tab("Disabled");
disabled.setEnabled(false);

Tabs tabs = new Tabs(selected, unselected, disabled);
tabs.setSelectedTab(selected);
```

You can disable a tab to mark it as unavailable. Disabled tabs can’t be focused and may be invisible to assistive technologies, such as screen readers.

Disabling can be preferable to hiding an element to prevent changes in layout when the element’s visibility changes. They can also make users aware of its existence even when unavailable.

### Autoselect (Flow)

The first tab you add to Tabs or Tab Sheet is automatically selected. Similarly, when a selected tab is removed, the next available tab is automatically selected.

Autoselect is enabled by default, but you can disable this behavior if needed. Notice how none of the tabs in the example below are initially selected.

```java
Tabs tabs = new Tabs();
tabs.setAutoselect(false);
```

When using autoselect and tab selection change listeners, you should add selection change listeners before adding any tabs if you want the listeners to trigger for the automatically selected tab.

## Orientation & Overflow

Tabs support two different orientations: horizontal (default) and vertical, which is not currently supported in Tab Sheets. Base your choice of orientation on your particular use case and the available space. Both are explained below.

### Horizontal

Horizontal tabs may be easier for users to understand and associate with the content. They’re best suited for a small number of items, but provide scrolling on overflow. Try scrolling horizontally the tabs in the example here: you’ll see that there are more than the initially visible ones.

```java
Tab analytics = new Tab("Analytics");
Tab customers = new Tab("Customers");
Tab dashboards = new Tab("Dashboards");
Tab documents = new Tab("Documents");
Tab orders = new Tab("Orders");

Tabs tabs = new Tabs(analytics, customers, dashboards, documents,
        orders);
tabs.setMaxWidth("100%");
tabs.setWidth("400px");
```

In horizontal orientation, scroll buttons are displayed by default to aid scrolling the tabs. These can be disabled by applying the  `hide-scroll-buttons`  theme variant. Notice in the example below that there’s no scrollbar or scroll buttons, but you can still scroll to reveal the overflowing tabs.

```java
Tab analytics = new Tab("Analytics");
Tab customers = new Tab("Customers");
Tab dashboards = new Tab("Dashboards");
Tab documents = new Tab("Documents");
Tab orders = new Tab("Orders");
Tab products = new Tab("Products");
Tab tasks = new Tab("Tasks");

Tabs tabs = new Tabs(analytics, customers, dashboards, documents,
        orders, products, tasks);
tabs.addThemeVariants(TabsVariant.LUMO_HIDE_SCROLL_BUTTONS);
tabs.setMaxWidth("100%");
tabs.setWidth("400px");
```

Hiding the scroll buttons isn’t recommended, though, for UIs designed to be operated on non-touchscreen devices, as horizontal scrolling can be difficult without them.

### Vertical

Vertical tabs can sometimes be a better choice for a large number of items. It’s easier for the user to scan a vertical list of options. However, they may not always be easy to understand and associate with the content.

Vertical tabs also provide scrolling on overflow, but no scroll buttons. Incidentally, vertical orientation is not available for Tab Sheets.

```java
Tab analytics = new Tab("Analytics");
Tab customers = new Tab("Customers");
Tab dashboards = new Tab("Dashboards");
Tab documents = new Tab("Documents");
Tab orders = new Tab("Orders");
Tab products = new Tab("Products");
Tab tasks = new Tab("Tasks");

Tabs tabs = new Tabs(analytics, customers, dashboards, documents,
        orders, products, tasks);
tabs.setOrientation(Tabs.Orientation.VERTICAL);
tabs.setHeight("240px");
tabs.setWidth("240px");
```

## Icons & Other Tab Content

In addition to text, tabs can contain icons and other content.

### Icons

Icons can be used to make tabs more prominent and easier to identify. They can be added next to the labels or above them. Generally, horizontal tabs work best with icons above the labels, as you can see in the example below.

```java
Tab profile = new Tab(VaadinIcon.USER.create(), new Span("Profile"));
Tab settings = new Tab(VaadinIcon.COG.create(), new Span("Settings"));
Tab notifications = new Tab(VaadinIcon.BELL.create(),
        new Span("Notifications"));

// Set the icon on top
for (Tab tab : new Tab[] { profile, settings, notifications }) {
    tab.addThemeVariants(TabVariant.LUMO_ICON_ON_TOP);
}

Tabs tabs = new Tabs(profile, settings, notifications);
```

Vertical tabs work best with icons next to labels, as you can see here.

```java
Tab profile = new Tab(VaadinIcon.USER.create(), new Span("Profile"));
Tab settings = new Tab(VaadinIcon.COG.create(), new Span("Settings"));
Tab notifications = new Tab(VaadinIcon.BELL.create(),
        new Span("Notifications"));

Tabs tabs = new Tabs(profile, settings, notifications);
tabs.setOrientation(Tabs.Orientation.VERTICAL);
```

Icon-only labels may sometimes be appealing, but they should provide a textual description using a  [Tooltip](https://vaadin.com/docs/latest/components/tooltip), or an  `aria-label`  attribute for assistive technologies.

### Other Elements

Tabs can contain almost any UI elements. For instance, they can contain badges indicating the number of items per tab. In this example, there’s a gray box with a number to the right of each tab label, indicating the count for each.

```java
Tab open = new Tab(new Span("Open"), createBadge(24));
Tab completed = new Tab(new Span("Completed"), createBadge(439));
Tab cancelled = new Tab(new Span("Cancelled"), createBadge(5));

Tabs tabs = new Tabs(open, completed, cancelled);
```

## Theme Variants

The following theme variants are available for Tabs and Tab Sheet.

### Centered

By default, tabs are left-aligned. They can be centered using the  `centered`  theme variant.

```java
Tab details = new Tab("Details");
Tab payment = new Tab("Payment");
Tab shipping = new Tab("Shipping");

Tabs tabs = new Tabs(details, payment, shipping);
tabs.addThemeVariants(TabsVariant.LUMO_CENTERED);
```

You can use this variant to suit your visual and stylistic preference. It’s typically used for top-level navigation. However, use it only where appropriate since by default left-aligned tabs are more discoverable and what most users expect.

### Equal-Width Tabs

Apply the  `equal-width-tabs`  theme variant to make each tab share equally the available space. This disables the ability to scroll, though, since the content never overflows.

```java
Tab details = new Tab("Details");
Tab payment = new Tab("Payment");
Tab shipping = new Tab("Shipping");

Tabs tabs = new Tabs(details, payment, shipping);
tabs.addThemeVariants(TabsVariant.LUMO_EQUAL_WIDTH_TABS);
```

Use this variant when there are a small number of tabs in a narrow space, such as for a tabbed sidebar and for mobile (i.e., portrait) layouts.

### Minimal

The  `minimal`  theme variant reduces visual styles to a minimum.

```java
Tab details = new Tab("Details");
Tab payment = new Tab("Payment");
Tab shipping = new Tab("Shipping");

Tabs tabs = new Tabs(details, payment, shipping);
tabs.addThemeVariants(TabsVariant.LUMO_MINIMAL);
```

You can generally use this to reduce visual clutter. However, use it with caution as it reduces the visual distinction of selected tabs to color only. This can be difficult to discern for many users.

### Small

The  `small`  theme variant can be used to make the Tabs smaller. This can be good when space is limited. Compare the tabs here to previous ones. You can see these are slightly smaller.

```java
Tab details = new Tab("Details");
Tab payment = new Tab("Payment");
Tab shipping = new Tab("Shipping");

Tabs tabs = new Tabs(details, payment, shipping);
tabs.addThemeVariants(TabsVariant.LUMO_SMALL);
```

### Bordered

The  `bordered`  theme variant adds a border around the Tab Sheet component.

```java
tabSheet.addThemeVariants(TabSheetVariant.LUMO_BORDERED);
```

## Prefix & Suffix

Custom content can be placed before or after the tabs in a Tab Sheet by placing that content in the  `prefix`  and  `suffix`  slots. Notice the additional content at both ends of the tab bar in this example.

```java
tabSheet.setPrefixComponent(new Button("Close all"));

Button plusButton = new Button(new Icon(VaadinIcon.PLUS));
plusButton.addThemeVariants(ButtonVariant.LUMO_ICON);
plusButton.setAriaLabel("Add tab");
tabSheet.setSuffixComponent(plusButton);
```

## Focus & Keyboard

Tab focus is rendered differently when focused by the keyboard. Once a tab is focused, arrow keys can be used to move the focus between tabs. Try pressing  Enter  or  Space  to select the tab on which to focus — or click on one tab with your mouse. Then use the left and right arrow keys to shift the focus.

## Common Cases

### Content Switching without Tab Sheet

Using the integrated content areas in  Tab Sheet  is the easiest way to switch among the different content for each tab. Sometimes, such as when the tabs need to be separated structurally from their content areas, it may be necessary to use the stand-alone Tabs component and manually implement content switching.

Try clicking on each tab here. Notice how the text content changes depending on which you select.

```java
details = new Tab("Details");
payment = new Tab("Payment");
shipping = new Tab("Shipping");

Tabs tabs = new Tabs(details, payment, shipping);
tabs.addSelectedChangeListener(
        event -> setContent(event.getSelectedTab()));
```

### Lazy Initialization of Tab Contents

Sometimes it can be desirable to initialize the contents for a tab, lazily. That is to say, delay its initialization until the tab is selected. When you first click on one of the tabs below, you’ll notice a loading indicator, and a short delay until the tab content is displayed for each.

```java
tabSheet.add("Dashboard", new LazyComponent(
            () -> new Text("This is the Dashboard tab content")));

public class LazyComponent extends Div {
    public LazyComponent(
            SerializableSupplier<? extends Component> supplier) {
        addAttachListener(e -> {
            if (getElement().getChildCount() == 0) {
                add(supplier.get());
            }
        });
    }
}
```
# Text Area
Text Area is an input field component that allows entry of multiple lines of text.

```java
TextArea textArea = new TextArea();
textArea.setLabel("Comment");
textArea.setMaxLength(charLimit);
textArea.setValueChangeMode(ValueChangeMode.EAGER);
textArea.addValueChangeListener(e -> {
    e.getSource()
            .setHelperText(e.getValue().length() + "/" + charLimit);
});
textArea.setValue("Great job. This is excellent!");
add(textArea);
```

Text Area is typically used for descriptions, comments, and other longer free-form content.

## Automatic Height Adjustment

Unless set to a fixed height, Text Area adjusts its height automatically based on its content. The default and minimum height is two rows of text.

```java
TextArea textArea = new TextArea();
textArea.setWidthFull();
textArea.setLabel("Description");
textArea.setValue(loremIpsum);
add(textArea);
```

### Minimum & Maximum Height

The automatic resizing can be restricted to a minimum and maximum height like so:

```java
TextArea textArea = new TextArea();
textArea.setWidthFull();
textArea.setMinHeight("100px");
textArea.setMaxHeight("150px");
textArea.setLabel("Description");
textArea.setValue(loremIpsum);
add(textArea);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/text-area#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/text-area#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/text-area#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/text-area#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/text-area#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/text-area#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix & Suffix

Prefix and suffix elements — rendered at either end of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix and suffix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/text-area#label), a  [Helper](https://vaadin.com/docs/latest/components/text-area#helper), or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```html
<!-- Associates external element as label: -->
<label id="external-label">This is the label</label>
<vaadin-text-area accessible-name-ref="external-label">...

<!-- Invisible label for screen readers: -->
<vaadin-text-area accessible-name="This is the label">...
```

```java
TextArea field = new TextArea();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.VAADIN_H.create());
field.setSuffixComponent(new Span(":)"));
```

## Constraints

Required

Required fields are marked with an indicator next to the label, and become invalid if left empty after having been focused. An error message explaining that the field is required needs to be provided manually.

An instruction text at the top of the form explaining the required indicator is recommended. The indicator itself can be customized with the  `--lumo-required-field-indicator`  style property.

Min & Max Length

The minimum and maximum input length value constraints dictate the smallest, and the largest number of characters a field accepts. It triggers a validation error if a value shorter than the minimum length is entered, and limits text entered to the maximum length. They can be used to enforce specific formats, or to cap the value to the length supported by the underlying database schema.

In cases where the length requirements may not be clear to the user, it’s recommended to provide this information, for example by using a Helper.

Pattern

The pattern is a regular expression used to validate the full value entered into the field. Any value that doesn’t match the pattern, invalidates the field.

Allowed Characters

A separate single-character, regular expression can be used to restrict the characters that can be entered into the field. Characters that don’t match the expression are rejected.

```java
TextArea field = new TextArea("Sentence");
field.setRequiredIndicatorVisible(true);
field.setPattern("^[A-Z]([A-Za-z0-9,\\-\\s])*\\.$");
field.setAllowedCharPattern("[A-Za-z0-9,.\\-\\s]");
field.setMinLength(5);
field.setMaxLength(50);
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
TextArea readonlyArea = new TextArea();
readonlyArea.setReadOnly(true);
readonlyArea.setLabel("Read-only");
readonlyArea.setValue("Value");

TextArea disabledArea = new TextArea();
disabledArea.setEnabled(false);
disabledArea.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
TextArea field = new TextArea();
field.addThemeVariants(TextAreaVariant.LUMO_SMALL,
        TextAreaVariant.LUMO_ALIGN_RIGHT,
        TextAreaVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Character Counter

Longer free-form inputs are often capped at a certain character limit. The current character count and upper limit should be displayed to the user, for example by using the Helper feature:

```java
TextArea textArea = new TextArea();
textArea.setWidthFull();
textArea.setLabel("Description");
textArea.setMaxLength(charLimit);
textArea.setValueChangeMode(ValueChangeMode.EAGER);
textArea.addValueChangeListener(e -> {
    e.getSource()
            .setHelperText(e.getValue().length() + "/" + charLimit);
});
textArea.setValue(loremIpsum);
add(textArea);
```

# Text Field
Text Field allows users to enter text. Prefix and suffix components, such as icons, are also supported.

```java
TextField textField = new TextField();
textField.setLabel("Street Address");
textField.setValue("Ruukinkatu 2");
textField.setClearButtonVisible(true);
textField.setPrefixComponent(VaadinIcon.MAP_MARKER.create());
add(textField);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/text-field#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/text-field#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/text-field#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/text-field#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/text-field#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/text-field#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix & Suffix

Prefix and suffix elements — rendered at either end of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix and suffix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/text-field#label), a  [Helper](https://vaadin.com/docs/latest/components/text-field#helper), or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```java
// Associates external element as label:
NativeLabel label = new NativeLabel("This is the label");
label.setId("external-label");
field.setAriaLabelledBy("external-label");

// Invisible label for screen readers:
field.setAriaLabel("This is the label");
```
```java
TextField field = new TextField();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.VAADIN_H.create());
field.setSuffixComponent(new Span(":)"));
```

## Constraints

Required

Required fields are marked with an indicator next to the label, and become invalid if left empty after having been focused. An error message explaining that the field is required needs to be provided manually.

An instruction text at the top of the form explaining the required indicator is recommended. The indicator itself can be customized with the  `--lumo-required-field-indicator`  style property.

Min & Max Length

The minimum and maximum input length value constraints dictate the smallest, and the largest number of characters a field accepts. It triggers a validation error if a value shorter than the minimum length is entered, and limits text entered to the maximum length. They can be used to enforce specific formats, or to cap the value to the length supported by the underlying database schema.

In cases where the length requirements may not be clear to the user, it’s recommended to provide this information, for example by using a Helper.

Pattern

The pattern is a regular expression used to validate the full value entered into the field. Any value that doesn’t match the pattern, invalidates the field.

Allowed Characters

A separate single-character, regular expression can be used to restrict the characters that can be entered into the field. Characters that don’t match the expression are rejected.

```java
TextField field = new TextField("Phone number");
field.setRequiredIndicatorVisible(true);
field.setPattern(
        "^[+]?[\\(]?[0-9]{3}[\\)]?[\\-]?[0-9]{3}[\\-]?[0-9]{4,6}$");
field.setAllowedCharPattern("[0-9()+-]");
field.setMinLength(5);
field.setMaxLength(18);
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
TextField readonlyField = new TextField();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue("Value");

TextField disabledField = new TextField();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
TextField field = new TextField();
field.addThemeVariants(TextFieldVariant.LUMO_SMALL,
        TextFieldVariant.LUMO_ALIGN_RIGHT,
        TextFieldVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Autoselect

When a field is set to  `autoselect`, its content is selected when the field is focused. Use  `autoselect`  when the user might to want to replace the entire value rather than adjust it.

Autoselect

Focused with

Result

`ON`

Pointing device or keyboard navigation.

Content selected.

`OFF`

Pointing device.

Cursor placed where clicked.

`OFF`

Keyboard navigation
Tab

Cursor at the end of the input value.

`OFF`

Keyboard navigation
Shift+Tab

# Time Picker
Time Picker is an input field for used entering or selecting a specific time.

```java
TimePicker timePicker = new TimePicker();
timePicker.setLabel("Alarm");
timePicker.setValue(LocalTime.of(7, 0));
add(timePicker);
```

The time can be entered directly using a keyboard, or by choosing a value from a set of predefined options presented in an overlay. The overlay opens when the field is clicked — or when any input is entered while the field is focused.

## Step

Time Picker’s step parameter defines the interval in seconds between the items displayed in the overlay. It also specifies the amount by which the time increases or decreases using the  Up  and  Down  arrow keys — when the overlay is disabled.

The default step is one hour (i.e.,  `3600`  seconds). Unlike  [Number Field](https://vaadin.com/docs/latest/components/number-field), Time Picker accepts values that don’t align with the specified step.

```java
TimePicker timePicker = new TimePicker();
timePicker.setLabel("Meeting time");
timePicker.setStep(Duration.ofMinutes(30));
timePicker.setValue(LocalTime.of(12, 30));
add(timePicker);
```

Use Common Steps

A step must evenly divide an hour or day. For example,  _"15 minutes"_  and  _"30 minutes"_  are valid steps for an hour, and  _"2 hours"_  is a valid step for a day, whereas  _"42 minutes"_  isn’t valid for either.

The displayed time format changes based on the step.

```java
TimePicker timePicker = new TimePicker();
timePicker.setLabel("Message received");
timePicker.setStep(Duration.ofSeconds(1));
timePicker.setValue(LocalTime.of(15, 45, 8));
add(timePicker);
```

Step

Format

Less than 60 seconds.

HH:MM:SS

Less than 1 second.

HH:MM:SS:FFF

Limit Number of Steps

The overlay doesn’t appear for steps less than 900 seconds (i.e., 15 minutes), to avoid showing an impractical number of choices.

## Auto Open

The overlay opens automatically when the field is focused using a pointer (i.e., a mouse or touch), or when the user types in the field. You can disable this so that the overlay opens only when the toggle button — or the  Up  or  Down  arrow keys — is pressed.

```java
TimePicker timePicker = new TimePicker();
timePicker.setLabel("Alarm");
timePicker.setStep(Duration.ofMinutes(30));
timePicker.setValue(LocalTime.of(5, 30));
timePicker.setAutoOpen(false);
add(timePicker);
```

## Validation

### Minimum & Maximum Value

You can define a minimum and maximum value for Time Picker if you need to restrict the input to a specific range:
```java
TimePicker timePicker = new TimePicker();
timePicker.setLabel("Appointment time");
timePicker.setHelperText("Open 8:00-16:00");
timePicker.setStep(Duration.ofMinutes(30));
timePicker.setValue(LocalTime.of(8, 30));
timePicker.setMin(LocalTime.of(8, 0));
timePicker.setMax(LocalTime.of(16, 0));
timePicker.addValueChangeListener(event -> {
    LocalTime value = event.getValue();
    String errorMessage = null;
    if (value != null) {
        if (value.compareTo(timePicker.getMin()) < 0) {
            errorMessage = "Too early, choose another time";
        } else if (value.compareTo(timePicker.getMax()) > 0) {
            errorMessage = "Too late, choose another time";
        }
    }
    timePicker.setErrorMessage(errorMessage);
});
add(timePicker);
```

### Custom Validation

If the minimum and maximum values aren’t sufficient for validation, you can also apply custom validation.

```java
TimePicker timePicker = new TimePicker();
timePicker.setLabel("Appointment time");
timePicker.setHelperText("Open 8:00-12:00, 13:00-16:00");
timePicker.setStep(Duration.ofMinutes(30));
timePicker.setMin(LocalTime.of(8, 0));
timePicker.setMax(LocalTime.of(16, 0));
add(timePicker);

Binder<Appointment> binder = new Binder<>(Appointment.class);
binder.forField(timePicker).withValidator(startTime -> {
    return !(LocalTime.of(8, 0).isAfter(startTime)
            || (LocalTime.of(12, 0).isBefore(startTime)
                    && LocalTime.of(13, 0).isAfter(startTime))
            || LocalTime.of(16, 0).isBefore(startTime));
}, "The selected time is not available").bind(Appointment::getStartTime,
        Appointment::setStartTime);
```

## Basic Features

The following features, common to most input field components, are supported:

Label

The label is used to identify the input field. It supports plain-text content, and its length is limited to the width of the field.  [Helpers](https://vaadin.com/docs/latest/components/time-picker#helper)  and  [Tooltips](https://vaadin.com/docs/latest/components/time-picker#tooltip)  can be used to provide additional information that doesn’t fit into the label.

Visible labels are strongly recommended for all input fields. In cases where the built-in label cannot be used, an external element can be associated as the field’s label through the  `aria-labelledby`  attribute. Fields without any visible label should include an invisible label for assistive technologies with the  `aria-label`  attribute.

Helper

Helpers are used to provide additional information that the user may need to enter in the field, such as format requirements or explanations of the field’s purpose below the field.

A style variant is available for rendering the helper  [above the field](https://vaadin.com/docs/latest/components/time-picker#helper-above-field).

In addition to plain text, helpers can contain components and HTML elements. However, complex and interactive content is likely to have accessibility issues.

Placeholder

The placeholder is text that’s displayed when the field is empty. Its primary purpose is to provide a short input hint (e.g., the expected format) in situations where a  [Helper](https://vaadin.com/docs/latest/components/time-picker#helper)  cannot be used.

Placeholders should not be used as a replacement for a visible label. They can be mistaken for a manually entered value. See  [Label](https://vaadin.com/docs/latest/components/time-picker#label)  for alternatives to the built-in field label.

Tooltip

Tooltips are small text pop-ups displayed on hover, and on keyboard-focus. They can be used to provide additional information about a field. This can be useful in situations where an always visible  [Helper](https://vaadin.com/docs/latest/components/time-picker#helper)  is not appropriate. Helpers are generally recommended in favor of tooltips, though, as they provide much better discoverability and mobile support. See the  [Tooltip](https://vaadin.com/docs/latest/components/tooltip)  documentation for more information.

Clear Button

The clear button — which is displayed when the field is not empty — clears the field’s current value. Although the button itself is not keyboard focusable, the clear action can be taken with the  Esc  key, when the field has focus. The clear button can be especially useful in search and filter fields, where users often need to clear the value. They’re less useful, however, in regular forms.

Prefix

A prefix element — rendered at the start of the field — can be used to display units, icons, and similar visual cues to the field’s purpose or format.

Prefix elements typically don’t work well with assistive technologies like screen readers. Therefore, the information communicated by them should also be conveyed through other means, such as in a  [Label](https://vaadin.com/docs/latest/components/time-picker#label), a  [Helper](https://vaadin.com/docs/latest/components/time-picker#helper)  or through ARIA attributes on the field itself.

External & Invisible Labels (ARIA)

Visible labels are strongly recommended for all input fields. In situations where the built-in label cannot be used, an external element can be associated as the field’s label through its element  `id`. Fields without any visible label should be provided an invisible label for assistive technologies like screen readers.

```java
// Associates external element as label:
NativeLabel label = new NativeLabel("This is the label");
label.setId("external-label");
field.setAriaLabelledBy("external-label");

// Invisible label for screen readers:
field.setAriaLabel("This is the label");
```

```java
TimePicker field = new TimePicker();
field.setLabel("Label");
field.setHelperText("Helper text");
field.setPlaceholder("Placeholder");
field.setTooltipText("Tooltip text");
field.setClearButtonVisible(true);
field.setPrefixComponent(VaadinIcon.VAADIN_H.create());
```

## Read-Only & Disabled

Fields used to display values should be set to  `read-only`  mode to prevent editing. Read-only fields are focusable and visible to screen readers. They can display tooltips. Their values can be selected and copied.

Fields that are currently unavailable should be  `disabled`. The reduced contrast of disabled fields makes them inappropriate for displaying information. They can’t be focused or display tooltips. They’re invisible to screen readers, and their values cannot be selected and copied.

Disabled fields can be useful in situations where they can become enabled based on some user action. Consider hiding fields entirely if there’s nothing the user can do to make them editable.

```java
TimePicker readonlyField = new TimePicker();
readonlyField.setReadOnly(true);
readonlyField.setLabel("Read-only");
readonlyField.setValue(LocalTime.of(7, 0));

TimePicker disabledField = new TimePicker();
disabledField.setEnabled(false);
disabledField.setLabel("Disabled");
```

## Style Variants

The following style variants can be applied:

Text Alignment

Three different text alignments are supported:  `left`, which is the default;  `center`; and  `right`.

Right-alignment is recommended for numerical values when presented in vertical groups. This tends to aid interpretation and comparison of values.

Small Variant

The small variant can be used to make individual fields more compact. The default size of fields can be customized with  [style properties](https://vaadin.com/docs/latest/styling/lumo/lumo-style-properties).

Helper Above Field

The helper can be rendered above the field, and below the label.

Borders

Borders can be applied to the field surface by providing a value (e.g.,  `1px`) to the  `--vaadin-input-field-border-width`  CSS property. This can be applied globally to all input fields using the  `html`  selector, or to individual component instances. Borders are required to achieve  [WCAG 2.1 level AA](https://www.w3.org/TR/WCAG21/#non-text-contrast)  conformant color contrast with the default Lumo styling of fields.

You can override the default border color with the  `--vaadin-input-field-border-color`  property.

```java
TimePicker field = new TimePicker();
field.addThemeVariants(TimePickerVariant.LUMO_SMALL,
        TimePickerVariant.LUMO_ALIGN_RIGHT,
        TimePickerVariant.LUMO_HELPER_ABOVE_FIELD);
field.getStyle().set("--vaadin-input-field-border-width", "1px");
```

## Best Practices

Use Time Picker when the user needs to choose a time of day. Don’t use it for durations, such as for a stopwatch or timer.

# Tooltip
Tooltips are small pop-ups for providing additional information about other UI elements. A tooltip for an element becomes visible when the user hovers the mouse pointer over the element or when the element receives keyboard focus.

```java
TextField textField = new TextField();
textField.setPlaceholder("Search");
textField.setPrefixComponent(new Icon("lumo", "search"));
textField.setTooltipText("Wrap in “quotes” for exact phrase");
add(textField);
```

Tooltips only support plain text content. They aren’t focusable and can’t contain interactive elements.

## Other UI Elements

Tooltips can be displayed for UI elements that lack a dedicated tooltip API. Proper accessibility, however, for these can’t be guaranteed.

```java
H2 heading = new H2("Heading with tooltip");
Tooltip tooltip = Tooltip.forComponent(heading)
        .withText("This is a tooltip")
        .withPosition(Tooltip.TooltipPosition.TOP_START);
add(heading);
```

The  [Grid](https://vaadin.com/docs/latest/components/grid#tooltips)  and  [Menu Bar](https://vaadin.com/docs/latest/components/menu-bar#tooltips)  components have dedicated APIs for configuring tooltips.

## Positioning

The default positioning of the tooltip in relation to the target element can be overridden. This can be useful for optimizing where the tooltip is rendered, to avoid overlaying other important UI elements, or for purely aesthetic reasons.

```java
Tab tab = new Tab(link);
tab.setTooltipText(viewName).withPosition(TooltipPosition.END);
```

The distance between the tooltip and the target element can also be customized by setting the following CSS properties on the tooltip:

-   `--vaadin-tooltip-offset-top`

-   `--vaadin-tooltip-offset-bottom`

-   `--vaadin-tooltip-offset-start`

-   `--vaadin-tooltip-offset-end`


## Configuring Delays

The delay before tooltips appear can be configured separately for hover and keyboard focus. The delay before tooltips disappear — when the pointer leaves the target element — can also be configured separately. On blur, though, the tooltip is closed immediately to avoid confusion when focusing another element.

```java
import com.vaadin.flow.component.shared.TooltipConfiguration;

// Global delay configuration:
TooltipConfiguration.setDefaultFocusDelay(2000);
TooltipConfiguration.setDefaultHoverDelay(1000);
TooltipConfiguration.setDefaultHideDelay(1000);

// Overriding delays for a particular component’s tooltip:
button.setTooltipText("Home").withHoverDelay(500);
```

## Triggering Manually

Tooltips can be configured not to appear automatically on hover or keyboard focus, but instead be programmatically triggered only. This can be used to create so-called,  _toggletips_ — tooltips that can be manually displayed and hidden by the user.

```java
textField.setTooltipText("Wrap in “quotes” for exact phrase");
Tooltip tooltip = textField.getTooltip().withManual(true);
button.addClickListener(event -> {
    tooltip.setOpened(!tooltip.isOpened());
});
```

## Accessibility

Tooltips are semantically associated with their target elements using the  [`aria-describedby`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-describedby)  attribute, and are announced by screen readers when the element gains keyboard focus.

However, tooltips on elements without dedicated tooltip APIs can’t be guaranteed to be announced correctly. This is because the announcement of  `aria-describedby`  attributes depends on the HTML element’s type and the  `role`  attribute. It also varies between different screen readers. Testing with screen readers is useful to ensure the accessibility of tooltips on these elements.

The tooltip feature currently doesn’t support triggering via long press on touch-screen devices.

Keep in mind that Vaadin components and other UI elements don’t, by default, imply the presence of tooltips in any way. This might make them difficult for users to discover.

In general, visible labels are always preferable to tooltips. A separately defined invisible  [`aria-label`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label)  attribute usually provides better accessibility than a tooltip.

## Best Practices

Tooltips should be used only to provide additional information, not for mission-critical information. They’re not a replacement for visible labels on input fields.

On input field components, tooltips should be considered a last resort if neither the label — not the helper — nor the placeholder text can be used to provide the necessary information.

# Tree Grid
Tree Grid is a component for displaying hierarchical tabular data grouped into expandable nodes.

```java
TreeGrid<Person> treeGrid = new TreeGrid<>();
treeGrid.setItems(managers, this::getStaff);
treeGrid.addHierarchyColumn(Person::getFirstName)
        .setHeader("First name");
treeGrid.addColumn(Person::getLastName).setHeader("Last name");
treeGrid.addColumn(Person::getEmail).setHeader("Email");
```

Tree Grid is an extension of the Grid component. Therefore, all of Grid’s features are available in Tree Grid. However, Tree Grid isn’t meant to be used as a navigation menu.

## Tree Column

The tree column contains the toggles for expanding and collapsing nodes. Nodes are opened and closed by clicking a tree column’s cell. They can also be toggled programmatically.

```java
Button expand = new Button("Expand All");
expand.addClickListener(event -> treeGrid.expand(managers));

Button collapse = new Button("Collapse All");
collapse.addClickListener(event -> treeGrid.collapse(managers));
```

## Rich Content

Like Grid, Tree Grid supports rich content.

```java
treeGrid.addComponentHierarchyColumn(person -> {
    Avatar avatar = new Avatar();
    avatar.setName(person.getFullName());
    avatar.setImage(person.getPictureUrl());

    Span fullName = new Span(person.getFullName());

    Span profession = new Span(person.getProfession());
    profession.getStyle()
            .set("color", "var(--lumo-secondary-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");

    VerticalLayout column = new VerticalLayout(fullName, profession);
    column.getStyle().set("line-height", "var(--lumo-line-height-m)");
    column.setPadding(false);
    column.setSpacing(false);

    HorizontalLayout row = new HorizontalLayout(avatar, column);
    row.setAlignItems(FlexComponent.Alignment.CENTER);
    row.setSpacing(true);
    return row;
}).setHeader("Employee");

treeGrid.addComponentColumn(person -> {
    Icon emailIcon = createIcon(VaadinIcon.ENVELOPE);
    Span email = new Span(person.getEmail());

    Anchor emailLink = new Anchor();
    emailLink.add(emailIcon, email);
    emailLink.setHref("mailto:" + person.getEmail());
    emailLink.getStyle().set("align-items", "center").set("display",
            "flex");

    Icon phoneIcon = createIcon(VaadinIcon.PHONE);
    Span phone = new Span(person.getAddress().getPhone());

    Anchor phoneLink = new Anchor();
    phoneLink.add(phoneIcon, phone);
    phoneLink.setHref("tel:" + person.getAddress().getPhone());
    phoneLink.getStyle().set("align-items", "center").set("display",
            "flex");

    VerticalLayout column = new VerticalLayout(emailLink, phoneLink);
    column.getStyle().set("font-size", "var(--lumo-font-size-s)")
            .set("line-height", "var(--lumo-line-height-m)");
    column.setPadding(false);
    column.setSpacing(false);
    return column;
}).setHeader("Contact");
```

## Programmatic Scrolling

Grid supports programmatic navigation to a specific row. This is particularly useful when dealing with large data sets. It saves users from having to scroll through potentially hundreds or thousands of rows.

To use this feature, you need to specify the index of the row you want to view. The scroll position of the grid will then be adjusted to bring that row into view.

With multiple levels of hierarchy, you need to specify the row index for each level, separately. For example, to scroll to the second child-row (index 1) of the third root-level row (index 2), you would provide the indexes 2, 1.

```java
treeGrid.scrollToIndex(indexesToScrollTo);
```

# Upload
Upload allows the user to upload files, giving feedback to the user during the upload process. It shows the upload progress and the status of each file. Files can be uploaded by clicking on the  **Upload**  button, or by dragging them onto the component.

```java
MultiFileMemoryBuffer buffer = new MultiFileMemoryBuffer();
Upload upload = new Upload(buffer);

upload.addSucceededListener(event -> {
    String fileName = event.getFileName();
    InputStream inputStream = buffer.getInputStream(fileName);

    // Do something with the file data
    // processFile(inputStream, fileName);
});
```

## Drag & Drop

Upload allows the user to drag files onto the component to upload them. Multiple files can be dropped simultaneously. By default, this is enabled on desktop computers, and disabled on touch devices. Explicitly setting it to enabled or disabled, though, affects both desktop and mobile devices.

```java
Upload dropEnabledUpload = new Upload(buffer1);
dropEnabledUpload.setDropAllowed(true);

Upload dropDisabledUpload = new Upload(buffer2);
dropDisabledUpload.setDropAllowed(false);
```

## Auto-Upload

By default, files are uploaded immediately — or at least they’re added to the queue to be uploaded. Auto-upload can be disabled, for example, to allow the user to review the list of files before initiating their upload by clicking the ▶️ button for each file. Change the button label, though, to indicate that uploads don’t start automatically.

```java
Upload upload = new Upload(buffer);
upload.setAutoUpload(false);

UploadExamplesI18N i18n = new UploadExamplesI18N();
i18n.getAddFiles().setMany("Select Files...");
upload.setI18n(i18n);
```

Uploads can be initiated programmatically when auto-upload is disabled. You might do this, for example, if you want to provide the user with a single button to start all uploads.

```java
Upload upload = new Upload(buffer);
upload.setAutoUpload(false);

Button uploadAllButton = new Button("Upload All Files");
uploadAllButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
uploadAllButton.addClickListener(event -> {
    // No explicit Flow API for this at the moment
    upload.getElement().callJsFunction("uploadFiles");
});
```

## Upload Restrictions

You can set three types of restrictions: file format; file count; and file size.

Exceptions that arise — usually from the user violating any of the imposed restrictions — aren’t shown in the UI by default. Use a  [File Rejected listener](https://vaadin.com/docs/latest/components/upload#listeners)  to catch those exceptions and, for example, a  [Notification](https://vaadin.com/docs/latest/components/notification)  to inform the user of the problem, together with any potential solutions.

The user should be informed upfront, though, about any file upload restrictions. Limitations on the maximum number of files allowed, file size, and format should all be communicated clearly, to reduce or eliminate exceptions.

### File Format

Upload can be configured to accept only files of specific formats. The acceptable file formats are set using MIME type patterns or file extensions (e.g.,  `"video/*"`,  `"image/tiff"`  or  `".pdf"`  and  `"audio/mp3"`).

```java
Upload upload = new Upload(buffer);
upload.setAcceptedFileTypes("application/pdf", ".pdf");

upload.addFileRejectedListener(event -> {
    String errorMessage = event.getErrorMessage();

    Notification notification = Notification.show(errorMessage, 5000,
            Notification.Position.MIDDLE);
    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
});
```

Prefer MIME Type

Although  [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types)  are widely supported, file extensions are only implemented  [in certain browsers](https://caniuse.com/input-file-accept)  and should be avoided.

File Format Restrictions are Client-Side

File format restrictions set with  `setAcceptedFileType`  method are checked only on the client side. They indicate the hints for users as to what file types to upload.

Using this method won’t restrict the uploaded file’s format on the server side. The Upload component doesn’t have an API to restrict uploaded files by file format or content on the server side. If required, it’s the responsibility of the application developer to implement application-specific restrictions on the server side in one or more of the Upload component’s event listeners (e.g., in  `Upload::addSucceededListener`).

### File Count

By default, Upload doesn’t limit the number of files that can be uploaded. However, you can set a file count limit. If you set the maximum to one, the native file browser prevents multiple files from being selected.

Java Flow-Specific

When using a  `Receiver`  that doesn’t implement the  `MultiFileReceiver`  interface — such as  `MemoryBuffer`  or  `FileBuffer` — the Upload component limits the number of files to one. This is because these receiver implementations only support handling a single file at once.

```java
Upload upload = new Upload(buffer);
upload.setMaxFiles(3);

upload.addFileRejectedListener(event -> {
    String errorMessage = event.getErrorMessage();

    Notification notification = Notification.show(errorMessage, 5000,
            Notification.Position.MIDDLE);
    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
});
```

### File Size

Upload allows you to limit the file size by setting a maximum amount in bytes. By default, though, there is no limit.
```java
Upload upload = new Upload(buffer);

int maxFileSizeInBytes = 10 * 1024 * 1024; // 10MB
upload.setMaxFileSize(maxFileSizeInBytes);

upload.addFileRejectedListener(event -> {
    String errorMessage = event.getErrorMessage();

    Notification notification = Notification.show(errorMessage, 5000,
            Notification.Position.MIDDLE);
    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
});
```

Revalidate Size Limit on Server

This constraint is set on the client and is checked before contacting the server.

## File Actions

Each file has a certain set of associated actions available, depending on its upload state. A file always has a  **Clear/Remove**  button. This button cancels the upload if applicable, and removes the file from the list. This button is the only available action during and after a successful upload.

Remove the File

The  **Clear/Remove**  button doesn’t remove a successfully uploaded file from the server file system or database. It’s only removed from the file list. Remember to remove the file from the backend.

If an error or exception occurs, Upload displays a  **Retry**  button for the user to be able to try to upload the file again.

When a file is queued (i.e., auto-upload is disabled), there’s a  **Start**  Button that the user must press to begin the upload process.

## Internationalization (i18n)

All labels and messages in Upload are configurable. For a complete list of them, see the API documentation ([Java](https://vaadin.com/api/platform/24.5.0.alpha15/com/vaadin/flow/component/upload/UploadI18N.html)  and  [Web component](https://cdn.vaadin.com/vaadin-web-components/24.5.0-alpha11/#/elements/vaadin-upload#property-i18n)).

```java
Upload upload = new Upload(buffer);

// See the separate UploadFinnishI18N class / file
// in this example for the I18N configuration
UploadFinnishI18N i18N = new UploadFinnishI18N();
upload.setI18n(i18N);
```

## Customization

You can replace the default upload button. You might do this if Upload needs a stronger emphasis. If so, you can use a primary button.

```java
Upload upload = new Upload(buffer);
upload.setAcceptedFileTypes("application/pdf", ".pdf");

Button uploadButton = new Button("Upload PDF...");
uploadButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

upload.setUploadButton(uploadButton);

// Disable the upload button after the file is selected
// Re-enable the upload button after the file is cleared
upload.getElement()
        .addEventListener("max-files-reached-changed", event -> {
            boolean maxFilesReached = event.getEventData()
                    .getBoolean("event.detail.value");
            uploadButton.setEnabled(!maxFilesReached);
        }).addEventData("event.detail.value");
```

You can also customize the drop label, as well as the icon.

```java
Upload upload = new Upload(buffer);

Span dropLabel = createDropLabel();
Icon dropIcon = VaadinIcon.CLOUD_UPLOAD_O.create();

upload.setDropLabel(dropLabel);
upload.setDropLabelIcon(dropIcon);
```

Large Drop Target

When customizing the Upload component, make sure not to make the drop target too small. A large drop target is easier to use and less error-prone.

## Listeners

Upload has listeners for the following events:

_All Finished_

Triggered when Upload has processed all of the files in its queue, regardless of whether all uploads were successful.

_Failed_

Occurs when the upload is received, but the reception is interrupted for some reason.

_File Rejected_

Sent when the file selected for upload doesn’t meet the constraints (e.g., file size limit).

_Finished_

Sent when Upload receives a file, regardless of whether the upload was successful. To distinguish results, use instead either  _Succeeded_  or  _Failed_  listeners.

_Progress_

Event for tracking upload progress.

_Started_

Triggered when the upload starts.

_Succeeded_

Sent when the upload has been received successfully.

## Best Practices

With regards to developing with Upload, this section provides some suggestions on how to label buttons and how to construct error messages for better user experiences.

### Labeling

Choose labels that are informative and instructive. For example, if the user is to upload a single PDF file, it’s better to have the button label say "Upload PDF…" instead of "Upload File…". The task becomes clearer and improves accessibility for the user — especially if they’re using a screen reader, as the button’s label is read aloud when focused.

```java
Upload upload = new Upload(buffer);
upload.setAcceptedFileTypes("application/pdf", ".pdf");

UploadExamplesI18N i18n = new UploadExamplesI18N();
i18n.getAddFiles().setOne("Upload PDF...");
i18n.getDropFiles().setOne("Drop PDF here");
i18n.getError().setIncorrectFileType(
        "The provided file does not have the correct format (PDF document).");
upload.setI18n(i18n);
```

Likewise, if the user is expected to upload a spreadsheet, but multiple file formats are accepted, label the button, "Upload Spreadsheet". Include helpers to inform the user which formats are accepted.


#### Upload spreadsheet

File size must be less than or equal to 1 MB. Only Excel and CSV files are accepted.

```java
H4 title = new H4("Upload spreadsheet");
Paragraph hint = new Paragraph(
        "File size must be less than or equal to 1 MB. Only Excel and CSV files are accepted.");

Upload upload = new Upload(buffer);
upload.setAcceptedFileTypes(
        // Microsoft Excel (.xls)
        "application/vnd.ms-excel", ".xls",
        // Microsoft Excel (OpenXML, .xlsx)
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ".xlsx",
        // Comma-separated values (.csv)
        "text/csv", ".csv");

UploadExamplesI18N i18n = new UploadExamplesI18N();
i18n.getAddFiles().setOne("Upload Spreadsheet...");
i18n.getDropFiles().setOne("Drop spreadsheet here");
i18n.getError().setIncorrectFileType(
        "Provide the file in one of the supported formats (.xls, .xlsx, .csv).");
upload.setI18n(i18n);

add(title, hint, upload);
```

### Error Messages

Try to provide meaningful feedback and error messages when an exception or error occurs. Avoid technical jargon. Instead, try to provide solutions and instructions on how to fix the error.

A "Server Unavailable" message might suffice for tech-savvy users, but for some it might be lacking, unhelpful, and frustrating. Error messages should be written with your users in mind.

```java
Upload upload = new Upload(buffer);
upload.setDropAllowed(false);

UploadExamplesI18N i18N = new UploadExamplesI18N();
i18N.getUploading().getError().setUnexpectedServerError(
        "File couldn't be uploaded, please try again later");
upload.setI18n(i18N);
```

# Vertical Layout
Vertical Layout places components top-to-bottom in a column. By default, it has a width of 100% and an undefined height. Its width is constrained by its parent component (i.e., it “fills” the available space). Whereas, its height is determined by the components it contains (i.e., it “hugs” its content).

See  [Horizontal Layout](https://vaadin.com/docs/latest/components/horizontal-layout)  for information on placing components side-by-side.

```java
VerticalLayout layout = new VerticalLayout();
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));
```

Components in a Vertical Layout can be aligned vertically, as you’d expect. However and perhaps surprisingly, they can also be aligned horizontally in a Vertical Layout.

## Vertical Alignment

You can position components at the top, middle, or bottom. You can also position them by specifying how the excess space in a layout is distributed among them.

```java
VerticalLayout layout = new VerticalLayout();
layout.setJustifyContentMode(FlexComponent.JustifyContentMode.CENTER);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));
```

Value

Description

`START`  (default)

Positions items at the top.

`CENTER`

Centers items, vertically.

`END`

Positions items at the bottom.

`BETWEEN`

Available space is distributed equally among items. However, no space is added before the first item, or after the last.

`AROUND`

Available space is distributed equally among items. However, the space before the first item and after the last is half of that between items.

`EVENLY`

Available space is distributed equally among items. The space before the first item and after the last item is the same as between others.

## Horizontal Alignment

Components in a Vertical Layout are left-aligned by default, but can be centered, right-aligned or stretched horizontally.

```java
VerticalLayout layout = new VerticalLayout();
layout.setAlignItems(FlexComponent.Alignment.CENTER);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));
```

Value

Description

`START`  (default)

Left-aligns items for left-to-right language text (e.g., English). For right-to-left languages (e.g., Arabic, Hebrew), it right-aligns items.

`CENTER`

Centers items, horizontally.

`END`

Right-aligns for left-to-right language text. For right-to-left languages, it left-aligns items.

`STRETCH`

Stretches horizontally items with undefined width.

It’s also possible to align horizontally individual components by overriding the general alignment setting of the layout.

```java
Button button1 = new Button("Button 1");
Button button2 = new Button("Button 2");
button1.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
VerticalLayout layout = new VerticalLayout();
layout.add(button1);
layout.setAlignSelf(Alignment.END, button1);
layout.add(button2);
layout.setAlignSelf(Alignment.CENTER, button2);
layout.setAlignItems(FlexComponent.Alignment.START);
layout.add(new Button("Button 3"));
```

## Spacing

Spacing is used to create space between components in the same layout. Spacing can help prevent misclicks and distinguish content areas.

```java
VerticalLayout layout = new VerticalLayout();
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Spacing");
radioButtonGroup.setItems(ENABLED_OPTION, DISABLED_OPTION);
radioButtonGroup.setValue(ENABLED_OPTION);
radioButtonGroup.addValueChangeListener(
        e -> layout.setSpacing(ENABLED_OPTION.equals(e.getValue())));
```

Five different spacing theme variants are available:

```java
VerticalLayout layout = new VerticalLayout();
layout.setSpacing(false);
layout.getThemeList().add(SPACING_XL_THEME);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Spacing variant");
radioButtonGroup.setItems(SPACING_XS_THEME, SPACING_S_THEME,
        SPACING_THEME, SPACING_L_THEME, SPACING_XL_THEME);
radioButtonGroup.setValue(SPACING_XL_THEME);
radioButtonGroup.addValueChangeListener(e -> {
    layout.getThemeList().remove(e.getOldValue());
    layout.getThemeList().add(e.getValue());
});
```

Theme Variant

Usage Recommendation

`spacing-xs`

Extra-small space between items.

`spacing-s`

Small space between items.

`spacing`

Medium space between items.

`spacing-l`

Large space between items.

`spacing-xl`

Extra-large space between items.

```typescript
<vaadin-vertical-layout
  theme="spacing-xs padding">
</vaadin-vertical-layout>
```

## Padding

Padding is the space allocated between the content in a layout and the outer border. This should not be confused with Margin, which is explained in the next section.

Padding can help distinguish the content in a layout from its surrounding. Padding is applied using the padding theme variant.

```java
VerticalLayout layout = new VerticalLayout();
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Padding");
radioButtonGroup.setItems(ENABLED_OPTION, DISABLED_OPTION);
radioButtonGroup.setValue(ENABLED_OPTION);
radioButtonGroup.addValueChangeListener(
        e -> layout.setPadding(ENABLED_OPTION.equals(e.getValue())));
```

## Margin

Margin is the space around a layout. This is different from Padding, which is explained in the previous section.

```java
VerticalLayout layout = new VerticalLayout();
layout.setWidth("auto");
layout.setMargin(true);
layout.setAlignItems(FlexComponent.Alignment.STRETCH);
layout.add(new Button("Button 1"));
layout.add(new Button("Button 2"));
layout.add(new Button("Button 3"));

RadioButtonGroup<String> radioButtonGroup = new RadioButtonGroup<>();
radioButtonGroup.setLabel("Margin");
radioButtonGroup.setItems(ENABLED_OPTION, DISABLED_OPTION);
radioButtonGroup.setValue(ENABLED_OPTION);
radioButtonGroup.addValueChangeListener(
        e -> layout.setMargin(ENABLED_OPTION.equals(e.getValue())));
```

# Virtual List

Virtual List allows you to render a long list of items inside a scrollable container without sacrificing performance. Each item is rendered on the fly as the user scrolls the list.

To use this component, you need to assign it a set of data items and a  _renderer_  that’s used to render each individual data item. The height of an item is determined by its content and can change dynamically.

```java
VirtualList<Person> list = new VirtualList<>();
list.setItems(people);
list.setRenderer(personCardRenderer);
add(list);
```

# Architecture

## Designing the Architecture

Software architecture is a wide concept. No one thing is the software architecture. It has many aspects and can be looked at from various points of view. This page presents only one of them: the structure of the software.

To explain a software architecture design to other developers, you need a good way of visualizing it. You’ve probably seen an architecture diagram. These aren’t always helpful. Often, they are an incoherent and inconsistent mess of boxes and arrows that confuse rather than clarify. At the other end of the spectrum, you’ll find dedicated modeling tools that use industry-standard notations such as Unified Modeling Language (UML) or Systems Modeling Language (SysML). These are without doubt useful but require you to learn a new notation and buy a dedicated modeling tool.

Fortunately, there is a middle way called the  _C4 model_. C4 is a model for visualizing software architecture in a notation and tooling-independent manner. The model is presented in detail at  [c4model.com](https://c4model.com/), but the main ideas are summarized on this page.

The C4 model takes its inspiration from digital maps, where you can zoom in and zoom out. Higher zoom levels offer a better overview but have fewer details, whereas lower levels have more details while providing less overview. C4 allows you to create "maps" of your code and provides four zoom levels for you to use: Context, Containers, Components, and Code. You’re not required to use all levels. It’s fine to omit a level if you don’t find it useful. There’s no point in drawing diagrams for their own sake.

## Context

A  _system context diagram_  is the highest level and a good starting point for new architecture. It depicts how the system you intend to build fits into the environment around it. It includes information about the users of the system and any external system with which it integrates. It doesn’t contain any technical information at all: that’s reserved for the lower levels.

Here is an example system context diagram of a fictional appointment scheduling system:

![A system context diagram of a fictional appointment scheduling system](https://vaadin.com/docs/latest/static/e5b6e4df5261640c8fdd73b79ab28701/87264/c4-context.png)

You can see that the system has two different types of users: employees and customers. You can also see that the system integrates with two external systems: a Customer Resource Management (CRM) system for storing customer information, and an online mailing service for sending emails to customers.

The notation is simple: it consists of boxes, circles, lines, and text. It’s important to remember to annotate the lines as well, as they describe the dynamics of the system. Observing the dynamics of a system can often tell you more than only looking at its static structure. For instance, if you left out the text from all the boxes in  [the previous diagram](https://vaadin.com/docs/latest/building-apps/architecture/design#c4-context), you could still understand what they mean from the annotated arrows.

You can add as much or as little text as you want, as long as it tells the story you want to tell. In the previous diagram you could, for instance, make the users larger and include more detailed descriptions of why each user might want to use the system.

## Containers

If you were to zoom in on the software system in the context diagram, you’d get to the second level: a  _container diagram_. In the C4 context, a container is either a deployable  _application_  or a  _data store_. It has nothing to do with Docker containers — even though you may later package your applications as such. A container diagram shows the deployable parts of the system and how they interact with each other and any external systems.

Continuing with the fictional appointment scheduling system example, zooming in on the system box gives the following container diagram:

![A container diagram of a fictional appointment scheduling system](https://vaadin.com/docs/latest/static/3cacb5fc01ea1d64d0c21b3c79a8302d/cb524/c4-container.png)

As you can see, the diagram reveals a lot more details than the context diagram. You can see that the system consists of six containers: two web browsers (the employee’s and the customer’s), two Vaadin applications, a Hazelcast shared cache and a PostgreSQL database. You can see that the employee-facing user interface is using Flow and the customer-facing user interface is using Hilla and React. You can also see how the containers communicate with each other and with the external systems.

The notation follows the same pattern as the system context diagram: boxes, circles, lines, and text. You can add as many details as needed. For instance, if modeling the web browsers as separate containers isn’t relevant, you could simplify the diagram like this:


![A simplified container diagram of a fictional appointment scheduling system](https://vaadin.com/docs/latest/static/8f71e89e49aba1d6dc984190b9ef52b4/5dba3/c4-container-simplified.png)

A Vaadin developer would be able to deduce from this diagram that the users are using their web browsers to interact with the applications.

## Components

If you were to zoom in on a container in the container diagram, you would get the third level: a  _component diagram_. The term  _component_  is used quite liberally in the software industry, often for different things depending on the context. In the C4 context, the term component is defined as an encapsulation of related functionality that has a well-defined interface and that can be instantiated.

However, as Vaadin also uses components to construct user interfaces, it makes sense to further the scope and type of a component with a prefix. Therefore, the components that you find in a component diagram are  _system components_  and the components you find in a Vaadin user interface are  _UI components_.

A component diagram shows how a container like a Vaadin application is constructed from system components. It includes information about the components' responsibilities, how they are implemented, and how they interact.

Continuing with the fictional appointment scheduling system example, zooming in on the scheduling application container gives the following component diagram:

![A component diagram of a scheduling application](https://vaadin.com/docs/latest/static/f0090c47b1d28e5449453877d930e692/a68d2/c4-component.png)

As you can see, the notation is again the same as in the past two levels.

If you had access to the source code of the scheduling application, this diagram would already be quite helpful in navigating it. You can see that there are six system components:

-   The  _Views_  system component contains the Flow user interface.

-   The  _Booking App Endpoints_  system component contains the  [gRPC](https://grpc.io/)  endpoints that the Booking App uses.

-   The  _Application Services_  system component contains the business logic of the entire application. It has an API that is called by both  _Views_  and  _Booking App Endpoints_.

-   The  _Entities_  system component contains the entities and repositories and uses Spring Data and JPA. It has an API that’s called by  _Application Services_.

-   The  _CRM Integration_  and  _Online Mailing Service Integration_  system components act as adapters between the scheduling application and the external CRM system and online mailing service, respectively. They both implement Service Provider Interfaces (SPI) that  _Application Services_  has defined.


Getting the system components right is essential to succeeding in building great Vaadin applications. You can learn more about APIs and SPIs of system components and how to turn system components into Java code on the  [System Components](https://vaadin.com/docs/latest/building-apps/architecture/components)  page.

## Code

If you were to zoom in on a system component in the component diagram, you would get to the fourth and final level: a  _code diagram_. This shows how a system component has been implemented in code and is typically drawn using UML or some other standard notation for code design. It’s the most detailed of all the diagrams and, therefore, likely the one you’ll use the least.

The code is the ultimate source of truth and it changes often, especially at the beginning of a project. This means that any code diagrams you draw are likely to become outdated at some point. It’s therefore recommended to make code diagrams only for the most complex components. You can keep them up to date or discard them when they are no longer useful. The main point is to only draw the diagrams that help you tell the story and get the job done.

# System Components
The  [Designing the Architecture](https://vaadin.com/docs/latest/building-apps/architecture/design)  page of the documentation discussed  _system components_  and  _UI components_. This page provides more about system components and how to turn them into Java code.

Vaadin applications are composed of system components, one of which is the user interface. The number of system components depends on the size and complexity of the application. A small application could have only one component. A large application might have ten or twenty components.

Here is an example of a Vaadin application with three components:

![A diagram of three system components and a database](https://vaadin.com/docs/latest/static/fc9e38f31112af10dc7502560cf2efa1/c1f19/three-components.png)

In this example, the  _Views_  component talks to the  _Services_  component. The  _Services_  component in turn talks to the  _Entities_  component, which uses JPA to communicate with a relational database.

## Components in Java

The Java programming language has no component construct. Instead, you would use Java packages to model components. Thus,  [the previous component diagram](https://vaadin.com/docs/latest/building-apps/architecture/components#three-system-components)  would correspond to the following Java package structure:

-   `com.example.application`  is a root package that contains the Spring Boot application class.

-   `com.example.application.views`  is a package corresponding to the  _views_  system component.

-   `com.example.application.services`  is the package corresponding to the  _services_  system component.

-   `com.example.application.entities`  is the package corresponding to the  _entities_  system component.


For small system components, a package per component is enough. However, in more complex cases, you’ll often need to create sub-packages to keep the code organized. You may also need to organize the system component packages themselves into parent packages.

## Application Programming Interfaces

A system component can have an  _Application Programming Interface_  (API) that allows other components to  _call_  it. However, system components are not required to make themselves available to other components. For instance, a user interface system component is typically only called by the web browser and never by other system components. Therefore, it doesn’t need an API at all.

In Java, the API consists of all  _public_  classes, interfaces and methods inside the system component package. In other words, the simplest possible component with an API is a package that contains a single public Java class, that in turn contains a single public method.

All classes or methods that are not considered a part of the API should have a different visibility than public, such as package private.

A system component can inherit the API of another component on which it depends. For instance,  [in the example](https://vaadin.com/docs/latest/building-apps/architecture/components#three-system-components), the services component can inherit the API of the entities component, like this:

```java
package com.example.application.services;

import com.example.application.entities.OrderRepository;
import com.example.application.entities.DraftOrder;
import com.example.application.entities.CompletedOrder;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderService { 1

    private final OrderRepository repository;

    OrderService(OrderRepository repository) { 2
        this.repository = repository;
    }

    @Transactional
    public CompletedOrder completeOrder(DraftOrder draftOrder) { 3
        var completedOrder = draftOrder.complete();
        return repository.save(completedOrder);
    }
}
```

1.  `OrderService`  is a part of the API, so it’s  _public_.

2.  The services system component handles instantiating the service itself. The constructor is  _package private_, as it is not part of the API.

3.  `completeOrder`  is a part of the API, so it’s  _public_.  `DraftOrder`  and  `CompletedOrder`  are inherited from the API of the entities system component.


As you can see, you’re not required to use Java interfaces for the API unless you need or want to use them.

## Service Provider Interfaces

A system component can also have a  _Service Provider Interface_  (SPI) that allows other components to plug into it. This is useful in cases where a component needs to interact with an external system, or when a component needs to externalize some business rules to another component.

An SPI is an interface that one component  _declares_, and another component  _implements_. In Java, it consists of at least one Java interface and optionally other types that the interface needs. For example, if the interface needs a Java class or a Java record as an input argument or return value, this would be a part of the SPI as well. An SPI is also allowed to include types from the system component’s API.

[In the example](https://vaadin.com/docs/latest/building-apps/architecture/components#three-system-components), the services system component may need to integrate with an external system. Instead of putting all the code inside a single component, the service components declare an SPI. Then, a new system integration component is created that implements this SPI and handles the actual interaction with the external system:

![A diagram of four system components](https://vaadin.com/docs/latest/static/f19e04e79cb17315052b8f95b3e341af/a78ed/components-with-spi.png)

This not only separates the concerns but also protects the application from changes in the external system. If the external system’s API changes, you only need to fix the system integration component. The rest of the system components can remain unchanged.

To distinguish between API and SPI classes and interfaces, you can put the SPI classes and interfaces inside a sub-package named  `spi`.  [In the example](https://vaadin.com/docs/latest/building-apps/architecture/components#three-system-components), the SPI could look like this:


```java
package com.example.application.services.spi; 1

import com.example.application.entities.CompletedOrder;

public interface ShippingSystem {

    void shipCompletedOrder(CompletedOrder completedOrder); 2
}
```

1.  The interface is in the  `spi`  sub-package to make it clear that it’s intended to be implemented by another system component.

2.  The  `CompletedOrder`  class, which is inherited from the API of the entities system component, can also be used by the SPI.


Sometimes, an interface can act as both the API and the SPI of the component at the same time. A typical example of this is the repository interface of a domain model component:

![A diagram of three system components: Services, Domain Model and Persistence](https://vaadin.com/docs/latest/static/14abb21335333f8b3411e312e4388bf6/7ec6d/combined-spi-api.png)

The repository interface is part of the API of the domain model and called by the services system component. However, the repository interface is also a part of the SPI of the domain model and implemented by the persistence system component. The persistence system component, in turn, talks to the database. In this case, using a sub-package  `spi`  is only confusing. Instead, JavaDocs should be used to explain the roles of the interface. Sometimes you have to be pragmatic.

## Instantiating Components

As Java has no component construct, a component instance consists of ordinary Java objects during runtime. These objects are instantiated by Spring, which also takes care of setting up the dependencies between them through dependency injection. Use  _constructor injection_  into  _final_  fields instead of autowiring into mutable fields, like this:

```java
@Service
public class InvoiceGenerationService {

    private final InvoiceRepository invoiceRepository;
    private final AccountingSystem accountingSystem;
    private final ApplicationEventPublisher eventPublisher;

    InvoiceGenerationService(InvoiceRepository invoiceRepository,
                             AccountingSystem accountingSystem,
                             ApplicationEventPublisher eventPublisher) {
        this.invoiceRepository = invoiceRepository;
        this.accountingSystem = accountingSystem;
        this.eventPublisher = eventPublisher;
    }
}
```

Constructor injection has several benefits. First, it becomes clear what are the dependencies of the class. Second, it’s impossible to instantiate the class without the necessary dependencies. Third, it’s impossible to modify unintentionally the dependencies after instantiation. If the number of constructor arguments grows too large, the class has too many responsibilities and you should split it into smaller parts.

Usually, using Spring’s component scanning and stereotype annotations, such as  `@Component`  or  `@Service`, is enough to instantiate all the objects in your system component. However, if you need more fine-grained control over the object creation, you can use Spring’s Java-based container configuration. Inside your component, create a  `@Configuration`  annotated class and use  `@Bean`  methods to create the objects.

Unless you need to use the  `@Import`  annotation to import the configuration class into some other configuration class, you can make it package private. This makes it clear that the configuration is not considered part of the system component’s API.

If you’re not familiar with Spring’s Java-based container configuration, or you want to learn more about it, read the  [Spring Framework Documentation](https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html:).

## Conceptual Layers

If you have any previous experience with software architectures, you have probably heard about layers. You may have run into terms like “presentation layer”, “business logic layer”, “infrastructure layer”, etc. Layers can help you reason about the structure of the application, but they can also impose unnecessary restrictions. For instance, if you require that a layer can only depend on the layers below it, you can’t use Service Provider Interfaces (SPI). Because of this, you should focus on system components rather than layers in your Vaadin applications.

That said, two layers make sense to use in Vaadin applications as well: the  _presentation layer_  and the  _application layer_.

In traditional web applications, you have the  _frontend_  and the  _backend_. The frontend of the application runs inside the user’s web browser whereas the backend runs on the server. Furthermore, the frontend is more or less synonymous with the user interface of the application and the backend is the "business logic" or "everything else". In a Vaadin application, however, the terms frontend and backend can be confusing. Take a look at this diagram:

![A diagram illustrating the presentation layer and application layer of a Flow and a Hilla app](https://vaadin.com/docs/latest/static/3eb991a404a7f8704ac1d2f967f182cf/d1be9/layers.png)

When you are building your user interface with Flow, you write the user interface in Java and run it on the server - the backend. Unless you have created any web components of your own, all the code that runs in the browser — the frontend — is provided by Vaadin in one way or the other. The frontend and backend don’t map directly onto the user interface and business logic.

When you are building your user interface with Hilla, you write the user interface in React and run it in the browser. The rest of the application runs on the server. In this case, the frontend and backend correspond to the user interface and business logic.

It’s also possible to write hybrid applications, where you write some parts of the user interface in Java and other parts in React. In this case, parts of the user interface run in the browser and parts on the server.

Because of this, it makes more sense to talk about the presentation layer and the application layer, as opposed to the frontend and the backend, or the user interface and the business logic. It’s important to remember that these layers are  _conceptual_  rather than physical. In a Flow or hybrid application, the presentation layer covers both the browser and a part of the server. In a Hilla application, the presentation layer is limited to the browser alone. In all cases, the application layer resides on the server.

# Monoliths

In software engineering, a  _monolithic application_  is a single, self-contained application. All system components run inside the same executable and communicate with each other over function calls. The application typically provides a single but complete service to its users.

Although a monolith often requires some supporting services like a database or an authentication provider, it’s quite self-sufficient. In its simplest form, a monolithic application is a single executable that runs on a single server.

Even though monoliths are packaged as a single executable, they can still be modular.  _Modular monoliths_  introduce clear boundaries between the different parts of the application and define how these parts can communicate with each other. Some parts may not know about the existence of other parts. A good way of building modular monoliths is to design them using  [system components](https://vaadin.com/docs/latest/building-apps/architecture/components).

## Advantages

In the time of  [microservices](https://vaadin.com/docs/latest/building-apps/architecture/microservices), monoliths have received a bit of a bad reputation. That reputation is not entirely justified, as monoliths have several advantages compared to microservices.

### Simplicity

Monoliths, when done well, are easy to develop, test, debug, and deploy. The components are contained inside a single codebase, and can often be contained inside a single project in your IDE. You need only to test and debug a single executable. You don’t have to set up a lot of supporting services to deploy the monolith: often, the executable and a database are enough.

### Transactional Integrity

Since everything happens inside the same executable, you can rely on local transactions. You don’t have to worry about things like distributed transactions or sagas.

### Less Overhead

Most of the system components communicate over function calls rather than network calls. This often translates to better performance of the application.

## Disadvantages

Despite the advantages mentioned before, some negative feelings about monoliths are understandable. Monoliths have several disadvantages that you should consider when deciding what kind of system architecture to choose.

### Scalability Challenges

It is possible to scale a monolith. You can scale both up, by adding more hardware resources, and out, by deploying more instances of the monolith. However, you’re always scaling the entire application. If only some parts of it require scaling, you may waste resources that cost money.

You may also run into another type of scalability challenge: scaling the code. As the monolith grows and more features are added to it, increasing effort is needed to prevent the quality of the code from degrading. In the worst case, the monolith can degrade into an unmaintainable  [Big Ball of Mud](http://www.laputan.org/mud/mud.html#BigBallOfMud).

### Continuous Deployment Challenges

Although you can use continuous deployment with a monolith, even small changes require rebuilding and deploying the entire application. If you haven’t set up session replication and rolling updates, every redeployment means downtime for your users.

### Team Collaboration Challenges

A monolith should be owned by one team, only. If you have more than one team working on the same application, you have to be sure to keep the teams aligned. The risk of conflicts in design, source control, release cadence, etc. increases.

## When to Use

Regardless of the disadvantages, most business applications should be monoliths. If your application provides a single service to a limited number of users in a limited geographical area, a monolith gets the job done.

Microservices come with many buzzwords, like endless scalability and improved resiliency. They sound nice to have, but they come with a cost. You have to decide if your application is worth that cost, or whether the time and money would be better spent on something else. Often, you can achieve the qualities you need (e.g., scalability, availability, and performance) without switching to microservices. Choosing microservices only because everybody else is doing it is not a good reason.

You can do some future-proofing by making your monolith modular. A well-designed, modular monolith is easier to split into microservices in the future, should the need arise.

# Microservices
Microservices is an architectural style that deconstructs a system into a collection of  _loosely coupled_  and  _independently deployable_  services. Each microservice is centered around a specific business capability and is developed, deployed and scaled independently, typically by one team. A microservice typically has its own database that’s not shared with any other service.

Microservices interact over network calls and can therefore be built using different programming languages and frameworks, as long as the communication protocols (such as gRPC and JSON/REST/HTTP) are compatible. Because microservices can go down and back up at any time, they have to be resilient by design. A service calling another service should remain operational even if the other service is unavailable.

You can read more about microservices at, for example,  [martinfowler.com](https://martinfowler.com/microservices/),  [microservices.io](https://microservices.io/), or  [Wikipedia](https://microservices.io/).

## Microservices & Vaadin

Vaadin is not itself a platform for building microservices. However, you can build and deploy Vaadin applications for microservice environments. Since Vaadin applications are Spring Boot applications, they function well together with  [Spring Cloud](https://spring.io/projects/spring-cloud).

The two primary use cases for Vaadin in a microservice environment are building  _dedicated_  user interfaces, and building  _aggregating_  user interfaces. These are described next. If your use case doesn’t fall in either of these categories, you may need to use something else for your user interface.

### Dedicated User Interfaces

Some microservices can have their own user interfaces. For example, if a particular department within a larger organization has its own microservice, it makes sense that the user interface is also specific to that department. Since the microservice is designed for internal use, it’s not likely to require as much scaling as, for example, a public-facing webshop. Therefore, it makes more sense to build the microservice as a Vaadin application, with its own Vaadin user interface. The service can still expose an API for other microservices to use.

Look at the following example:

![A diagram of a system with three separate microservices with dedicated user interfaces](https://vaadin.com/docs/latest/static/9456cae24ec07d37c7a985bfd61948a0/ba112/microservices-dedicated.png)

In this fictional organization, orders, invoicing and shipping are handled by separate departments. Each department has its own microservice with a Vaadin UI specialized for their needs. The microservices are also communicating with each other through an event bus.

### Aggregating User Interfaces

Sometimes, you may have to build a user interface for a specific group of users that need to interact with multiple microservices through some API. In this case, the user interface alone becomes a microservice itself, but without an API. The user interface aggregates multiple microservices into a holistic user experience, preventing the user from having to jump between multiple user interfaces in their day-to-day work.

Look at the following example:

![A diagram of a system with three separate microservices that share the same user interface](https://vaadin.com/docs/latest/static/ba91d96be10339f9400f6b60a83e0ef5/22b39/microservices-aggregating.png)

In this fictional organization, the warehouse workers need access to both the product catalog, the inventory service and the shipping service. These microservices are all maintained by different teams, who use different frameworks (such as Spring Boot, Node.js and .NET) to build them. The microservices expose REST APIs for the user interface to use while communicating with each other through an event bus.

The warehouse UI is a Vaadin application that provides not only the user interface itself but also acts as its own  _API gateway_. In other words, there’s no need to set up a separate API gateway since the Vaadin application can communicate directly with the other microservices. This is effectively the Backend For Frontend (BFF) pattern.

## Advantages

Microservices emerged over a long period in response to a particular set of problems that they are good at solving. Here are the main benefits of building microservice-based systems:

### Targeted Scalability

You can scale specific microservices according to demand. This is beneficial if different parts of the system have varying loads. By only scaling the parts that need it, you can use the hardware resources more efficiently, thereby saving money.

### Flexibility in Technology

Since the microservices are decoupled and communicate over standardized network protocols, the teams can choose the best technology stack for their requirements. This also reduces the risk of vendor-lock-in.

### Resilience

Well-designed microservices can handle failures gracefully, either by degrading functionality or by employing fallback mechanisms. Given the fact that they are also loosely coupled and independently deployable, the system as a whole becomes more resilient to disturbances. The failure of a single service won’t take down the entire system.

### Continuous Deployment

Teams can work on their own microservices at their own pace and deploy them as often as they like, without affecting the rest of the system. Microservices can be developed in parallel and features can be deployed faster.

## Disadvantages

Microservices are useful for solving a certain class of problems. For other problems, they may be overkill — or perhaps not suitable at all. Here are the main drawbacks of building microservice-based systems:

### Increased Complexity

As the number of microservices increases, so does the number of moving parts. Getting these parts to interact efficiently and consistently isn’t easy. Data integrity is harder to achieve when multiple services are involved in implementing the same business process, especially when any of these services can go down at any time.

If you’re not careful, your efforts may result in a distributed monolith that has none of the advantages of microservices, but all the disadvantages. In the worst case, you may end up with a  _Distributed Ball of Mud_, which is even worse than a  [Big Ball of Mud](http://www.laputan.org/mud/mud.html#BigBallOfMud).

### Technology Creep

Letting teams choose their own technology stacks was listed earlier as an advantage, but that can also be a disadvantage. Having too many technology stacks can make it more difficult to move developers between teams, which is a risk for the organization. Furthermore, the development and deployment environment — with its continuous delivery chains and all — becomes more complicated the more technology stacks it needs to support.

### Communication Overhead

Microservices communicate over network calls, which are inherently slower than function calls. Furthermore, network calls are inherently less secure than function calls: They require more overhead for encryption, decryption, authentication, etc. If not managed, this leads to poor performance of the system.

### Testing & Debugging Challenges

A distributed system consisting of multiple processes is more difficult to test and debug than a single process running on a single machine. The root cause of an issue observed in one microservice may be in a different microservice.

## When to Use

Microservices have their advantages and disadvantages. It’s important to know when it’s a good choice. In summary, here are some factors that should exist for it to be the right choice:

-   You have more than one team working on the system.

-   Your system is providing more than one service to more than one group of users.

-   You need to be able to redeploy parts of your system without affecting others.

-   Different parts of the system have different loads, requiring different scaling.

-   You know how to build microservices or already have a microservice environment up and running.


Before you start a new microservice-based project, you should consider whether a  [monolith](https://vaadin.com/docs/latest/building-apps/architecture/monoliths)  would be enough to get the job done.

